<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation · FiniteVolumeMethod.jl</title><meta name="title" content="Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation · FiniteVolumeMethod.jl"/><meta property="og:title" content="Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation · FiniteVolumeMethod.jl"/><meta property="twitter:title" content="Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation · FiniteVolumeMethod.jl"/><meta name="description" content="Documentation for FiniteVolumeMethod.jl."/><meta property="og:description" content="Documentation for FiniteVolumeMethod.jl."/><meta property="twitter:description" content="Documentation for FiniteVolumeMethod.jl."/><meta property="og:url" content="https://SciML.github.io/FiniteVolumeMethod.jl/tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/"/><meta property="twitter:url" content="https://SciML.github.io/FiniteVolumeMethod.jl/tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/"/><link rel="canonical" href="https://SciML.github.io/FiniteVolumeMethod.jl/tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">FiniteVolumeMethod.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../interface/">Interface</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../overview/">Section Overview</a></li><li><a class="tocitem" href="../diffusion_equation_on_a_square_plate/">Diffusion Equation on a Square Plate</a></li><li><a class="tocitem" href="../diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/">Diffusion Equation in a Wedge with Mixed Boundary Conditions</a></li><li><a class="tocitem" href="../reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/">Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk</a></li><li><a class="tocitem" href="../porous_medium_equation/">Porous-Medium Equation</a></li><li><a class="tocitem" href="../porous_fisher_equation_and_travelling_waves/">Porous-Fisher Equation and Travelling Waves</a></li><li class="is-active"><a class="tocitem" href>Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation</a><ul class="internal"><li><a class="tocitem" href="#Solving-the-problem"><span>Solving the problem</span></a></li><li><a class="tocitem" href="#Piecewise-linear-interpolation"><span>Piecewise linear interpolation</span></a></li><li><a class="tocitem" href="#Natural-neighbour-interpolation"><span>Natural neighbour interpolation</span></a></li><li><a class="tocitem" href="#Just-the-code"><span>Just the code</span></a></li></ul></li><li><a class="tocitem" href="../helmholtz_equation_with_inhomogeneous_boundary_conditions/">Helmholtz Equation with Inhomogeneous Boundary Conditions</a></li><li><a class="tocitem" href="../laplaces_equation_with_internal_dirichlet_conditions/">Laplace&#39;s Equation with Internal Dirichlet Conditions</a></li><li><a class="tocitem" href="../equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/">Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems</a></li><li><a class="tocitem" href="../reaction_diffusion_brusselator_system_of_pdes/">A Reaction-Diffusion Brusselator System of PDEs</a></li><li><a class="tocitem" href="../gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/">Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System</a></li><li><a class="tocitem" href="../diffusion_equation_on_an_annulus/">Diffusion Equation on an Annulus</a></li><li><a class="tocitem" href="../mean_exit_time/">Mean Exit Time</a></li><li><a class="tocitem" href="../solving_mazes_with_laplaces_equation/">Solving Mazes with Laplace&#39;s Equation</a></li><li><a class="tocitem" href="../keller_segel_chemotaxis/">Keller-Segel Model of Chemotaxis</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Solvers for Specific Problems, and Writing Your Own</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../wyos/overview/">Section Overview</a></li><li><a class="tocitem" href="../../wyos/diffusion_equations/">Diffusion Equations</a></li><li><a class="tocitem" href="../../wyos/mean_exit_time/">Mean Exit Time Problems</a></li><li><a class="tocitem" href="../../wyos/linear_reaction_diffusion_equations/">Linear Reaction-Diffusion Equations</a></li><li><a class="tocitem" href="../../wyos/poissons_equation/">Poisson&#39;s Equation</a></li><li><a class="tocitem" href="../../wyos/laplaces_equation/">Laplace&#39;s Equation</a></li></ul></li><li><a class="tocitem" href="../../math/">Mathematical and Implementation Details</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/FiniteVolumeMethod.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/FiniteVolumeMethod.jl/tree/main/docs/src/literate_tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation.jl" title="View source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Piecewise-Linear-and-Natural-Neighbour-Inteprolation-for-an-Advection-Diffusion-Equation"><a class="docs-heading-anchor" href="#Piecewise-Linear-and-Natural-Neighbour-Inteprolation-for-an-Advection-Diffusion-Equation">Piecewise Linear and Natural Neighbour Inteprolation for an Advection-Diffusion Equation</a><a id="Piecewise-Linear-and-Natural-Neighbour-Inteprolation-for-an-Advection-Diffusion-Equation-1"></a><a class="docs-heading-anchor-permalink" href="#Piecewise-Linear-and-Natural-Neighbour-Inteprolation-for-an-Advection-Diffusion-Equation" title="Permalink"></a></h1><p>In this tutorial, we have three aims:</p><ol><li>Demonstrate how to solve an advection-diffusion equation.</li><li>Demonstrate how piecewise linear interpolation can be applied to a PDE solution at each time.</li><li>Demonstrate how  <a href="https://github.com/DanielVandH/NaturalNeighbours.jl">NaturalNeighbours.jl</a> can be applied to compute more accurate interpolants than piecewise linear interpolation at each time.</li></ol><p>The equation we will be considering is</p><p class="math-container">\[\begin{equation}\label{eq:advdiffeq}
\begin{aligned}
\pdv{u}{t} &amp;= D\pdv[2]{u}{x} + D\pdv[2]{u}{y} - \nu\pdv{u}{x},
\end{aligned}
\end{equation}\]</p><p>with <span>$u(\vb x, 0) = \delta(\vb x)$</span> and homogeneous Dirichlet conditions, where <span>$\delta$</span> is the Dirac delta function. This equation is defined on <span>$\mathbb R^2$</span>, but we will replace <span>$\mathbb R^2$</span> with <span>$\Omega = [-L, L]^2$</span> for <span>$L = 30$</span>.</p><h2 id="Solving-the-problem"><a class="docs-heading-anchor" href="#Solving-the-problem">Solving the problem</a><a id="Solving-the-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-the-problem" title="Permalink"></a></h2><p>We start by defining and solving the problem associated with \eqref{eq:advdiffeq}. For the mesh, we could use <code>triangulate_rectangle</code>, but we want to put most of the triangles near the origin, so we need to use <code>refine!</code> on an initial mesh.</p><pre><code class="language-julia hljs">using DelaunayTriangulation, FiniteVolumeMethod, LinearAlgebra, CairoMakie
L = 30
tri = triangulate_rectangle(-L, L, -L, L, 2, 2, single_boundary=true)
tot_area = get_area(tri)
max_area_function = (A, r) -&gt; 1e-6tot_area * r^2 / A
area_constraint = (_tri, T) -&gt; begin
    u, v, w = triangle_vertices(T)
    p, q, r = get_point(_tri, u, v, w)
    c = (p .+ q .+ r) ./ 3
    dist_to_origin = norm(c)
    A = DelaunayTriangulation.triangle_area(p, q, r)
    flag = A ≥ max_area_function(A, dist_to_origin)
    return flag
end
refine!(tri; min_angle=33.0, custom_constraint=area_constraint)
triplot(tri)</code></pre><img src="f3689285.png" alt="Example block output"/><pre><code class="language-julia hljs">mesh = FVMGeometry(tri)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">FVMGeometry with 5000 control volumes, 9863 triangles, and 14862 edges</code></pre><p>The boundary conditions are homogeneous <code>Dirichlet</code> conditions.</p><pre><code class="language-julia hljs">BCs = BoundaryConditions(mesh, (x, y, t, u, p) -&gt; zero(u), Dirichlet)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BoundaryConditions with 1 boundary condition with type Dirichlet</code></pre><p>We now need to define the actual problem. We need to write \eqref{eq:advdiffeq} in the form</p><p class="math-container">\[\pdv{u}{t} + \div\vb q = 0.\]</p><p>To do this, write:</p><p class="math-container">\[\begin{align*}
\div \vb q &amp;= \nu\pdv{u}{x} - D\pdv[2]{u}{x} - D\pdv[2]{u}{y} \\
&amp;= \pdv{x}\left(\nu u - D\pdv{u}{x}\right) - \pdv{y}\left(D\pdv{u}{y}\right) \\
&amp;= \div \begin{bmatrix} \nu u - D\pdv{u}{x} &amp; -D\pdv{u}{y} \end{bmatrix}^{\mkern-1.5mu\mathsf{T}} \\
&amp;= \div \left(\boldsymbol\nu u - D\grad u\right),
\end{align*}\]</p><p>where <span>$\boldsymbol\nu = (\nu, 0)^{\mkern-1.5mu\mathsf{T}}$</span>. Thus, we can write</p><p class="math-container">\[\vb q = \boldsymbol\nu u - D\grad u.\]</p><p>We now have our flux function. Next, let us define the initial condition. We approximate by</p><p class="math-container">\[\delta(\vb x) \approx g(\vb x) \approx \frac{1}{\varepsilon^2\pi}\exp\left[-\frac{1}{\varepsilon^2}\left(x^2+y^2\right)\right],\]</p><p>taking <span>$\varepsilon=1/10$</span>. We can now define the problem. Remember that the flux function takes argument <span>$(\alpha, \beta, \gamma)$</span> rather than <span>$u$</span>, replacing <span>$u$</span> with <span>$u(x, y) = \alpha x + \beta y + \gamma$</span>, and it returns a <code>Tuple</code> representing the vector. We let <span>$D = 0.02$</span> and <span>$\nu = 0.05$</span>.</p><pre><code class="language-julia hljs">ε = 1 / 10
f = (x, y) -&gt; 1 / (ε^2 * π) * exp(-(x^2 + y^2) / ε^2)
initial_condition = [f(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)]
flux_function = (x, y, t, α, β, γ, p) -&gt; begin
    ∂x = α
    ∂y = β
    u = α * x + β * y + γ
    qx = p.ν * u - p.D * ∂x
    qy = -p.D * ∂y
    return (qx, qy)
end
flux_parameters = (D=0.02, ν=0.05)
final_time = 250.0
prob = FVMProblem(mesh, BCs;
    initial_condition,
    flux_function,
    flux_parameters,
    final_time)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">FVMProblem with 5000 nodes and time span (0.0, 250.0)</code></pre><p>Now we can solve and visualise the solution.</p><pre><code class="language-julia hljs">using OrdinaryDiffEq, LinearSolve
times = [0, 10, 25, 50, 100, 200, 250]
sol = solve(prob, TRBDF2(linsolve=KLUFactorization()), saveat=times)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
Interpolation: 1st order linear
t: 7-element Vector{Float64}:
   0.0
  10.0
  25.0
  50.0
 100.0
 200.0
 250.0
u: 7-element Vector{Vector{Float64}}:
 [0.0, 0.0, 0.0, 0.0, 31.830988618379067, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
 [0.0, 0.0, 0.0, 0.0, 31.830988618379067, 0.0, 0.0, 0.0, 0.0, 0.0  …  4.066753277540322e-43, 2.8488474322795543e-43, 4.315187764870875e-45, 2.3763698684298e-60, 9.538998133281113e-76, 2.739164872714823e-13, 6.674334606384418e-34, 1.5161331091198345e-34, 1.8260620142440974e-53, 8.086415835844593e-49]
 [0.0, 0.0, 0.0, 0.0, 31.830988618379067, 0.0, 0.0, 0.0, 0.0, 0.0  …  8.23391997022047e-30, 5.220549814653682e-30, 1.665040775330767e-31, 1.6287700877090987e-44, 1.3043455222872805e-61, 3.6821472458732825e-9, 6.863512829318162e-25, 3.6771170552058965e-25, 9.979807767569023e-39, 7.218675196322838e-39]
 [0.0, 0.0, 0.0, 0.0, 31.830988618379067, 0.0, 0.0, 0.0, 0.0, 0.0  …  1.0037247923574523e-20, 6.17993998587632e-21, 3.772815609901226e-22, 3.521549469355037e-33, 6.765897480868023e-52, 1.1196445589629383e-7, 4.205657619757498e-19, 4.536546819359947e-19, 7.4693580958375195e-28, 2.083588318564695e-32]
 [0.0, 0.0, 0.0, 0.0, 31.830988618379067, 0.0, 0.0, 0.0, 0.0, 0.0  …  4.908458497667812e-13, 2.9060727865728184e-13, 3.5971580000417557e-14, 5.312123913386845e-23, 1.4276295087831808e-43, 1.8093743100641382e-7, 9.27098723225602e-15, 2.192002102304295e-14, 3.594755349154432e-18, -1.6298087013358494e-26]
 [0.0, 0.0, 0.0, 0.0, 31.830988618379067, 0.0, 0.0, 0.0, 0.0, 0.0  …  3.0829497438864826e-7, 1.685120218904999e-7, 4.4773936794186886e-8, 2.1269125888694875e-14, 2.869025096521627e-37, 1.4318543489079493e-8, 8.618275784888957e-13, 7.143467422040313e-12, 2.740717522881799e-10, 6.812201191203553e-24]
 [0.0, 0.0, 0.0, 0.0, 31.830988618379067, 0.0, 0.0, 0.0, 0.0, 0.0  …  6.328015246343963e-6, 3.345492869067269e-6, 1.1443535522097138e-6, 4.276332819229381e-12, 7.548437172778271e-36, 2.862046871670017e-9, 1.7195462706059908e-13, 1.0367224737470748e-11, 2.6911442304263533e-8, 1.1926434933074073e-21]</code></pre><pre><code class="language- hljs">using CairoMakie
fig = Figure(fontsize=38)
for i in eachindex(sol)
    ax = Axis(fig[1, i], width=400, height=400,
        xlabel=&quot;x&quot;, ylabel=&quot;y&quot;,
        title=&quot;t = $(sol.t[i])&quot;,
        titlealign=:left)
    tricontourf!(ax, tri, sol.u[i], levels=0:0.00001:0.001, extendhigh=:auto, extendlow=:auto, colormap=:matter)
    tightlimits!(ax)
    ylims!(ax, -10, 10)
end
resize_to_layout!(fig)
fig

        !DelaunayTriangulation.has_vertex(tri, i) &amp;&amp; continue</code></pre><h2 id="Piecewise-linear-interpolation"><a class="docs-heading-anchor" href="#Piecewise-linear-interpolation">Piecewise linear interpolation</a><a id="Piecewise-linear-interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Piecewise-linear-interpolation" title="Permalink"></a></h2><p>As mentioned in <a href="../../math/">mathematical details section</a>, a key part of the finite volume method is the assumption that <span>$u$</span> is piecewise linear between each triangular element, letting <span>$u(x, y) = \alpha x + \beta y + \gamma$</span>. Thus, it may be natural to want to interpolate the solution using piecewise linear interpolation. This could be done by making use of <code>jump_and_march</code> from DelaunayTriangulation.jl to find the triangle containing a given point <span>$(x, y)$</span> and then use <code>pl_interpolate</code> to interpolate the solution at the point; we do not provide a method that gets this triangle for you and then interpolates without this intermediate <code>jump_and_march</code>, as it is typically more efficient to first obtain all the triangles you need and then interpolate. In what follows, we:</p><ol><li>Define a grid to interpolate over.</li><li>Find the triangles containing each point in the grid.</li><li>Interpolate at each point for the given times.</li></ol><p>We consider the times <span>$t = 10, 25, 50, 100, 200, 250$</span>. You could also of course amend the procedure so that you evaluate the interpolant at each time for a given point first, allowing you to avoid storing the triangle since you only consider each point a single time.</p><pre><code class="language-julia hljs">x = LinRange(-L, L, 250)
y = LinRange(-L, L, 250)
triangles = Matrix{NTuple{3,Int}}(undef, length(x), length(y))
for j in eachindex(y)
    for i in eachindex(x)
        triangles[i, j] = jump_and_march(tri, (x[i], y[j]))
    end
end
interpolated_vals = zeros(length(x), length(y), length(sol))
for k in eachindex(sol)
    for j in eachindex(y)
        for i in eachindex(x)
            interpolated_vals[i, j, k] = pl_interpolate(prob, triangles[i, j], sol.u[k], x[i], y[j])
        end
    end
end</code></pre><p>Let&#39;s visualise these results to check their accuracy. We compute the triangulation of our grid to make the <code>tricontourf</code> call faster.</p><pre><code class="language-julia hljs">_tri = triangulate([[x for x in x, _ in y] |&gt; vec [y for _ in x, y in y] |&gt; vec]&#39;)
fig = Figure(fontsize=38)
for i in eachindex(sol)
    ax = Axis(fig[1, i], width=400, height=400,
        xlabel=&quot;x&quot;, ylabel=&quot;y&quot;,
        title=&quot;t = $(sol.t[i])&quot;,
        titlealign=:left)
    tricontourf!(ax, _tri, interpolated_vals[:, :, i] |&gt; vec, levels=0:0.00001:0.001, extendhigh=:auto, extendlow=:auto, colormap=:matter)
    tightlimits!(ax)
    ylims!(ax, -10, 10)
end
resize_to_layout!(fig)
fig</code></pre><img src="601cd983.png" alt="Example block output"/><h2 id="Natural-neighbour-interpolation"><a class="docs-heading-anchor" href="#Natural-neighbour-interpolation">Natural neighbour interpolation</a><a id="Natural-neighbour-interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Natural-neighbour-interpolation" title="Permalink"></a></h2><p>Since the solution is defined over a triangulation, the most natural form of inteprolation to use, other than piecewise linear interpolation, is natural neighbour interpolation. We can use <a href="https://github.com/DanielVandH/NaturalNeighbours.jl">NaturalNeighbours.jl</a> for this; NaturalNeighbours.jl also provides the same piecewise linear interpolant above via its <code>Triangle()</code> interpolator, which may be more efficient as it has multithreading built in.</p><p>The way to construct a natural neighbour interpolant is as follows, where we provide the interpolant with the solution at <span>$t = 50$</span>.</p><pre><code class="language-julia hljs">using NaturalNeighbours
itp = interpolate(tri, sol.u[4], derivatives=true) # sol.t[4] == 50</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
Interpolation: 1st order linear
t: 7-element Vector{Float64}:
   0.0
  10.0
  25.0
  50.0
 100.0
 200.0
 250.0
u: 7-element Vector{Vector{Float64}}:
 [0.0, 0.0, 0.0, 0.0, 31.830988618379067, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
 [0.0, 0.0, 0.0, 0.0, 31.830988618379067, 0.0, 0.0, 0.0, 0.0, 0.0  …  4.066753277540322e-43, 2.8488474322795543e-43, 4.315187764870875e-45, 2.3763698684298e-60, 9.538998133281113e-76, 2.739164872714823e-13, 6.674334606384418e-34, 1.5161331091198345e-34, 1.8260620142440974e-53, 8.086415835844593e-49]
 [0.0, 0.0, 0.0, 0.0, 31.830988618379067, 0.0, 0.0, 0.0, 0.0, 0.0  …  8.23391997022047e-30, 5.220549814653682e-30, 1.665040775330767e-31, 1.6287700877090987e-44, 1.3043455222872805e-61, 3.6821472458732825e-9, 6.863512829318162e-25, 3.6771170552058965e-25, 9.979807767569023e-39, 7.218675196322838e-39]
 [0.0, 0.0, 0.0, 0.0, 31.830988618379067, 0.0, 0.0, 0.0, 0.0, 0.0  …  1.0037247923574523e-20, 6.17993998587632e-21, 3.772815609901226e-22, 3.521549469355037e-33, 6.765897480868023e-52, 1.1196445589629383e-7, 4.205657619757498e-19, 4.536546819359947e-19, 7.4693580958375195e-28, 2.083588318564695e-32]
 [0.0, 0.0, 0.0, 0.0, 31.830988618379067, 0.0, 0.0, 0.0, 0.0, 0.0  …  4.908458497667812e-13, 2.9060727865728184e-13, 3.5971580000417557e-14, 5.312123913386845e-23, 1.4276295087831808e-43, 1.8093743100641382e-7, 9.27098723225602e-15, 2.192002102304295e-14, 3.594755349154432e-18, -1.6298087013358494e-26]
 [0.0, 0.0, 0.0, 0.0, 31.830988618379067, 0.0, 0.0, 0.0, 0.0, 0.0  …  3.0829497438864826e-7, 1.685120218904999e-7, 4.4773936794186886e-8, 2.1269125888694875e-14, 2.869025096521627e-37, 1.4318543489079493e-8, 8.618275784888957e-13, 7.143467422040313e-12, 2.740717522881799e-10, 6.812201191203553e-24]
 [0.0, 0.0, 0.0, 0.0, 31.830988618379067, 0.0, 0.0, 0.0, 0.0, 0.0  …  6.328015246343963e-6, 3.345492869067269e-6, 1.1443535522097138e-6, 4.276332819229381e-12, 7.548437172778271e-36, 2.862046871670017e-9, 1.7195462706059908e-13, 1.0367224737470748e-11, 2.6911442304263533e-8, 1.1926434933074073e-21]</code></pre><p>We need <code>derivatives = true</code> so that we can use the higher order interpolants <code>Sibson(1)</code>, <code>Hiyoshi(2)</code>, and <code>Farin()</code> below - if you don&#39;t use those, then you shouldn&#39;t need this option (unless you want to later differentiate the interpolant using <code>differentiate</code>, then yes you do need it).</p><p>We can then evaluate this interpolant by simply calling it. The most efficient way to call it is by providing it with a vector of points, rather than broadcasting over points, since multithreading can be used in this case. Let us interpolate at the grid from before, which requires us to collect it into a vector:</p><pre><code class="language-julia hljs">_x = [x for x in x, _ in y] |&gt; vec
_y = [y for _ in x, y in y] |&gt; vec;</code></pre><p>We will look at all the interpolants provided by NaturalNeighbours.jl.<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup></p><pre><code class="language-julia hljs">sibson_vals = itp(_x, _y; method=Sibson())
triangle_vals = itp(_x, _y; method=Triangle()) # this is the same as pl_interpolate
laplace_vals = itp(_x, _y; method=Laplace())
sibson_1_vals = itp(_x, _y; method=Sibson(1))
nearest_vals = itp(_x, _y; method=Nearest())
farin_vals = itp(_x, _y; method=Farin())
hiyoshi_vals = itp(_x, _y; method=Hiyoshi(2))
pde_vals = sol.u[4];</code></pre><p>We visualise these results as follows.</p><pre><code class="language-julia hljs">fig = Figure(fontsize=38)
all_vals = (sibson_vals, triangle_vals, laplace_vals, sibson_1_vals, nearest_vals, farin_vals, hiyoshi_vals, pde_vals)
titles = (&quot;(a): Sibson&quot;, &quot;(b): Triangle&quot;, &quot;(c): Laplace&quot;, &quot;(d): Sibson-1&quot;, &quot;(e): Nearest&quot;, &quot;(f): Farin&quot;, &quot;(g): Hiyoshi&quot;, &quot;(h): PDE&quot;)
fig = Figure(fontsize=55, resolution=(6350, 1550)) # resolution from resize_to_layout!(fig) - had to manually adjust to fix missing ticks
for (i, (vals, title)) in enumerate(zip(all_vals, titles))
    ax2d = Axis(fig[1, i], xlabel=&quot;x&quot;, ylabel=&quot;y&quot;, width=600, height=600, title=title, titlealign=:left)
    ax3d = Axis3(fig[2, i], xlabel=&quot;x&quot;, ylabel=&quot;y&quot;, width=600, height=600, title=title, titlealign=:left)
    ax3d.zlabeloffset[] = 125
    xlims!(ax2d, -4, 6)
    ylims!(ax2d, -4, 4)
    xlims!(ax3d, -4, 6)
    ylims!(ax3d, -4, 4)
    if vals ≠ pde_vals
        contourf!(ax2d, _x, _y, vals, colormap=:matter, levels=0:0.001:0.1, extendlow=:auto, extendhigh=:auto)
        vals = copy(vals)
        vals[(_x.&lt;-4).|(_x.&gt;6)] .= NaN
        vals[(_y.&lt;-4).|(_y.&gt;4)] .= NaN # This is the only way to fix the weird issues with Axis3 when changing the (x/y/z)lims...
        surface!(ax3d, _x, _y, vals, color=vals, colormap=:matter, colorrange=(0, 0.1))
    else
        tricontourf!(ax2d, tri, vals, colormap=:matter, levels=0:0.001:0.1, extendlow=:auto, extendhigh=:auto)
        triangles = [T[j] for T in each_solid_triangle(tri), j in 1:3]
        x = getx.(get_points(tri))
        y = gety.(get_points(tri))
        vals = copy(vals)
        vals[(x.&lt;-4).|(x.&gt;6)] .= NaN
        vals[(y.&lt;-4).|(y.&gt;4)] .= NaN # This is the only way to fix the weird issues with Axis3 when changing the (x/y/z)lims...
        mesh!(ax3d, hcat(x, y, vals), triangles, color=vals, colormap=:matter, colorrange=(0, 0.1))
    end
end
fig</code></pre><img src="bc950740.png" alt="Example block output"/><p>We note that natural neighbour interpolation is not technically well defined for constrained triangulations. In this case it is fine, but for regions with, say, holes or non-convex boundaries, you may run into issues. For such cases, you should usually call the interpolant with <code>project=false</code> to at least help the procedure a bit. You may also be interested in <code>identify_exterior_points</code>. We consider interpolating data over a region with holes in <a href="../diffusion_equation_on_an_annulus/">this annulus example</a>.</p><h2 id="Just-the-code"><a class="docs-heading-anchor" href="#Just-the-code">Just the code</a><a id="Just-the-code-1"></a><a class="docs-heading-anchor-permalink" href="#Just-the-code" title="Permalink"></a></h2><p>An uncommented version of this example is given below. You can view the source code for this file <a href="https://github.com/SciML/FiniteVolumeMethod.jl/tree/main/docs/src/literate_tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation.jl">here</a>.</p><pre><code class="language-julia hljs">using DelaunayTriangulation, FiniteVolumeMethod, LinearAlgebra, CairoMakie
L = 30
tri = triangulate_rectangle(-L, L, -L, L, 2, 2, single_boundary=true)
tot_area = get_area(tri)
max_area_function = (A, r) -&gt; 1e-6tot_area * r^2 / A
area_constraint = (_tri, T) -&gt; begin
    u, v, w = triangle_vertices(T)
    p, q, r = get_point(_tri, u, v, w)
    c = (p .+ q .+ r) ./ 3
    dist_to_origin = norm(c)
    A = DelaunayTriangulation.triangle_area(p, q, r)
    flag = A ≥ max_area_function(A, dist_to_origin)
    return flag
end
refine!(tri; min_angle=33.0, custom_constraint=area_constraint)
triplot(tri)

mesh = FVMGeometry(tri)

BCs = BoundaryConditions(mesh, (x, y, t, u, p) -&gt; zero(u), Dirichlet)

ε = 1 / 10
f = (x, y) -&gt; 1 / (ε^2 * π) * exp(-(x^2 + y^2) / ε^2)
initial_condition = [f(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)]
flux_function = (x, y, t, α, β, γ, p) -&gt; begin
    ∂x = α
    ∂y = β
    u = α * x + β * y + γ
    qx = p.ν * u - p.D * ∂x
    qy = -p.D * ∂y
    return (qx, qy)
end
flux_parameters = (D=0.02, ν=0.05)
final_time = 250.0
prob = FVMProblem(mesh, BCs;
    initial_condition,
    flux_function,
    flux_parameters,
    final_time)

using OrdinaryDiffEq, LinearSolve
times = [0, 10, 25, 50, 100, 200, 250]
sol = solve(prob, TRBDF2(linsolve=KLUFactorization()), saveat=times)

using CairoMakie
fig = Figure(fontsize=38)
for i in eachindex(sol)
    ax = Axis(fig[1, i], width=400, height=400,
        xlabel=&quot;x&quot;, ylabel=&quot;y&quot;,
        title=&quot;t = $(sol.t[i])&quot;,
        titlealign=:left)
    tricontourf!(ax, tri, sol.u[i], levels=0:0.00001:0.001, extendhigh=:auto, extendlow=:auto, colormap=:matter)
    tightlimits!(ax)
    ylims!(ax, -10, 10)
end
resize_to_layout!(fig)
fig

        !DelaunayTriangulation.has_vertex(tri, i) &amp;&amp; continue

x = LinRange(-L, L, 250)
y = LinRange(-L, L, 250)
triangles = Matrix{NTuple{3,Int}}(undef, length(x), length(y))
for j in eachindex(y)
    for i in eachindex(x)
        triangles[i, j] = jump_and_march(tri, (x[i], y[j]))
    end
end
interpolated_vals = zeros(length(x), length(y), length(sol))
for k in eachindex(sol)
    for j in eachindex(y)
        for i in eachindex(x)
            interpolated_vals[i, j, k] = pl_interpolate(prob, triangles[i, j], sol.u[k], x[i], y[j])
        end
    end
end

_tri = triangulate([[x for x in x, _ in y] |&gt; vec [y for _ in x, y in y] |&gt; vec]&#39;)
fig = Figure(fontsize=38)
for i in eachindex(sol)
    ax = Axis(fig[1, i], width=400, height=400,
        xlabel=&quot;x&quot;, ylabel=&quot;y&quot;,
        title=&quot;t = $(sol.t[i])&quot;,
        titlealign=:left)
    tricontourf!(ax, _tri, interpolated_vals[:, :, i] |&gt; vec, levels=0:0.00001:0.001, extendhigh=:auto, extendlow=:auto, colormap=:matter)
    tightlimits!(ax)
    ylims!(ax, -10, 10)
end
resize_to_layout!(fig)
fig

using NaturalNeighbours
itp = interpolate(tri, sol.u[4], derivatives=true) # sol.t[4] == 50

_x = [x for x in x, _ in y] |&gt; vec
_y = [y for _ in x, y in y] |&gt; vec;

sibson_vals = itp(_x, _y; method=Sibson())
triangle_vals = itp(_x, _y; method=Triangle()) # this is the same as pl_interpolate
laplace_vals = itp(_x, _y; method=Laplace())
sibson_1_vals = itp(_x, _y; method=Sibson(1))
nearest_vals = itp(_x, _y; method=Nearest())
farin_vals = itp(_x, _y; method=Farin())
hiyoshi_vals = itp(_x, _y; method=Hiyoshi(2))
pde_vals = sol.u[4];

fig = Figure(fontsize=38)
all_vals = (sibson_vals, triangle_vals, laplace_vals, sibson_1_vals, nearest_vals, farin_vals, hiyoshi_vals, pde_vals)
titles = (&quot;(a): Sibson&quot;, &quot;(b): Triangle&quot;, &quot;(c): Laplace&quot;, &quot;(d): Sibson-1&quot;, &quot;(e): Nearest&quot;, &quot;(f): Farin&quot;, &quot;(g): Hiyoshi&quot;, &quot;(h): PDE&quot;)
fig = Figure(fontsize=55, resolution=(6350, 1550)) # resolution from resize_to_layout!(fig) - had to manually adjust to fix missing ticks
for (i, (vals, title)) in enumerate(zip(all_vals, titles))
    ax2d = Axis(fig[1, i], xlabel=&quot;x&quot;, ylabel=&quot;y&quot;, width=600, height=600, title=title, titlealign=:left)
    ax3d = Axis3(fig[2, i], xlabel=&quot;x&quot;, ylabel=&quot;y&quot;, width=600, height=600, title=title, titlealign=:left)
    ax3d.zlabeloffset[] = 125
    xlims!(ax2d, -4, 6)
    ylims!(ax2d, -4, 4)
    xlims!(ax3d, -4, 6)
    ylims!(ax3d, -4, 4)
    if vals ≠ pde_vals
        contourf!(ax2d, _x, _y, vals, colormap=:matter, levels=0:0.001:0.1, extendlow=:auto, extendhigh=:auto)
        vals = copy(vals)
        vals[(_x.&lt;-4).|(_x.&gt;6)] .= NaN
        vals[(_y.&lt;-4).|(_y.&gt;4)] .= NaN # This is the only way to fix the weird issues with Axis3 when changing the (x/y/z)lims...
        surface!(ax3d, _x, _y, vals, color=vals, colormap=:matter, colorrange=(0, 0.1))
    else
        tricontourf!(ax2d, tri, vals, colormap=:matter, levels=0:0.001:0.1, extendlow=:auto, extendhigh=:auto)
        triangles = [T[j] for T in each_solid_triangle(tri), j in 1:3]
        x = getx.(get_points(tri))
        y = gety.(get_points(tri))
        vals = copy(vals)
        vals[(x.&lt;-4).|(x.&gt;6)] .= NaN
        vals[(y.&lt;-4).|(y.&gt;4)] .= NaN # This is the only way to fix the weird issues with Axis3 when changing the (x/y/z)lims...
        mesh!(ax3d, hcat(x, y, vals), triangles, color=vals, colormap=:matter, colorrange=(0, 0.1))
    end
end
fig</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>This list is available from <code>?NaturalNeighbours.AbstractInterpolator</code>. Look at the help page (<code>?</code>) for the respective interpolators or NaturalNeighbours.jl&#39;s documentation for more information.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../porous_fisher_equation_and_travelling_waves/">« Porous-Fisher Equation and Travelling Waves</a><a class="docs-footer-nextpage" href="../helmholtz_equation_with_inhomogeneous_boundary_conditions/">Helmholtz Equation with Inhomogeneous Boundary Conditions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Saturday 11 May 2024 11:40">Saturday 11 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
