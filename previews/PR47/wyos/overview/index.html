<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Section Overview · FiniteVolumeMethod.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://DanielVandH.github.io/FiniteVolumeMethod.jl/wyos/overview/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">FiniteVolumeMethod.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../interface/">Interface</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/overview/">Section Overview</a></li><li><a class="tocitem" href="../../tutorials/diffusion_equation_on_a_square_plate/">Diffusion Equation on a Square Plate</a></li><li><a class="tocitem" href="../../tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/">Diffusion Equation in a Wedge with Mixed Boundary Conditions</a></li><li><a class="tocitem" href="../../tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/">Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk</a></li><li><a class="tocitem" href="../../tutorials/porous_medium_equation/">Porous-Medium Equation</a></li><li><a class="tocitem" href="../../tutorials/porous_fisher_equation_and_travelling_waves/">Porous-Fisher Equation and Travelling Waves</a></li><li><a class="tocitem" href="../../tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/">Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation</a></li><li><a class="tocitem" href="../../tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/">Helmholtz Equation with Inhomogeneous Boundary Conditions</a></li><li><a class="tocitem" href="../../tutorials/laplaces_equation_with_internal_dirichlet_conditions/">Laplace&#39;s Equation with Internal Dirichlet Conditions</a></li><li><a class="tocitem" href="../../tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/">Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems</a></li><li><a class="tocitem" href="../../tutorials/reaction_diffusion_brusselator_system_of_pdes/">A Reaction-Diffusion Brusselator System of PDEs</a></li><li><a class="tocitem" href="../../tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/">Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System</a></li><li><a class="tocitem" href="../../tutorials/diffusion_equation_on_an_annulus/">Diffusion Equation on an Annulus</a></li><li><a class="tocitem" href="../../tutorials/mean_exit_time/">Mean Exit Time</a></li><li><a class="tocitem" href="../../tutorials/solving_mazes_with_laplaces_equation/">Solving Mazes with Laplace&#39;s Equation</a></li><li><a class="tocitem" href="../../tutorials/keller_segel_chemotaxis/">Keller-Segel Model of Chemotaxis</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Solvers for Specific Problems, and Writing Your Own</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Section Overview</a><ul class="internal"><li><a class="tocitem" href="#Relevant-Docstrings-for-Writing-Your-Own-Solver"><span>Relevant Docstrings for Writing Your Own Solver</span></a></li></ul></li><li><a class="tocitem" href="../diffusion_equations/">Diffusion Equations</a></li><li><a class="tocitem" href="../mean_exit_time/">Mean Exit Time Problems</a></li><li><a class="tocitem" href="../linear_reaction_diffusion_equations/">Linear Reaction-Diffusion Equations</a></li><li><a class="tocitem" href="../poissons_equation/">Poisson&#39;s Equation</a></li><li><a class="tocitem" href="../laplaces_equation/">Laplace&#39;s Equation</a></li></ul></li><li><a class="tocitem" href="../../math/">Mathematical and Implementation Details</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Solvers for Specific Problems, and Writing Your Own</a></li><li class="is-active"><a href>Section Overview</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Section Overview</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/main/docs/src/wyos/overview.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Solvers-for-Specific-Problems,-and-Writing-Your-Own"><a class="docs-heading-anchor" href="#Solvers-for-Specific-Problems,-and-Writing-Your-Own">Solvers for Specific Problems, and Writing Your Own</a><a id="Solvers-for-Specific-Problems,-and-Writing-Your-Own-1"></a><a class="docs-heading-anchor-permalink" href="#Solvers-for-Specific-Problems,-and-Writing-Your-Own" title="Permalink"></a></h1><p>The problems solved by this package are quite general, taking the form</p><p class="math-container">\[\pdv{u}{t} + \div\vb q = S.\]</p><p>For some problems, though, this is not the most efficient form to implement. For example, the diffusion equation</p><p class="math-container">\[\pdv{u}{t} = D\grad^2 u\]</p><p>might be better treated by converting the problem into</p><p class="math-container">\[\dv{\vb u}{t} = \vb A\vb u + \vb b,\]</p><p>which is faster to solve than if we were to treat it as a nonlinear problem (which is done by default). For this reason, we define some templates  for specific types of problems, namely:</p><ol><li><code>DiffusionEquation</code>s: <span>$\partial_tu = \div[D(\vb x)\grad u]$</span>.</li><li><code>MeanExitTimeProblem</code>s: <span>$\div[D(\vb x)\grad T(\vb x)] = -1$</span>.</li><li><code>LinearReactionDiffusionEquation</code>s: <span>$\partial_tu + \div[D(\vb x)\grad u] + f(\vb x)u$</span>.</li><li><code>PoissonsEquation</code>: <span>$\div[D(\vb x)\grad u]  f(\vb x)$</span>.</li><li><code>LaplacesEquation</code>: <span>$\div[D(\vb x)\grad u] = 0$</span>.</li></ol><p>The docstrings below define the templates for these problems.</p><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.AbstractFVMTemplate" href="#FiniteVolumeMethod.AbstractFVMTemplate"><code>FiniteVolumeMethod.AbstractFVMTemplate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractFVMTemplate &lt;: AbstractFVMProblem</code></pre><p>An abstract type that defines some specific problems. These problems are those that could  be defined directly using <a href="../../interface/#FiniteVolumeMethod.FVMProblem"><code>FVMProblem</code></a>s, but are common enough that (1) it is useful to have them defined here, and (2) it is useful to have them defined in a way that is more efficient than with a default implementation (e.g. exploiting linearity). The  problems are all defined as subtypes of a common abstract type,  namely, <code>AbstractFVMTemplate</code> (the home of this docstring), which itself is a subtype of <code>AbstractFVMProblem</code>. </p><p>To understand how to make use of these specific problems, either  see the docstring for each problem, or see the  &quot;Solvers for Specific Problems, and Writing Your Own&quot; section of the docs.</p><p>To see the full list of problems, do </p><pre><code class="language-julia-repl hljs">julia&gt; using FiniteVolumeMethod

julia&gt; subtypes(FiniteVolumeMethod.AbstractFVMTemplate)
5-element Vector{Any}:
 DiffusionEquation
 LaplacesEquation
 LinearReactionDiffusionEquation
 MeanExitTimeProblem
 PoissonsEquation</code></pre><p>The constructor for each problem is defined in its docstring. Note that all the problems above are exported.</p><p>These problems can all be solved using the standard <code>solve</code> interface from  DifferentialEquations.jl, just like for <a href="../../interface/#FiniteVolumeMethod.FVMProblem"><code>FVMProblem</code></a>s. The only exception  is for steady state problems, in which case the <code>solve</code> interface is still used, except  the interface is from LinearSolve.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/specific_problems/abstract_templates.jl#L1-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CommonSolve.solve-Tuple{FiniteVolumeMethod.AbstractFVMTemplate, Vararg{Any}}" href="#CommonSolve.solve-Tuple{FiniteVolumeMethod.AbstractFVMTemplate, Vararg{Any}}"><code>CommonSolve.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve(prob::AbstractFVMTemplate, args...; kwargs...)</code></pre><p>Solve the problem <code>prob</code> using the standard <code>solve</code> interface from DifferentialEquations.jl. For  steady state problems, the interface is from LinearSolve.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/specific_problems/abstract_templates.jl#L51-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.DiffusionEquation" href="#FiniteVolumeMethod.DiffusionEquation"><code>FiniteVolumeMethod.DiffusionEquation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DiffusionEquation &lt;: AbstractFVMTemplate</code></pre><p>A struct for defining a problem representing a diffusion equation:</p><p class="math-container">\[\pdv{u}{t} = \div\left[D(\vb x)\grad u\right]\]</p><p>inside a domain <span>$\Omega$</span>. </p><p>You can solve this problem using <a href="#CommonSolve.solve-Tuple{FiniteVolumeMethod.AbstractFVMTemplate, Vararg{Any}}"><code>solve</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The solution to this problem will have an extra component added to it. The original solution will be inside  <code>sol[begin:end-1, :]</code>, where <code>sol</code> is the solution returned by <a href="#CommonSolve.solve-Tuple{FiniteVolumeMethod.AbstractFVMTemplate, Vararg{Any}}"><code>solve</code></a>.</p></div></div><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">DiffusionEquation(mesh::FVMGeometry,
    BCs::BoundaryConditions,
    ICs::InternalConditions=InternalConditions();
    diffusion_function,
    diffusion_parameters=nothing,
    initial_condition,
    initial_time=0.0,
    final_time,
    kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>mesh::FVMGeometry</code>: The <a href="../../interface/#FiniteVolumeMethod.FVMGeometry"><code>FVMGeometry</code></a>.</li><li><code>BCs::BoundaryConditions</code>: The <a href="../../interface/#FiniteVolumeMethod.BoundaryConditions"><code>BoundaryConditions</code></a>. For these boundary conditions, all functions should still be of the form <code>(x, y, t, u, p) -&gt; Number</code>, but the <code>t</code> and <code>u</code> arguments should be unused as they will be replaced with <code>nothing</code>.</li><li><code>ICs::InternalConditions=InternalConditions()</code>: The <a href="../../interface/#FiniteVolumeMethod.InternalConditions"><code>InternalConditions</code></a>. For these internal conditions, all functions should still be of the form <code>(x, y, t, u, p) -&gt; Number</code>, but the <code>t</code> and <code>u</code> arguments should be unused as they will be replaced with <code>nothing</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>diffusion_function</code>: The diffusion function. Should be of the form <code>(x, y, p) -&gt; Number</code>, where <code>p = diffusion_parameters</code> below.</li><li><code>diffusion_parameters=nothing</code>: The argument <code>p</code> in <code>diffusion_function</code>.</li><li><code>initial_condition</code>: The initial condition. </li><li><code>initial_time=0.0</code>: The initial time.</li><li><code>final_time</code>: The final time.</li><li><code>kwargs...</code>: Any other keyword arguments are passed to the <code>ODEProblem</code> (from DifferentialEquations.jl) that represents the problem. </li></ul><p><strong>Fields</strong></p><p>The struct has extra fields in addition to the arguments above:</p><ul><li><code>A</code>: This is a sparse matrix <code>A</code> so that <code>du/dt = Au + b</code>.</li><li><code>b</code>: The <code>b</code> above.</li><li><code>Aop</code>: The <code>MatrixOperator</code> that represents the system so that <code>du/dt = Aop*u</code> (with <code>u</code> padded with an extra component since <code>A</code> is now inside <code>Aop</code>).</li><li><code>problem</code>: The <code>ODEProblem</code> that represents the problem. This is the problem that is solved when you call <a href="#CommonSolve.solve-Tuple{FiniteVolumeMethod.AbstractFVMTemplate, Vararg{Any}}"><code>solve</code></a> on the struct.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/specific_problems/diffusion_equation.jl#L1-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.MeanExitTimeProblem" href="#FiniteVolumeMethod.MeanExitTimeProblem"><code>FiniteVolumeMethod.MeanExitTimeProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MeanExitTimeProblem</code></pre><p>A struct for defining a problem representing a mean exit time problem:</p><p class="math-container">\[\div\left[D(\vb x)\grad T\right] =-1\]</p><p>inside a domain <span>$\Omega$</span>. This problem is a special case of <a href="#FiniteVolumeMethod.PoissonsEquation"><code>PoissonsEquation</code></a>, but is defined separately since it is common enough to warrant its own definition; <code>MeanExitTimeProblem</code> is constructed using <a href="#FiniteVolumeMethod.PoissonsEquation"><code>PoissonsEquation</code></a>.</p><p>You can solve this problem using <a href="#CommonSolve.solve-Tuple{FiniteVolumeMethod.AbstractFVMTemplate, Vararg{Any}}"><code>solve</code></a>.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">MeanExitTimeProblem(mesh::FVMGeometry,
    BCs::BoundaryConditions,
    ICs::InternalConditions=InternalConditions();
    diffusion_function,
    diffusion_parameters=nothing,
    kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>mesh::FVMGeometry</code>: The <a href="../../interface/#FiniteVolumeMethod.FVMGeometry"><code>FVMGeometry</code></a>.</li><li><code>BCs::BoundaryConditions</code>: The <a href="../../interface/#FiniteVolumeMethod.BoundaryConditions"><code>BoundaryConditions</code></a>.</li><li><code>ICs::InternalConditions=InternalConditions()</code>: The <a href="../../interface/#FiniteVolumeMethod.InternalConditions"><code>InternalConditions</code></a>.</li></ul><p>The functions for <code>BCs</code> and <code>ICs</code> are not used. Whenever a <a href="../../interface/#FiniteVolumeMethod.Neumann"><code>Neumann</code></a> condition is encountered,  or a <a href="../../interface/#FiniteVolumeMethod.Dirichlet"><code>Dirichlet</code></a> condition, it is assumed that the conditon is homogeneous. If any of the  conditions are <a href="../../interface/#FiniteVolumeMethod.Dudt"><code>Dudt</code></a> or <a href="../../interface/#FiniteVolumeMethod.Constrained"><code>Constrained</code></a> types, then an error is thrown.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>diffusion_function</code>: The diffusion function. Should be of the form <code>(x, y, p) -&gt; Number</code>, where <code>p = diffusion_parameters</code> below.</li><li><code>diffusion_parameters=nothing</code>: The argument <code>p</code> in <code>diffusion_function</code>.</li><li><code>kwargs...</code>: Any other keyword arguments are passed to the <code>LinearProblem</code> (from LinearSolve.jl) that represents the problem.</li></ul><p><strong>Fields</strong></p><p>The struct has extra fields in addition to the arguments above:</p><ul><li><code>A</code>: This is a sparse matrix <code>A</code> so that <code>AT = b</code>.</li><li><code>b</code>: The <code>b</code> above.</li><li><code>problem</code>: The <code>LinearProblem</code> that represents the problem. This is the problem that is solved when you call <a href="#CommonSolve.solve-Tuple{FiniteVolumeMethod.AbstractFVMTemplate, Vararg{Any}}"><code>solve</code></a> on the struct.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/specific_problems/mean_exit_time.jl#L1-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.LinearReactionDiffusionEquation" href="#FiniteVolumeMethod.LinearReactionDiffusionEquation"><code>FiniteVolumeMethod.LinearReactionDiffusionEquation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearReactionDiffusionEquation</code></pre><p>A struct for defining a problem representing a linear reaction-diffusion equation:</p><p class="math-container">\[\pdv{u}{t} = \div\left[D(\vb x)\grad u\right] + f(\vb x)u\]</p><p>inside a domain <span>$\Omega$</span>. </p><p>You can solve this problem using <a href="#CommonSolve.solve-Tuple{FiniteVolumeMethod.AbstractFVMTemplate, Vararg{Any}}"><code>solve</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The solution to this problem will have an extra component added to it. The original solution will be inside  <code>sol[begin:end-1, :]</code>, where <code>sol</code> is the solution returned by <a href="#CommonSolve.solve-Tuple{FiniteVolumeMethod.AbstractFVMTemplate, Vararg{Any}}"><code>solve</code></a>.</p></div></div><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">LinearReactionDiffusionEquation(mesh::FVMGeometry,
    BCs::BoundaryConditions,
    ICs::InternalConditions=InternalConditions();
    diffusion_function,
    diffusion_parameters=nothing,
    source_function,
    source_parameters=nothing,
    initial_condition,
    initial_time=0.0,
    final_time,
    kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>mesh::FVMGeometry</code>: The <a href="../../interface/#FiniteVolumeMethod.FVMGeometry"><code>FVMGeometry</code></a>.</li><li><code>BCs::BoundaryConditions</code>: The <a href="../../interface/#FiniteVolumeMethod.BoundaryConditions"><code>BoundaryConditions</code></a>. For these boundary conditions, all functions should still be of the form <code>(x, y, t, u, p) -&gt; Number</code>, but the <code>t</code> and <code>u</code> arguments should be unused as they will be replaced with <code>nothing</code>.</li><li><code>ICs::InternalConditions=InternalConditions()</code>: The <a href="../../interface/#FiniteVolumeMethod.InternalConditions"><code>InternalConditions</code></a>. For these internal conditions, all functions should still be of the form <code>(x, y, t, u, p) -&gt; Number</code>, but the <code>t</code> and <code>u</code> arguments should be unused as they will be replaced with <code>nothing</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>diffusion_function</code>: The diffusion function. Should be of the form <code>(x, y, p) -&gt; Number</code>, where <code>p = diffusion_parameters</code> below.</li><li><code>diffusion_parameters=nothing</code>: The argument <code>p</code> in <code>diffusion_function</code>.</li><li><code>source_function</code>: The source function. Should be of the form <code>(x, y, p) -&gt; Number</code>, where <code>p = source_parameters</code> below.</li><li><code>source_parameters=nothing</code>: The argument <code>p</code> in <code>source_function</code>.</li><li><code>initial_condition</code>: The initial condition.</li><li><code>initial_time=0.0</code>: The initial time.</li><li><code>final_time</code>: The final time.</li><li><code>kwargs...</code>: Any other keyword arguments are passed to the <code>ODEProblem</code> (from DifferentialEquations.jl) that represents the problem.</li></ul><p><strong>Fields</strong></p><p>The struct has extra fields in addition to the arguments above:</p><ul><li><code>A</code>: This is a sparse matrix <code>A</code> so that <code>du/dt = Au + b</code>.</li><li><code>b</code>: The <code>b</code> above.</li><li><code>Aop</code>: The <code>MatrixOperator</code> that represents the system so that <code>du/dt = Aop*u</code> (with <code>u</code> padded with an extra component since <code>A</code> is now inside <code>Aop</code>).</li><li><code>problem</code>: The <code>ODEProblem</code> that represents the problem. This is the problem that is solved when you call <a href="#CommonSolve.solve-Tuple{FiniteVolumeMethod.AbstractFVMTemplate, Vararg{Any}}"><code>solve</code></a> on the struct.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/specific_problems/linear_reaction_diffusion_equations.jl#L1-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.PoissonsEquation" href="#FiniteVolumeMethod.PoissonsEquation"><code>FiniteVolumeMethod.PoissonsEquation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PoissonsEquation</code></pre><p>A struct for defining a problem representing a (generalised) Poisson&#39;s equation:</p><p class="math-container">\[\div[D(\vb x)\grad u] = f(\vb x)\]</p><p>inside a domain <span>$\Omega$</span>. See also <a href="#FiniteVolumeMethod.LaplacesEquation"><code>LaplacesEquation</code></a>, a special case of this  problem with <span>$f(\vb x) = 0$</span>.</p><p>You can solve this problem using <a href="#CommonSolve.solve-Tuple{FiniteVolumeMethod.AbstractFVMTemplate, Vararg{Any}}"><code>solve</code></a>.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">PoissonsEquation(mesh::FVMGeometry,
    BCs::BoundaryConditions,
    ICs::InternalConditions=InternalConditions();
    diffusion_function=(x,y,p)-&gt;1.0,
    diffusion_parameters=nothing,
    source_function, 
    source_parameters=nothing,
    kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>mesh::FVMGeometry</code>: The <a href="../../interface/#FiniteVolumeMethod.FVMGeometry"><code>FVMGeometry</code></a>.</li><li><code>BCs::BoundaryConditions</code>: The <a href="../../interface/#FiniteVolumeMethod.BoundaryConditions"><code>BoundaryConditions</code></a>. For these boundary conditions, all functions should still be of the form <code>(x, y, t, u, p) -&gt; Number</code>, but the <code>t</code> and <code>u</code> arguments should be unused as they will be replaced with <code>nothing</code>.</li><li><code>ICs::InternalConditions=InternalConditions()</code>: The <a href="../../interface/#FiniteVolumeMethod.InternalConditions"><code>InternalConditions</code></a>. For these internal conditions, all functions should still be of the form <code>(x, y, t, u, p) -&gt; Number</code>, but the <code>t</code> and <code>u</code> arguments should be unused as they will be replaced with <code>nothing</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>diffusion_function=(x,y,p)-&gt;1.0</code>: The diffusion function. Should be of the form <code>(x, y, p) -&gt; Number</code>, where <code>p = diffusion_parameters</code> below.</li><li><code>diffusion_parameters=nothing</code>: The argument <code>p</code> in <code>diffusion_function</code>.</li><li><code>source_function</code>: The source function. Should be of the form <code>(x, y, p) -&gt; Number</code>, where <code>p = source_parameters</code> below.</li><li><code>source_parameters=nothing</code>: The argument <code>p</code> in <code>source_function</code>.</li><li><code>kwargs...</code>: Any other keyword arguments are passed to the <code>LinearProblem</code> (from LinearSolve.jl) that represents the problem.</li></ul><p><strong>Fields</strong></p><p>The struct has extra fields in addition to the arguments above:</p><ul><li><code>A</code>: This is a sparse matrix <code>A</code> so that <code>Au = b</code>.    </li><li><code>b</code>: The <code>b</code> above.</li><li><code>problem</code>: The <code>LinearProblem</code> that represents the problem. This is the problem that is solved when you call <a href="#CommonSolve.solve-Tuple{FiniteVolumeMethod.AbstractFVMTemplate, Vararg{Any}}"><code>solve</code></a> on the struct.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/specific_problems/poissons_equation.jl#L1-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.LaplacesEquation" href="#FiniteVolumeMethod.LaplacesEquation"><code>FiniteVolumeMethod.LaplacesEquation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LaplacesEquation</code></pre><p>A struct for defining a problem representing a (generalised) Laplace&#39;s equation:</p><p class="math-container">\[\div[D(\vb x)\grad u] = 0\]</p><p>inside a domain <span>$\Omega$</span>. See also <a href="#FiniteVolumeMethod.PoissonsEquation"><code>PoissonsEquation</code></a>.</p><p>You can solve this problem using <a href="#CommonSolve.solve-Tuple{FiniteVolumeMethod.AbstractFVMTemplate, Vararg{Any}}"><code>solve</code></a>.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">LaplacesEquation(mesh::FVMGeometry,
    BCs::BoundaryConditions,
    ICs::InternalConditions=InternalConditions();
    diffusion_function=(x,y,p)-&gt;1.0,
    diffusion_parameters=nothing,
    kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>mesh::FVMGeometry</code>: The <a href="../../interface/#FiniteVolumeMethod.FVMGeometry"><code>FVMGeometry</code></a>.</li><li><code>BCs::BoundaryConditions</code>: The <a href="../../interface/#FiniteVolumeMethod.BoundaryConditions"><code>BoundaryConditions</code></a>. For these boundary conditions, all functions should still be of the form <code>(x, y, t, u, p) -&gt; Number</code>, but the <code>t</code> and <code>u</code> arguments should be unused as they will be replaced with <code>nothing</code>.</li><li><code>ICs::InternalConditions=InternalConditions()</code>: The <a href="../../interface/#FiniteVolumeMethod.InternalConditions"><code>InternalConditions</code></a>. For these internal conditions, all functions should still be of the form <code>(x, y, t, u, p) -&gt; Number</code>, but the <code>t</code> and <code>u</code> arguments should be unused as they will be replaced with <code>nothing</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>diffusion_function=(x,y,p)-&gt;1.0</code>: The diffusion function. Should be of the form <code>(x, y, p) -&gt; Number</code>, where <code>p = diffusion_parameters</code> below.</li><li><code>diffusion_parameters=nothing</code>: The argument <code>p</code> in <code>diffusion_function</code>.</li><li><code>kwargs...</code>: Any other keyword arguments are passed to the <code>LinearProblem</code> (from LinearSolve.jl) that represents the problem.</li></ul><p><strong>Fields</strong></p><p>The struct has extra fields in addition to the arguments above:</p><ul><li><code>A</code>: This is a sparse matrix <code>A</code> so that <code>Au = b</code>.    </li><li><code>b</code>: The <code>b</code> above.</li><li><code>problem</code>: The <code>LinearProblem</code> that represents the problem. This is the problem that is solved when you call <a href="#CommonSolve.solve-Tuple{FiniteVolumeMethod.AbstractFVMTemplate, Vararg{Any}}"><code>solve</code></a> on the struct.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/specific_problems/laplaces_equation.jl#L1-L36">source</a></section></article><p>Now, again, we note that all these problems can already be implemented using the main interface <code>FVMProblem</code>. However, the templates we provide are more efficient, and also provide a good starting point for writing your own solver, meaning your own function  that evaluates the system of ODEs. In the sections that follow, we will demonstrate two things for each of the problems above:</p><ol><li>The mathematical details involved in implementing each template.</li><li>Examples of using the templates from FiniteVolumeMethod.jl.</li></ol><p>With these two steps, you should be able to also know how to write your own solver for any problem you like. </p><h2 id="Relevant-Docstrings-for-Writing-Your-Own-Solver"><a class="docs-heading-anchor" href="#Relevant-Docstrings-for-Writing-Your-Own-Solver">Relevant Docstrings for Writing Your Own Solver</a><a id="Relevant-Docstrings-for-Writing-Your-Own-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#Relevant-Docstrings-for-Writing-Your-Own-Solver" title="Permalink"></a></h2><p>For writing these solvers, there are some specific functions that might be of use to you.  Here, we provide the docstrings for these functions. These functions are public API.</p><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.get_dirichlet_fidx" href="#FiniteVolumeMethod.get_dirichlet_fidx"><code>FiniteVolumeMethod.get_dirichlet_fidx</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_dirichlet_fidx(conds, node)</code></pre><p>Get the index of the function that corresponds to the <a href="../../interface/#FiniteVolumeMethod.Dirichlet"><code>Dirichlet</code></a> condition at <code>node</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/conditions.jl#L319-L323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.is_dirichlet_node" href="#FiniteVolumeMethod.is_dirichlet_node"><code>FiniteVolumeMethod.is_dirichlet_node</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_dirichlet_node(conds, node)</code></pre><p>Check if <code>node</code> has a <a href="../../interface/#FiniteVolumeMethod.Dirichlet"><code>Dirichlet</code></a> condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/conditions.jl#L365-L369">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.get_dirichlet_nodes" href="#FiniteVolumeMethod.get_dirichlet_nodes"><code>FiniteVolumeMethod.get_dirichlet_nodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_dirichlet_nodes(conds)</code></pre><p>Get all nodes that have a <a href="../../interface/#FiniteVolumeMethod.Dirichlet"><code>Dirichlet</code></a> condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/conditions.jl#L407-L411">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.has_dirichlet_nodes" href="#FiniteVolumeMethod.has_dirichlet_nodes"><code>FiniteVolumeMethod.has_dirichlet_nodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_dirichlet_nodes(conds)</code></pre><p>Check if any node has a <a href="../../interface/#FiniteVolumeMethod.Dirichlet"><code>Dirichlet</code></a> condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/conditions.jl#L400-L404">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.get_dudt_fidx" href="#FiniteVolumeMethod.get_dudt_fidx"><code>FiniteVolumeMethod.get_dudt_fidx</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_dudt_fidx(conds, node)</code></pre><p>Get the index of the function that corresponds to the <a href="../../interface/#FiniteVolumeMethod.Dudt"><code>Dudt</code></a> condition at <code>node</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/conditions.jl#L305-L309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.is_dudt_node" href="#FiniteVolumeMethod.is_dudt_node"><code>FiniteVolumeMethod.is_dudt_node</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_dudt_node(conds, node)</code></pre><p>Check if <code>node</code> has a <a href="../../interface/#FiniteVolumeMethod.Dudt"><code>Dudt</code></a> condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/conditions.jl#L351-L355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.get_dudt_nodes" href="#FiniteVolumeMethod.get_dudt_nodes"><code>FiniteVolumeMethod.get_dudt_nodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_dudt_nodes(conds)</code></pre><p>Get all nodes that have a <a href="../../interface/#FiniteVolumeMethod.Dudt"><code>Dudt</code></a> condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/conditions.jl#L421-L425">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.has_dudt_nodes" href="#FiniteVolumeMethod.has_dudt_nodes"><code>FiniteVolumeMethod.has_dudt_nodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_dudt_nodes(conds)</code></pre><p>Check if any node has a <a href="../../interface/#FiniteVolumeMethod.Dudt"><code>Dudt</code></a> condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/conditions.jl#L414-L418">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.get_neumann_fidx" href="#FiniteVolumeMethod.get_neumann_fidx"><code>FiniteVolumeMethod.get_neumann_fidx</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_neumann_fidx(conds, i, j)</code></pre><p>Get the index of the function that corresponds to the <a href="../../interface/#FiniteVolumeMethod.Neumann"><code>Neumann</code></a> condition at the edge <code>(i, j)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/conditions.jl#L312-L316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.is_neumann_edge" href="#FiniteVolumeMethod.is_neumann_edge"><code>FiniteVolumeMethod.is_neumann_edge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_neumann_edge(conds, i, j)</code></pre><p>Check if the edge <code>(i, j)</code> has a <a href="../../interface/#FiniteVolumeMethod.Neumann"><code>Neumann</code></a> condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/conditions.jl#L358-L362">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.has_neumann_edges" href="#FiniteVolumeMethod.has_neumann_edges"><code>FiniteVolumeMethod.has_neumann_edges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_neumann_edges(conds)</code></pre><p>Check if any edge has a <a href="../../interface/#FiniteVolumeMethod.Neumann"><code>Neumann</code></a> condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/conditions.jl#L386-L390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.get_neumann_edges" href="#FiniteVolumeMethod.get_neumann_edges"><code>FiniteVolumeMethod.get_neumann_edges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_neumann_edges(conds)</code></pre><p>Get all edges that have a <a href="../../interface/#FiniteVolumeMethod.Neumann"><code>Neumann</code></a> condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/conditions.jl#L428-L432">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.get_constrained_fidx" href="#FiniteVolumeMethod.get_constrained_fidx"><code>FiniteVolumeMethod.get_constrained_fidx</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_constrained_fidx(conds, i, j)</code></pre><p>Get the index of the function that corresponds to the <a href="../../interface/#FiniteVolumeMethod.Constrained"><code>Constrained</code></a> condition at the edge <code>(i, j)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/conditions.jl#L326-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.is_constrained_edge" href="#FiniteVolumeMethod.is_constrained_edge"><code>FiniteVolumeMethod.is_constrained_edge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_constrained_edge(conds, i, j)</code></pre><p>Check if the edge <code>(i, j)</code> has a <a href="../../interface/#FiniteVolumeMethod.Constrained"><code>Constrained</code></a> condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/conditions.jl#L372-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.has_constrained_edges" href="#FiniteVolumeMethod.has_constrained_edges"><code>FiniteVolumeMethod.has_constrained_edges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_constrained_edges(conds)</code></pre><p>Check if any edge has a <a href="../../interface/#FiniteVolumeMethod.Constrained"><code>Constrained</code></a> condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/conditions.jl#L379-L383">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.get_constrained_edges" href="#FiniteVolumeMethod.get_constrained_edges"><code>FiniteVolumeMethod.get_constrained_edges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_constrained_edges(conds)</code></pre><p>Get all edges that have a <a href="../../interface/#FiniteVolumeMethod.Constrained"><code>Constrained</code></a> condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/conditions.jl#L435-L439">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.eval_condition_fnc" href="#FiniteVolumeMethod.eval_condition_fnc"><code>FiniteVolumeMethod.eval_condition_fnc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eval_condition_fnc(conds, fidx, x, y, t, u)</code></pre><p>Evaluate the function that corresponds to the condition at <code>fidx</code> at the point <code>(x, y)</code> at time <code>t</code> with solution <code>u</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/conditions.jl#L335-L339">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.has_condition" href="#FiniteVolumeMethod.has_condition"><code>FiniteVolumeMethod.has_condition</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_condition(conds, node)</code></pre><p>Check if <code>node</code> has any condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/conditions.jl#L393-L397">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.get_cv_components" href="#FiniteVolumeMethod.get_cv_components"><code>FiniteVolumeMethod.get_cv_components</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_cv_components(props, edge_index)</code></pre><p>Get the quantities for a control volume edge interior to the associated triangulation, relative to the <code>edge_index</code>th edge of the triangle corresponding to <code>props</code>.</p><p><strong>Outputs</strong></p><ul><li><code>x</code>: The <code>x</code>-coordinate of the edge&#39;s midpoint. </li><li><code>y</code>: The <code>y</code>-coordinate of the edge&#39;s midpoint.</li><li><code>nx</code>: The <code>x</code>-component of the edge&#39;s normal vector.</li><li><code>ny</code>: The <code>y</code>-component of the edge&#39;s normal vector.</li><li><code>ℓ</code>: The length of the edge.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/equations/control_volumes.jl#L2-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.get_boundary_cv_components" href="#FiniteVolumeMethod.get_boundary_cv_components"><code>FiniteVolumeMethod.get_boundary_cv_components</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_boundary_cv_components(tri::Triangulation, i, j)</code></pre><p>Get the quantities for both control volume edges lying a boundary edge <code>(i, j)</code>.</p><p><strong>Outputs</strong></p><ul><li><code>nx</code>: The <code>x</code>-component of the edge&#39;s normal vector.</li><li><code>ny</code>: The <code>y</code>-component of the edge&#39;s normal vector.</li><li><code>mᵢx</code>: The <code>x</code>-coordinate of the midpoint of the <code>i</code>th vertex and the edge&#39;s midpoint.</li><li><code>mᵢy</code>: The <code>y</code>-coordinate of the midpoint of the <code>i</code>th vertex and the edge&#39;s midpoint.</li><li><code>mⱼx</code>: The <code>x</code>-coordinate of the midpoint of the <code>j</code>th vertex and the edge&#39;s midpoint.</li><li><code>mⱼy</code>: The <code>y</code>-coordinate of the midpoint of the <code>j</code>th vertex and the edge&#39;s midpoint.</li><li><code>ℓᵢ</code>: Half the length of the boundary edge, which is the length of the control volume edge.</li><li><code>T</code>: The triangle containing the boundary edge.</li><li><code>props</code>: The <a href="../../interface/#FiniteVolumeMethod.TriangleProperties"><code>TriangleProperties</code></a> for <code>T</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/equations/control_volumes.jl#L23-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.get_triangle_props" href="#FiniteVolumeMethod.get_triangle_props"><code>FiniteVolumeMethod.get_triangle_props</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_triangle_props(mesh, i, j, k)</code></pre><p>Get the <a href="../../interface/#FiniteVolumeMethod.TriangleProperties"><code>TriangleProperties</code></a> for the triangle <code>(i, j, k)</code> in <code>mesh</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/geometry.jl#L53-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.get_volume" href="#FiniteVolumeMethod.get_volume"><code>FiniteVolumeMethod.get_volume</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_volume(mesh, i)</code></pre><p>Get the volume of the <code>i</code>th control volume in <code>mesh</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/geometry.jl#L60-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_point-Tuple{FVMGeometry, Any}" href="#DelaunayTriangulation.get_point-Tuple{FVMGeometry, Any}"><code>DelaunayTriangulation.get_point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_point(mesh, i)</code></pre><p>Get the <code>i</code>th point in <code>mesh</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/geometry.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.triangle_contributions!" href="#FiniteVolumeMethod.triangle_contributions!"><code>FiniteVolumeMethod.triangle_contributions!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">triangle_contributions!(A, mesh, conditions, diffusion_function, diffusion_parameters)</code></pre><p>Add the contributions from each triangle to the matrix <code>A</code>, based on the equation </p><p class="math-container">\[\dv{u_i}{t} = \frac{1}{V_i}\sum_{\sigma \in \mathcal E_i} D(\vb x_\sigma)\left[\left(s_{k, 11}n_\sigma^x + s_{k, 21}n_\sigma^y\right)u_{k1} + \left(s_{k, 12}n_\sigma^x + s_{k, 22}n_\sigma^y\right)u_{k2} + \left(s_{k, 13}n_\sigma^x + s_{k, 23}n_\sigma^y\right)u_{k3}\right]L_\sigma + S_i, \]</p><p>as explained in the docs. Will not update any rows corresponding to  <a href="../../interface/#FiniteVolumeMethod.Dirichlet"><code>Dirichlet</code></a> or <a href="../../interface/#FiniteVolumeMethod.Dudt"><code>Dudt</code></a> nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/specific_problems/abstract_templates.jl#L59-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.apply_dirichlet_conditions!" href="#FiniteVolumeMethod.apply_dirichlet_conditions!"><code>FiniteVolumeMethod.apply_dirichlet_conditions!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">apply_dirichlet_conditions!(initial_condition, mesh, conditions)</code></pre><p>Applies the Dirichlet conditions specified in <code>conditions</code> to the <code>initial_condition</code>. The boundary  conditions are assumed to take the form <code>a(x, y, t, u, p) -&gt; Number</code>, but <code>t</code> and <code>u</code> are passed  as <code>nothing</code>. Note that this assumes that the associated system <code>(A, b)</code> is such that <code>A[i, :]</code> is all  zero, and <code>b[i]</code> is zero, where <code>i</code> is a node with a Dirichlet condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/specific_problems/abstract_templates.jl#L93-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.apply_dudt_conditions!" href="#FiniteVolumeMethod.apply_dudt_conditions!"><code>FiniteVolumeMethod.apply_dudt_conditions!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">apply_dudt_conditions!(b, mesh, conditions)</code></pre><p>Applies the Dudt conditions specified in <code>conditions</code> to the <code>b</code> vector. The boundary    conditions are assumed to take the form <code>a(x, y, t, u, p) -&gt; Number</code>, but <code>t</code> and <code>u</code> are passed as <code>nothing</code>. Note that this assumes that the associated system <code>(A, b)</code> is such that <code>A[i, :]</code> is all zero, so that replacing <code>b[i]</code> with the boundary condition will set <code>duᵢ/dt = b[i]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/specific_problems/abstract_templates.jl#L108-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.boundary_edge_contributions!" href="#FiniteVolumeMethod.boundary_edge_contributions!"><code>FiniteVolumeMethod.boundary_edge_contributions!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boundary_edge_contributions!(A, b, mesh, conditions, diffusion_function, diffusion_parameters)</code></pre><p>Add the contributions from each boundary edge to the matrix <code>A</code>, based on the equation </p><p class="math-container">\[\dv{u_i}{t} = \frac{1}{V_i}\sum_{\sigma \in \mathcal E_i} D(\vb x_\sigma)\left[\left(s_{k, 11}n_\sigma^x + s_{k, 21}n_\sigma^y\right)u_{k1} + \left(s_{k, 12}n_\sigma^x + s_{k, 22}n_\sigma^y\right)u_{k2} + \left(s_{k, 13}n_\sigma^x + s_{k, 23}n_\sigma^y\right)u_{k3}\right]L_\sigma + S_i, \]</p><p>as explained in the docs. Will not update any rows corresponding to  <a href="../../interface/#FiniteVolumeMethod.Dirichlet"><code>Dirichlet</code></a> or <a href="../../interface/#FiniteVolumeMethod.Dudt"><code>Dudt</code></a> nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/specific_problems/abstract_templates.jl#L125-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.non_neumann_boundary_edge_contributions!" href="#FiniteVolumeMethod.non_neumann_boundary_edge_contributions!"><code>FiniteVolumeMethod.non_neumann_boundary_edge_contributions!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">non_neumann_boundary_edge_contributions!(A, mesh, conditions, diffusion_function, diffusion_parameters)</code></pre><p>Add the contributions from each non-Neumann boundary edge to the matrix <code>A</code>, based on the equation</p><p class="math-container">\[\dv{u_i}{t} = \frac{1}{V_i}\sum_{\sigma \in \mathcal E_i} D(\vb x_\sigma)\left[\left(s_{k, 11}n_\sigma^x + s_{k, 21}n_\sigma^y\right)u_{k1} + \left(s_{k, 12}n_\sigma^x + s_{k, 22}n_\sigma^y\right)u_{k2} + \left(s_{k, 13}n_\sigma^x + s_{k, 23}n_\sigma^y\right)u_{k3}\right]L_\sigma + S_i, \]</p><p>as explained in the docs. Will not update any rows corresponding to  <a href="../../interface/#FiniteVolumeMethod.Dirichlet"><code>Dirichlet</code></a> or <a href="../../interface/#FiniteVolumeMethod.Dudt"><code>Dudt</code></a> nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/specific_problems/abstract_templates.jl#L203-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.neumann_boundary_edge_contributions!" href="#FiniteVolumeMethod.neumann_boundary_edge_contributions!"><code>FiniteVolumeMethod.neumann_boundary_edge_contributions!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">neumann_boundary_edge_contributions!(b, mesh, conditions, diffusion_function, diffusion_parameters)</code></pre><p>Add the contributions from each Neumann boundary edge to the vector <code>b</code>, based on the equation</p><p class="math-container">\[\dv{u_i}{t} = \frac{1}{V_i}\sum_{\sigma \in \mathcal E_i} D(\vb x_\sigma)\left[\grad u(\vb x_\sigma) \vdot \vu n\right]L_\sigma + S_i,\]</p><p>as explained in the docs. Will not update any rows corresponding to  <a href="../../interface/#FiniteVolumeMethod.Dirichlet"><code>Dirichlet</code></a> or <a href="../../interface/#FiniteVolumeMethod.Dudt"><code>Dudt</code></a> nodes. This function will pass <code>nothing</code> in place  of the arguments <code>u</code> and <code>t</code> in the boundary condition functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/specific_problems/abstract_templates.jl#L144-L156">source</a></section><section><div><pre><code class="nohighlight hljs">neumann_boundary_edge_contributions!(F, mesh, conditions, diffusion_function, diffusion_parameters, u, t)</code></pre><p>Add the contributions from each Neumann boundary edge to the vector <code>F</code>, based on the equation</p><p class="math-container">\[\dv{u_i}{t} = \frac{1}{V_i}\sum_{\sigma \in \mathcal E_i} D(\vb x_\sigma)\left[\grad u(\vb x_\sigma) \vdot \vu n\right]L_\sigma + S_i,\]</p><p>as explained in the docs. Will not update any rows corresponding to  <a href="../../interface/#FiniteVolumeMethod.Dirichlet"><code>Dirichlet</code></a> or <a href="../../interface/#FiniteVolumeMethod.Dudt"><code>Dudt</code></a> nodes. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/specific_problems/abstract_templates.jl#L173-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.create_rhs_b" href="#FiniteVolumeMethod.create_rhs_b"><code>FiniteVolumeMethod.create_rhs_b</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_rhs_b(mesh, conditions, source_function, source_parameters)</code></pre><p>Create the vector <code>b</code> defined by </p><pre><code class="nohighlight hljs">b = [source_function(x, y, source_parameters) for (x, y) in each_point(mesh.triangulation)],</code></pre><p>and <code>b[i] = 0</code> whenever <code>i</code> is a Dirichlet node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/specific_problems/abstract_templates.jl#L241-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.apply_steady_dirichlet_conditions!" href="#FiniteVolumeMethod.apply_steady_dirichlet_conditions!"><code>FiniteVolumeMethod.apply_steady_dirichlet_conditions!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">apply_steady_dirichlet_conditions!(A, b, mesh, conditions)</code></pre><p>Applies the Dirichlet conditions specified in <code>conditions</code> to the <code>initial_condition</code>. The boundary  conditions are assumed to take the form <code>a(x, y, t, u, p) -&gt; Number</code>, but <code>t</code> and <code>u</code> are passed  as <code>nothing</code>. Note that this assumes that the associated system <code>(A, b)</code> is such that <code>A[i, :]</code> is all  zero, and <code>b[i]</code> is zero, where <code>i</code> is a node with a Dirichlet condition.</p><p>For a steady problem <code>Au = b</code>, applies the Dirichlet boundary conditions specified by <code>conditions</code>  so that <code>A[i, i] = 1</code> and <code>b[i]</code> is the condition, where <code>i</code> is a boundary node. Note that this  assumes that all of <code>A[i, :]</code> is zero before setting <code>A[i, i] = 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/specific_problems/abstract_templates.jl#L262-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.two_point_interpolant" href="#FiniteVolumeMethod.two_point_interpolant"><code>FiniteVolumeMethod.two_point_interpolant</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">two_point_interpolant(mesh, u, i, j, mx, my)</code></pre><p>Given a <code>mesh &lt;: FVMGeometry</code>, a set of function values <code>u</code> at the nodes of <code>mesh</code>,  and a point <code>(mx, my)</code> on the line segment between the nodes <code>i</code> and <code>j</code>, interpolates the solution at the point <code>(mx, my)</code> using two-point interpolation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/utils.jl#L27-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.get_dirichlet_callback" href="#FiniteVolumeMethod.get_dirichlet_callback"><code>FiniteVolumeMethod.get_dirichlet_callback</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_dirichlet_callback(prob[, f=update_dirichlet_nodes!]; kwargs...)</code></pre><p>Get the callback for updating <a href="../../interface/#FiniteVolumeMethod.Dirichlet"><code>Dirichlet</code></a> nodes. The <code>kwargs...</code> argument is ignored,  except to detect if a user has already provided a callback, in which case the  callback gets merged into a <code>CallbackSet</code> with the <a href="../../interface/#FiniteVolumeMethod.Dirichlet"><code>Dirichlet</code></a> callback. If the problem  <code>prob</code> has no <a href="../../interface/#FiniteVolumeMethod.Dirichlet"><code>Dirichlet</code></a> nodes, the returned callback does nothing and is never  called.</p><p>You can provide <code>f</code> to change the function that updates the <a href="../../interface/#FiniteVolumeMethod.Dirichlet"><code>Dirichlet</code></a> nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/solve.jl#L142-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.jacobian_sparsity" href="#FiniteVolumeMethod.jacobian_sparsity"><code>FiniteVolumeMethod.jacobian_sparsity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">jacobian_sparsity(prob)</code></pre><p>Returns a prototype for the Jacobian of the given <code>prob</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/feaf66391431a92e6b3b14135315c2d6744a8861/src/solve.jl#L44-L48">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../tutorials/keller_segel_chemotaxis/">« Keller-Segel Model of Chemotaxis</a><a class="docs-footer-nextpage" href="../diffusion_equations/">Diffusion Equations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 15 September 2023 02:04">Friday 15 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
