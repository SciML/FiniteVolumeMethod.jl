<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Mathematical and Implementation Details · FiniteVolumeMethod.jl</title><meta name="title" content="Mathematical and Implementation Details · FiniteVolumeMethod.jl"/><meta property="og:title" content="Mathematical and Implementation Details · FiniteVolumeMethod.jl"/><meta property="twitter:title" content="Mathematical and Implementation Details · FiniteVolumeMethod.jl"/><meta name="description" content="Documentation for FiniteVolumeMethod.jl."/><meta property="og:description" content="Documentation for FiniteVolumeMethod.jl."/><meta property="twitter:description" content="Documentation for FiniteVolumeMethod.jl."/><meta property="og:url" content="https://SciML.github.io/FiniteVolumeMethod.jl/math/"/><meta property="twitter:url" content="https://SciML.github.io/FiniteVolumeMethod.jl/math/"/><link rel="canonical" href="https://SciML.github.io/FiniteVolumeMethod.jl/math/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FiniteVolumeMethod.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../interface/">Interface</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorials/overview/">Section Overview</a></li><li><a class="tocitem" href="../tutorials/diffusion_equation_on_a_square_plate/">Diffusion Equation on a Square Plate</a></li><li><a class="tocitem" href="../tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/">Diffusion Equation in a Wedge with Mixed Boundary Conditions</a></li><li><a class="tocitem" href="../tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/">Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk</a></li><li><a class="tocitem" href="../tutorials/porous_medium_equation/">Porous-Medium Equation</a></li><li><a class="tocitem" href="../tutorials/porous_fisher_equation_and_travelling_waves/">Porous-Fisher Equation and Travelling Waves</a></li><li><a class="tocitem" href="../tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/">Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation</a></li><li><a class="tocitem" href="../tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/">Helmholtz Equation with Inhomogeneous Boundary Conditions</a></li><li><a class="tocitem" href="../tutorials/laplaces_equation_with_internal_dirichlet_conditions/">Laplace&#39;s Equation with Internal Dirichlet Conditions</a></li><li><a class="tocitem" href="../tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/">Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems</a></li><li><a class="tocitem" href="../tutorials/reaction_diffusion_brusselator_system_of_pdes/">A Reaction-Diffusion Brusselator System of PDEs</a></li><li><a class="tocitem" href="../tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/">Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System</a></li><li><a class="tocitem" href="../tutorials/diffusion_equation_on_an_annulus/">Diffusion Equation on an Annulus</a></li><li><a class="tocitem" href="../tutorials/mean_exit_time/">Mean Exit Time</a></li><li><a class="tocitem" href="../tutorials/solving_mazes_with_laplaces_equation/">Solving Mazes with Laplace&#39;s Equation</a></li><li><a class="tocitem" href="../tutorials/keller_segel_chemotaxis/">Keller-Segel Model of Chemotaxis</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Solvers for Specific Problems, and Writing Your Own</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../wyos/overview/">Section Overview</a></li><li><a class="tocitem" href="../wyos/diffusion_equations/">Diffusion Equations</a></li><li><a class="tocitem" href="../wyos/mean_exit_time/">Mean Exit Time Problems</a></li><li><a class="tocitem" href="../wyos/linear_reaction_diffusion_equations/">Linear Reaction-Diffusion Equations</a></li><li><a class="tocitem" href="../wyos/poissons_equation/">Poisson&#39;s Equation</a></li><li><a class="tocitem" href="../wyos/laplaces_equation/">Laplace&#39;s Equation</a></li></ul></li><li class="is-active"><a class="tocitem" href>Mathematical and Implementation Details</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Interior-Discretisation"><span>Interior Discretisation</span></a></li><li><a class="tocitem" href="#Control-volumes"><span>Control volumes</span></a></li><li><a class="tocitem" href="#Discretising-the-PDE"><span>Discretising the PDE</span></a></li><li class="toplevel"><a class="tocitem" href="#Boundary-Conditions"><span>Boundary Conditions</span></a></li><li><a class="tocitem" href="#Dirichlet-boundary-conditions"><span>Dirichlet boundary conditions</span></a></li><li><a class="tocitem" href="#Time-dependent-Dirichlet-boundary-conditions"><span>Time-dependent Dirichlet boundary conditions</span></a></li><li><a class="tocitem" href="#Neumann-boundary-conditions"><span>Neumann boundary conditions</span></a></li><li class="toplevel"><a class="tocitem" href="#Internal-Conditions"><span>Internal Conditions</span></a></li><li class="toplevel"><a class="tocitem" href="#Putting-Everything-Together"><span>Putting Everything Together</span></a></li><li class="toplevel"><a class="tocitem" href="#Systems-of-Equations"><span>Systems of Equations</span></a></li><li class="toplevel"><a class="tocitem" href="#Steady-State-Problems"><span>Steady-State Problems</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Mathematical and Implementation Details</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Mathematical and Implementation Details</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/FiniteVolumeMethod.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/FiniteVolumeMethod.jl/blob/main/docs/src/math.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Mathematical-and-Implementation-Details"><a class="docs-heading-anchor" href="#Mathematical-and-Implementation-Details">Mathematical and Implementation Details</a><a id="Mathematical-and-Implementation-Details-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-and-Implementation-Details" title="Permalink"></a></h1><ul><li><a href="#Mathematical-and-Implementation-Details">Mathematical and Implementation Details</a></li><li><a href="#Interior-Discretisation">Interior Discretisation</a></li><li class="no-marker"><ul><li><a href="#Control-volumes">Control volumes</a></li><li><a href="#Discretising-the-PDE">Discretising the PDE</a></li></ul></li><li><a href="#Boundary-Conditions">Boundary Conditions</a></li><li class="no-marker"><ul><li><a href="#Dirichlet-boundary-conditions">Dirichlet boundary conditions</a></li><li><a href="#Time-dependent-Dirichlet-boundary-conditions">Time-dependent Dirichlet boundary conditions</a></li><li><a href="#Neumann-boundary-conditions">Neumann boundary conditions</a></li></ul></li><li><a href="#Internal-Conditions">Internal Conditions</a></li><li><a href="#Putting-Everything-Together">Putting Everything Together</a></li><li><a href="#Systems-of-Equations">Systems of Equations</a></li><li><a href="#Steady-State-Problems">Steady-State Problems</a></li></ul><p>Here we outline the mathematical and implementation details involved in implementing the finite volume method (FVM). We assume that our partial differential equation (PDE) is given by </p><p class="math-container">\[\begin{equation}
\label{eq:pde}
\pdv{u(\vb x, t)}{t} + \div \vb q(\vb x, t, u) = S(\vb x, t, u), \quad \vb x \in \Omega,
\end{equation}\]</p><p>together with some boundary conditions or internal conditions that we discuss later. We also discuss steady-state problems and systems of PDEs of the form \eqref{eq:pde}.</p><h1 id="Interior-Discretisation"><a class="docs-heading-anchor" href="#Interior-Discretisation">Interior Discretisation</a><a id="Interior-Discretisation-1"></a><a class="docs-heading-anchor-permalink" href="#Interior-Discretisation" title="Permalink"></a></h1><p>Let us start by discretising \eqref{eq:pde} inside <span>$\Omega$</span>. The first step in this discretisation is to compute a triangulation of <span>$\Omega$</span>, decomposing <span>$\Omega$</span> into a collection of disjoint triangles <span>$\{T_k\}$</span> so that </p><p class="math-container">\[\Omega = \bigcup_k T_k.\]</p><p>This triangulation is typically a <em>constrained Delaunay triangulation</em>, denoted <span>$\mathcal T(\Omega)$</span>, with appropriate care taken if <span>$\Omega$</span> is multiply-connected; these triangulations can be computed using <a href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl">DelaunayTriangulation.jl</a>. An example of such a domain <span>$\Omega$</span> and its triangulation <span>$\mathcal T(\Omega)$</span> is shown below, where we use a multiply-connected domain to emphasise that these details are not necessarily restricted to simple domains.</p><img src="2be44e4a.png" alt="Example block output"/><h2 id="Control-volumes"><a class="docs-heading-anchor" href="#Control-volumes">Control volumes</a><a id="Control-volumes-1"></a><a class="docs-heading-anchor-permalink" href="#Control-volumes" title="Permalink"></a></h2><p>Key to the FVM are the <em>control volumes</em>, which are used to define volumes <span>$\Omega_i$</span> around individual vertices <span>$\vb x_i$</span> that we integrate the PDE over. To define these volumes, take <span>$\vb x_i \in \Omega$</span>, which is a vertex of <span>$\mathcal T(\Omega)$</span>, and take the set of triangles <span>$\mathcal T_i = \{T_k\}$</span> that have <span>$\vb x_i$</span> as a vertex. For each of these triangles <span>$T_{k&#39;} \in \mathcal T_i$</span>, connect its centroid to the midpoints of the triangle&#39;s edges. Once this procedure is complete, we obtain a closed polygon around <span>$\vb x_i$</span> that we denote by <span>$\partial\Omega_i$</span> and whose interior defines the control volume <span>$\Omega_i$</span>. We show the result of this procedure, applied to the above domain, below, where we show the centroids in red and the control volume boundaries in blue.</p><img src="d1724c4a.png" alt="Example block output"/><p>Let us now establish some notation for referring to these control volumes, using the figure below  as a reference.</p><table><tr><th style="text-align: left">Symbol</th><th style="text-align: left">Description</th><th style="text-align: left">Example</th></tr><tr><td style="text-align: left"><span>$\vb x_i$</span></td><td style="text-align: left">A vertex of <span>$\mathcal T(\Omega)$</span></td><td style="text-align: left">The blue point below</td></tr><tr><td style="text-align: left"><span>$\Omega_i$</span></td><td style="text-align: left">The control volume around <span>$\vb x_i$</span></td><td style="text-align: left">The green region below</td></tr><tr><td style="text-align: left"><span>$\partial\Omega_i$</span></td><td style="text-align: left">The boundary of <span>$\Omega_i$</span></td><td style="text-align: left">The blue edges below</td></tr><tr><td style="text-align: left"><span>$V_i$</span></td><td style="text-align: left">The volume of <span>$\Omega_i$</span></td><td style="text-align: left">The volume of the green region below</td></tr><tr><td style="text-align: left"><span>$\mathcal E_i$</span></td><td style="text-align: left">The set of edges of <span>$\partial\Omega_i$</span></td><td style="text-align: left">The blue edges below</td></tr><tr><td style="text-align: left"><span>$\sigma$</span></td><td style="text-align: left">An edge <span>$\sigma \in \mathcal E_i$</span></td><td style="text-align: left">The magenta edge below. Note that <span>$\bigcup_{\sigma \in \mathcal E_i} \sigma = \partial\Omega_i$</span></td></tr><tr><td style="text-align: left"><span>$\vb x_{\sigma}$</span></td><td style="text-align: left">The midpoint of <span>$\sigma \in \mathcal E_i$</span></td><td style="text-align: left">The blue point below on <span>$\sigma$</span></td></tr><tr><td style="text-align: left"><span>$\hat{\vb n}_{\sigma}$</span></td><td style="text-align: left">The outward unit normal vector to <span>$\sigma \in \mathcal E_i$</span></td><td style="text-align: left">The black arrow below</td></tr><tr><td style="text-align: left"><span>$\mathcal T_i$</span></td><td style="text-align: left">The set of triangles that have <span>$\vb x_i$</span> as a vertex</td><td style="text-align: left">The black triangles surrounding <span>$\vb x_i$</span> below</td></tr><tr><td style="text-align: left"><span>$L_\sigma$</span></td><td style="text-align: left">The length of <span>$\sigma \in \mathcal E_i$</span></td><td style="text-align: left">The length of the magenta edge below</td></tr></table><img src="a6f88ab7.png" alt="Example block output"/><h2 id="Discretising-the-PDE"><a class="docs-heading-anchor" href="#Discretising-the-PDE">Discretising the PDE</a><a id="Discretising-the-PDE-1"></a><a class="docs-heading-anchor-permalink" href="#Discretising-the-PDE" title="Permalink"></a></h2><p>Now that we have our concept of control volumes, we can discretise the PDE \eqref{eq:pde}. We do this  by considering each PDE inside each <span>$\Omega_i$</span> and integrating. For a given control volume <span>$\Omega_i$</span>, we can integrate the PDE to give</p><p class="math-container">\[\begin{equation}\label{eq:integratedi}
\dv{t}\iint_{\Omega_i} u\dd{V} + \iint_{\Omega_i} \div\vb q \dd{V} = \iint_{\Omega_i} S \dd{V}.
\end{equation}\]</p><p>Using the divergence theorem, the second integral in \eqref{eq:integratedi} becomes</p><p class="math-container">\[\begin{equation}\label{eq:applieddthm}
\iint_{\Omega_i} \div\vb q = \oint_{\partial\Omega_i} \vb q \vdot \vu n_\sigma \dd{s} = \sum_{\sigma \in \mathcal E_i} \int_\sigma \vb q \vdot \vu n_\sigma \dd{s},
\end{equation}\]</p><p>where the last equality in \eqref{eq:applieddthm} follows from integrating over each individual line segment that defines <span>$\partial\Omega_i$</span>, which is simply <span>$\mathcal E_i$</span>. We then define the <em>control volume averages</em>,</p><p class="math-container">\[\begin{equation}\label{eq:averages}
\bar u_i = \frac{1}{V_i}\iint_{\Omega_i} u\dd{V},\quad \bar S_i = \frac{1}{V_i}\iint_{\Omega_i} S\dd{V},
\end{equation}\]</p><p>so that our integral formulation \eqref{eq:integratedi} becomes</p><p class="math-container">\[\begin{equation}\label{eq:intform}
\dv{\bar u_i}{t} + \frac{1}{V_i}\sum_{\sigma\in\mathcal E_i}\int_\sigma \vb q \vdot \vu n_\sigma \dd{s} = \bar S_i.
\end{equation}\]</p><p>Note that \eqref{eq:intform} is still an exact expression.</p><p>To proceed, we need to approximate the integrals <span>$\int_\sigma \vb q \vdot \vu n_\sigma\dd{s}$</span>. To accomplish this, we use a midpoint rule, writing</p><p class="math-container">\[\begin{equation}\label{eq:midpt_rule}
\int_\sigma \vb q \vdot \vu n_\sigma \dd{s} \approx \left[\vb q(\vb x_\sigma, t, u(\vb x_\sigma, t))\vdot \vu n_\sigma\right]L_\sigma.
\end{equation}\]</p><p>Then, replacing the control volume averages with their value at <span>$\vb x_i$</span>, we obtain the following approximation:</p><p class="math-container">\[\begin{equation}\label{eq:nextapprox}
\dv{u_i}{t} + \frac{1}{V_i}\sum_{\sigma\in\mathcal E_i} \left[\vb q(\vb x_\sigma, t, u(\vb x_\sigma, t)) \vdot \vu n_\sigma\right]L_\sigma = S_i,
\end{equation}\]</p><p>where <span>$u_i = u(\vb x_i, t)$</span> and <span>$S_i = S(\vb x_i, t)$</span>. </p><p>The final step in this part of the approximation is the evaluation of <span>$\vb q(\vb x_\sigma, t, u(\vb x_\sigma, t))$</span>. To deal with this function, consider some <span>$T_k \in \mathcal T_i$</span> so that <span>$\vb x_\sigma$</span> is inside <span>$T_k$</span>. We use a linear shape function inside <span>$T_k$</span> to approximate <span>$u$</span>, writing</p><p class="math-container">\[\begin{equation}\label{eq:shape}
u(\vb x, t) = \alpha_kx + \beta_ky + \gamma_k, \quad \vb x \in T_k,
\end{equation}\]</p><p>where we have suppressed the dependence of the coefficients <span>$(\alpha_k, \beta_k,\gamma_k)$</span> on <span>$t$</span>. The vertices of <span>$T_k$</span> are given by <span>$v_{k1}, v_{k2}, v_{k3}$</span> with corresponding coordinates <span>$\vb x_{k1}, \vb x_{k2}, \vb x_{k3}$</span>, respectively. We can then solve for the coefficients in \eqref{eq:shape} by requiring that <span>$u$</span> is equal to the values at the vertices of <span>$T_k$</span>, giving the system of equations</p><p class="math-container">\[\begin{equation}\label{eq:near_cramer}
\begin{aligned}
u(\vb x_{k1}, t) &amp;= \alpha_kx_{k1} + \beta_ky_{k1} + \gamma_k, \\
u(\vb x_{k2}, t) &amp;= \alpha_kx_{k2} + \beta_ky_{k2} + \gamma_k, \\
u(\vb x_{k3}, t) &amp;= \alpha_kx_{k3} + \beta_ky_{k3} + \gamma_k,
\end{aligned}
\end{equation}\]</p><p>where <span>$\vb x_{ki} = (x_{ki}, y_{ki})^{\mkern-1.5mu\mathsf{T}}$</span>. Note that the values on the left-hand side of \eqref{eq:near_cramer} are all known from either the initial condition or the previous time-step. Using Cramer&#39;s rule, we define</p><p class="math-container">\[\begin{equation}\label{eq:shape_coeffs}
\vb S_k = \frac{1}{\Delta_k}\begin{bmatrix} y_{k2}-y_{k3} &amp; y_{k3}-y_{k1} &amp; y_{k1}-y_{k2} \\ x_{k3} - x_{k2} &amp; x_{k1}-x_{k3}&amp;x_{k2}-x_{k1} \\ x_{k2}y_{k3}-x_{k3}y_{k2} &amp; x_{k3}y_{k1}-x_{k1}y_{k3}&amp;x_{k1}y_{k2}-x_{k2}y_{k1} \end{bmatrix},
\end{equation}\]</p><p>where</p><p class="math-container">\[\begin{equation}\label{eq:deltak}
\Delta_k = x_{k1}y_{k2}-x_{k2}y_{k1}-x_{k1}y_{k3}+x_{k3}y_{k1}+x_{k2}y_{k3}-x_{k3}y_{k2},
\end{equation}\]</p><p>and thus we obtain</p><p class="math-container">\[\begin{equation}\label{eq:shapecoeffvals}
\begin{aligned}
\alpha_k &amp;= s_{k,11}u_{k1} + s_{k,12}u_{k2} + s_{k,13}u_{k3}, \\
\beta_k &amp;= s_{k,21}u_{k1} + s_{k,22}u_{k2} + s_{k,23}u_{k3}, \\
\gamma_k &amp;= s_{k,31}u_{k1} + s_{k,32}u_{k2} + s_{k,33}u_{k3},
\end{aligned}
\end{equation}\]</p><p>where <span>$u_{ki} = u(\vb x_{ki}, t)$</span> and <span>$s_{k,ij}$</span> are the elements of <span>$\vb S_k$</span>. With \eqref{eq:shape} and \eqref{eq:shapecoeffvals}, we can approximate <span>$\vb q(\vb x_\sigma, t, u(\vb x_\sigma, t))$</span> and thus obtain the approximation</p><p class="math-container">\[\begin{equation}\label{eq:interiorapproximation}
\dv{u_i}{t} + \frac{1}{V_i}\sum_{\sigma\in\mathcal E_i} \left[\vb q\left(\vb x_\sigma, t, \alpha_{k(\sigma)}x_\sigma + \beta_{k(\sigma)}y_\sigma + \gamma_{k(\sigma)}\right)\vdot \vu n_\sigma\right]L_\sigma = S_i,
\end{equation}\]</p><p>where <span>$k(\sigma)$</span> is the index of the triangle that contains <span>$\vb x_\sigma$</span>. This linear shape function also allows us to compute gradients like <span>$\grad u(\vb x_\sigma, t)$</span>, since <span>$\grad u(\vb x_\sigma, t) = (\alpha_{k(\sigma)}, \beta_{k(\sigma)})^{\mkern-1.5mu\mathsf{T}}$</span>.</p><h1 id="Boundary-Conditions"><a class="docs-heading-anchor" href="#Boundary-Conditions">Boundary Conditions</a><a id="Boundary-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-Conditions" title="Permalink"></a></h1><p>Let us now discuss how boundary conditions (BCs) are handled. We assume that BCs take on any of the following forms:</p><p class="math-container">\[\begin{align}
\vb q(\vb x, t, u) \vdot \vu n_\sigma &amp;= a(\vb x, t, u) &amp; \vb x \in \mathcal B \subseteq \partial\Omega, \label{eq:neumann} \\
\dv{u(\vb x, t)}{t} &amp;= a(\vb x, t, u) &amp; \vb x \in \mathcal B \subseteq \partial\Omega, \label{eq:dudtdirichlet} \\
u(\vb x, t) &amp;= a(\vb x, t, u) &amp; \vb x \in \mathcal B \subseteq \partial\Omega, \label{eq:dirichlet}
\end{align}\]</p><p>where the functions <span>$a$</span> are user-provided functions. The conditions \eqref{eq:neumann}–\eqref{eq:dirichlet} are called <em>Neumann</em>, <em>time-dependent Dirichlet</em>, and <em>Dirichlet</em>, respectively. We discuss how we handle incompatible BCs below, and then how each of these three types are implemented. </p><h2 id="Dirichlet-boundary-conditions"><a class="docs-heading-anchor" href="#Dirichlet-boundary-conditions">Dirichlet boundary conditions</a><a id="Dirichlet-boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Dirichlet-boundary-conditions" title="Permalink"></a></h2><p>When we have a Dirichlet BC of the form \eqref{eq:dirichlet}, the implementation is simple: Rather than using \eqref{eq:interiorapproximation}, we instead leave <span>$\mathrm du_i/\mathrm dt = 0$</span> and update the value of <span>$u_i$</span> with <span>$a(\vb x_i, t, u_i)$</span> at the end of the iteration using a callback; note that the expression <span>$u_i = a(\vb x_i, t, u_i)$</span> is <strong>not</strong> an implicit equation for <span>$u_i$</span>, rather it is simply a reassignment of <span>$u_i$</span> to <span>$a(\vb x_i, t, u_i)$</span>, i.e. <span>$u_i \leftarrow a(\vb x_i, t, u_i)$</span>.</p><h2 id="Time-dependent-Dirichlet-boundary-conditions"><a class="docs-heading-anchor" href="#Time-dependent-Dirichlet-boundary-conditions">Time-dependent Dirichlet boundary conditions</a><a id="Time-dependent-Dirichlet-boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Time-dependent-Dirichlet-boundary-conditions" title="Permalink"></a></h2><p>For a time-dependent Dirichlet BC of the form \eqref{eq:dudtdirichlet}, the implementation is again simple: Rather than using \eqref{eq:interiorapproximation}, simply compute <span>$\mathrm du_i/\mathrm dt = a(\vb x_i, t, u_i)$</span> instead. </p><h2 id="Neumann-boundary-conditions"><a class="docs-heading-anchor" href="#Neumann-boundary-conditions">Neumann boundary conditions</a><a id="Neumann-boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Neumann-boundary-conditions" title="Permalink"></a></h2><p>Neumann boundary conditions \eqref{eq:neumann} are the most complex out of the three. Let us return to our integral formulation \eqref{eq:intform}. Let <span>$\mathcal E_i^n$</span> be the set of edges in <span>$\mathcal E_i$</span> that have a Neumann BC associated with them, and <span>$\mathcal E_i^c = \mathcal E_i \setminus \mathcal E_i^n$</span>. Then, also using \eqref{eq:interiorapproximation}, in the case of \eqref{eq:neumann} we can write</p><p class="math-container">\[\begin{equation}\label{eq:neumanndecomp}
\dv{u_i}{t} + \frac{1}{V_i}\sum_{\sigma\in \mathcal E_i^c} \left[\vb q(\vb x_\sigma, t, \alpha_{k(\sigma)}x_\sigma + \beta_{k(\sigma)}y_\sigma + \gamma_{k(\sigma)}) \vdot \vu n_\sigma\right]L_\sigma + \frac{1}{V_i}\sum_{\sigma\in\mathcal E_i^n} \int_{\sigma} a_{\sigma}(\vb x, t, u)\dd{s} = S_i,
\end{equation}\]</p><p>where <span>$a_\sigma$</span> is the BC function associated with <span>$\sigma$</span>. This integral is then approximated using a midpoint rule as done previously, giving</p><p class="math-container">\[\begin{equation}\label{eq:neumanndecompapprox}
\dv{u_i}{t} + \frac{1}{V_i}\sum_{\sigma\in \mathcal E_i^c} \left[\vb q(\vb x_\sigma, t, u(\vb x_\sigma, t)) \vdot \vu n_\sigma\right]L_\sigma + \frac{1}{V_i}\sum_{\sigma\in\mathcal E_i^n} \left[a_{\sigma}(\vb x_\sigma, t, u(\vb x_\sigma, t))\right]L_\sigma = S_i,
\end{equation}\]</p><p>where <span>$u(\vb x_\sigma, t) = \alpha_{k(\sigma)}x_\sigma + \beta_{k(\sigma)}y_\sigma + \gamma_{k(\sigma)}$</span>.</p><h1 id="Internal-Conditions"><a class="docs-heading-anchor" href="#Internal-Conditions">Internal Conditions</a><a id="Internal-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-Conditions" title="Permalink"></a></h1><p>We also allow for specifying internal conditions, meaning conditions of the form \eqref{eq:neumann}–\eqref{eq:dirichlet} that are applied away from the boundary. We do not currently allow for internal Neumann conditions directly.<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> These conditions are handled in the same way as BCs, except that the user is to provide them per-vertex rather than per-edge.</p><h1 id="Putting-Everything-Together"><a class="docs-heading-anchor" href="#Putting-Everything-Together">Putting Everything Together</a><a id="Putting-Everything-Together-1"></a><a class="docs-heading-anchor-permalink" href="#Putting-Everything-Together" title="Permalink"></a></h1><p>We have now specified how we discretise the PDE itself, and how we handle both boundary and internal conditions. The remaining task is to actually discuss how we compute <span>$\mathrm du_i/\mathrm dt$</span>. As written, \eqref{eq:interiorapproximation} indicates that we loop over each vertex and, within each vertex, loop over each edge of its control volume. On average, <span>$|\mathcal E_i^c| = 12$</span> (since, on average, a point in a Delaunay triangulation has six neighbours), and so computing <span>$\mathrm du_i/\mathrm dt$</span> for each <span>$i$</span> requires <span>$\mathcal O(12n)$</span> loop iterates and many repeated computations (since each control volume edge appears in another control volume), where <span>$n$</span> is the number of points in the mesh. An alternative approach is to instead loop over each triangle in <span>$\mathcal T(\Omega)$</span> and to then loop over each edge, adding the contributions from each to the associated vertices. This instead requires <span>$\mathcal O(3|\mathcal T|)$</span> loop iterates, where <span>$|\mathcal T|$</span> is the number of triangles in <span>$\mathcal T(\Omega)$</span>, and we instead only need to compute the relevant quantities for each control volume edge a single time; note that <span>$|\mathcal T| = \mathcal O(n)$</span> by Euler&#39;s formula. This is the approach we take in our implementation.</p><p>Let us think about how we can instead loop over each triangle. Consider an interior control volume, shown below.</p><img src="4dcaa65a.png" alt="Example block output"/><p>We denote the triangle in blue by <span>$T$</span>, and refer to the blue, red, and green vertices by <span>$v_b$</span>, <span>$v_r$</span>, and <span>$v_g$</span>, respectively. The relevant edges that contribute to <span>$\mathrm du_b/\mathrm dt$</span>, <span>$\mathrm du_r/\mathrm dt$</span>, and <span>$\mathrm du_g/\mathrm dt$</span> are <span>$\sigma_{br}$</span>, <span>$\sigma_{rg}$</span>, and <span>$\sigma_{gb}$</span>, as annotated above. In particular, <span>$\sigma_{br}$</span> contributes to both <span>$\mathrm du_b/\mathrm dt$</span> and <span>$\mathrm du_r/\mathrm dt$</span>, <span>$\sigma_{rg}$</span> contributes to both <span>$\mathrm du_r/\mathrm dt$</span> and <span>$\mathrm du_g/\mathrm dt$</span>, and <span>$\sigma_{gb}$</span> contributes to both <span>$\mathrm du_g/\mathrm dt$</span> and <span>$\mathrm du_b/\mathrm dt$</span>. </p><p>Let us focus on <span>$u_b$</span> and <span>$u_r$</span>. The contribution from <span>$e_{br}$</span> to <span>$\mathrm du_b/\mathrm dt$</span> and <span>$\mathrm du_r/\mathrm dt$</span> is given by:</p><p class="math-container">\[\begin{equation}\label{eq:triangleupdate}
\begin{aligned}
\dv{u_b}{t} &amp;\leftarrow \dv{u_b}{t} - Q, \\
\dv{u_r}{t} &amp; \leftarrow \dv{u_r}{t} + Q, 
\end{aligned}
\end{equation}\]</p><p>where </p><p class="math-container">\[Q = \left[\vb q\left(\vb x_{br}, t, \alpha x_{br} + \beta y_{br} + \gamma\right) \vdot \vu n_{br}\right]L_{br},\]</p><p>and <span>$\vb x_{br}$</span> is the midpoint of <span>$e_{br}$</span>; <span>$\vu n_{br}$</span> is the unit normal vector to the edge <span>$\sigma_{br} = \overrightarrow{\vb x_{br}\vb x_T}$</span>, where <span>$\vb x_T$</span> is the centroid of <span>$T$</span> which should only be computed once for the current <span>$T$</span>, which should point away from <span>$\vb x_b$</span> but towards <span>$\vb x_r$</span>; <span>$L_{br} = \|\vb x_T - \vb x_{br}\|$</span>, and <span>$\alpha,\beta,\gamma$</span> are computed from \eqref{eq:shapecoeffvals} using the vertices of <span>$T$</span>. Notice that \eqref{eq:triangleupdate} uses a minus sign for <span>$\mathrm du_b/\mathrm dt$</span> and a plus sign for <span>$\mathrm du_r/\mathrm dt$</span>, because we have brought the sum in \eqref{eq:interiorapproximation} to the right-hand side of the equation. </p><p>When we apply the procedure above to each triangle, we will have computed the contribution from each edge to each vertex - almost. The only issue is with boundary triangles, where the edges that lie on the boundary will not be iterated over as they not of the form <span>$\overrightarrow{\vb x_{br}\vb x_T}$</span> (i.e., they are not connected to a centroid). There are two ways to handle this:</p><ol><li>For each triangle looped over, also check if it is a boundary triangle and then consider its boundary edges.</li><li>After looping over all triangles, loop over all boundary edges to pick up the missing contributions.</li></ol><p>The second approach is preferable, as we don&#39;t need to worry about needless checks for boundary triangles, the number of boundary edges it has, etc. </p><p>To understand how to pick up contributions from a single edge, consider the figure below which shows some control volumes in the corner of a domain:</p><img src="3710d24f.png" alt="Example block output"/><p>Consider the edge <span>$e_{ij}$</span> shown in red. There two control volumes that lie on <span>$e_{ij}$</span>, the one for <span>$v_i$</span> and the other for <span>$v_j$</span>. We denote the midpoint of <span>$e_{ij}$</span> by <span>$\vb x_{ij} = (\vb x_i + \vb x_j)/2$</span>, so that the two control volume edges are <span>$\overrightarrow{\vb x_i\vb x_{ij}}$</span> and <span>$\overrightarrow{\vb x_{ij}\vb x_j}$</span> for <span>$v_i$</span> and <span>$v_j$</span>, respectively. The contributions from the flux over each edge gives</p><p class="math-container">\[\begin{equation}\label{eq:bndedgecontrbi}
\begin{aligned}
\dv{u_i}{t} &amp;\leftarrow \dv{u_i}{t} - Q_i, \\[6pt]
\dv{u_j}{t} &amp;\leftarrow \dv{u_j}{t} - Q_j, \\[6pt]
\end{aligned}
\end{equation}\]</p><p>where </p><p class="math-container">\[\begin{equation}\label{eq:bndedgecontrbiflux}
\begin{aligned}
Q_i &amp;= \left[\vb q\left(\vb m_i, t, \alpha_{ij} m_{ix} + \beta_{ij} m_{iy} + \gamma_{ij}\right) \vdot \vu n_{ij}\right]L_i, \\
Q_j &amp;= \left[\vb q\left(\vb m_j, t, \alpha_{ij} m_{jx} + \beta_{ij} m_{jy} + \gamma_{ij}\right) \vdot \vu n_{ij}\right]L_j,
\end{aligned}
\end{equation}\]</p><p>where <span>$\vb m_i = (\vb x_i + \vb x_{ij})/2 = (m_{ix}, m_{iy})^{\mkern-1.5mu\mathsf{T}}$</span>, <span>$\vb m_j = (\vb x_{ij} + \vb x_j)/2 = (m_{jx}, m_{jy})^{\mkern-1.5mu\mathsf{T}}$</span>, <span>$\vb n_{ij}$</span> is the outward unit normal vector to <span>$e_{ij}$</span>, <span>$L_i = \|\vb x_{ij} - \vb x_i\|$</span>, <span>$L_j = \|\vb x_j - \vb x_{ij}\|$</span>, and <span>$\alpha_{ij}, \beta_{ij}, \gamma_{ij}$</span> are computed from \eqref{eq:shapecoeffvals} using the vertices of the triangle that contains <span>$e_{ij}$</span>. If there is a Neumann boundary condition on <span>$e_{ij}$</span>, \eqref{eq:bndedgecontrbiflux} uses the boundary condition functions for computing the <span>$\vb q \vdot \vu n$</span> terms.</p><p>Now that we have looped over all triangles and also over all boundary edges, the final values for each <span>$\mathrm du_i/\mathrm dt$</span> is given by </p><p class="math-container">\[\dv{u_i}{t} \leftarrow \frac{1}{V_i}\dv{u_i}{t} + S(\vb x_i, t, u_i).\]</p><p>Of course, if there is a Dirichlet boundary condition at <span>$u_i$</span> we set <span>$\mathrm du_i/\mathrm dt = 0$</span>, and if there is a boundary condition on <span>$\mathrm du_i/\mathrm dt$</span> we use that boundary condition instead.</p><h1 id="Systems-of-Equations"><a class="docs-heading-anchor" href="#Systems-of-Equations">Systems of Equations</a><a id="Systems-of-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Systems-of-Equations" title="Permalink"></a></h1><p>We also provide support for systems of PDEs that take the form</p><p class="math-container">\[\begin{equation}\label{eq:system}
\begin{aligned}
\pdv{u_1(\vb x, t)}{t} + \div \vb q_1(\vb x, t, u_1, \ldots, u_n) &amp;= S_1(\vb x, t, u_1, \ldots, u_n), \\
\pdv{u_2(\vb x, t)}{t} + \div \vb q_2(\vb x, t, u_1, \ldots, u_n) &amp;= S_2(\vb x, t, u_1, \ldots, u_n), \\
&amp;\vdots \\
\pdv{u_n(\vb x, t)}{t} + \div \vb q_n(\vb x, t, u_1, \ldots, u_n) &amp;= S_n(\vb x, t, u_1, \ldots, u_n),
\end{aligned}
\end{equation}\]</p><p>where any of the divergences and source terms may also depend on the other variables <span>$u_1,\ldots,u_n$</span>. We can write this as,</p><p class="math-container">\[\begin{equation}\label{eq:systemsim}
\pdv{\vb u(\vb x, t)}{t} + \div \vb Q(\vb x, t, \vb u) = \vb S(\vb x, t, \vb u),
\end{equation}\]</p><p>where</p><p class="math-container">\[\begin{equation}\label{eq:sysdef}
\begin{aligned}
\vb u(\vb x, t) &amp;= \begin{bmatrix} u_1(\vb x, t) \\ u_2(\vb x, t) \\ \vdots \\ u_n(\vb x, t) \end{bmatrix} \in \mathbb R^{n \times 1}, \\\vb Q(\vb x, t, \vb u) &amp;= \begin{bmatrix} \vb q_1(\vb x, t, \vb u) &amp; \vb q_2(\vb x, t, \vb u) &amp; \cdots &amp; \vb q_n(\vb x, t, \vb u) \end{bmatrix} \in \mathbb R^{2 \times n}, \\\vb S(\vb x, t, \vb u) &amp;= \begin{bmatrix} S_1(\vb x, t, \vb u) \\ S_2(\vb x, t, \vb u) \\ \vdots \\ S_n(\vb x, t, \vb u) \end{bmatrix} \in \mathbb R^{n \times 1},
\end{aligned}
\end{equation}\]</p><p>and the divergence <span>$\div \vb Q$</span> is defined as</p><p class="math-container">\[\begin{equation}\label{eq:divdef}
\div \vb Q(\vb x, t, \vb u) = \begin{bmatrix} \div \vb q_1(\vb x, t, \vb u) \\ \div \vb q_2(\vb x, t, \vb u) \\ \vdots \\ \div\vb q_n(\vb x, t, \vb u) \end{bmatrix} \in \mathbb R^{n \times 1}.
\end{equation}\]</p><p>The method we use for solving these equations is basically the same as what we do for a single PDE. Letting <span>$\vb u_i = \vb u(\vb x_i, t)$</span> and <span>$\vb S_i = \vb S(\vb x_i, t)$</span>, the analogous approximation to \eqref{eq:interiorapproximation} is</p><p class="math-container">\[\begin{equation}\label{eq:sysapproxint}
\dv{u_i}{t} + \frac{1}{V_i}\sum_{\sigma\in\mathcal E_i} \left[\vb Q\left(\vb x_\sigma, t, t, \boldsymbol\alpha_{k(\sigma)}x_\sigma + \boldsymbol\beta_{k(\sigma)}y_\sigma + \boldsymbol\gamma_k\right)^{\mkern-1.5mu\mathsf{T}}\vu{n}_\sigma\right]L_\sigma = \vb S_i,
\end{equation}\]</p><p>where <span>$\boldsymbol\alpha_{k(\sigma)}$</span>, <span>$\boldsymbol\beta_{k(\sigma)}$</span>, and <span>$\boldsymbol\gamma_k$</span> are the vectors of coefficients from \eqref{eq:shapecoeffvals}, e.g.</p><p class="math-container">\[\boldsymbol\alpha_{k(\sigma)} = s_{k(\sigma),11}\vb u_{k1} + s_{k(\sigma),12}\vb u_{k2} + s_{k(\sigma),13}\vb u_{k3}.\]</p><p>where <span>$\vb u_{ki} = \vb u(\vb x_{ki}, t)$</span> and <span>$s_{k(\sigma),ij}$</span> are the elements of <span>$\vb S_{k(\sigma)}$</span>. The only difference between \eqref{eq:sysapproxint} and \eqref{eq:interiorapproximation} is that we now have a vector of PDEs rather than a single PDE. The procedure for computing the contribution from each edge is the same as before, except that we now have to loop over each PDE in the system. In the code, we use a <code>FVMSystem</code> type to represent a system of PDEs, constructed by providing a vector of <code>FVMProblem</code>s. The <code>FVMSystem</code> replaces the initial conditions with a matrix initial condition, where the <code>i</code>th column refers to the <code>i</code>th component of the system.</p><h1 id="Steady-State-Problems"><a class="docs-heading-anchor" href="#Steady-State-Problems">Steady-State Problems</a><a id="Steady-State-Problems-1"></a><a class="docs-heading-anchor-permalink" href="#Steady-State-Problems" title="Permalink"></a></h1><p>We provide support for steady-state problems, in which case \eqref{eq:pde} (and similarly for \eqref{eq:system}) becomes</p><p class="math-container">\[\begin{equation}
\div \vb q(\vb x, t, u) = S(\vb x, t, \vb u).
\end{equation}\]</p><p>This is solved in exactly the same way, except rootfinding is used and there is no timestepping.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>This is a technical limitation due to how the control volumes are defined. For vertices away from the boundary, the control volume edges do not lie along any of the triangle&#39;s edges, which is where we would like to impose Neumann conditions.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../wyos/laplaces_equation/">« Laplace&#39;s Equation</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Tuesday 31 December 2024 19:42">Tuesday 31 December 2024</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
