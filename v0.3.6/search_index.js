var documenterSearchIndex = {"docs":
[{"location":"example_list/#List-of-Examples-and-Setup","page":"List of Examples and Setup","title":"List of Examples and Setup","text":"","category":"section"},{"location":"example_list/","page":"List of Examples and Setup","title":"List of Examples and Setup","text":"We provide six examples in the sidebar. For running these examples, it is assumed that you have installed Gmsh, and have it available. I currently have set","category":"page"},{"location":"example_list/","page":"List of Examples and Setup","title":"List of Examples and Setup","text":"GMSH_PATH = \"./gmsh-4.9.4-Windows64/gmsh.exe\"","category":"page"},{"location":"example_list/","page":"List of Examples and Setup","title":"List of Examples and Setup","text":"The following packages are also loaded:","category":"page"},{"location":"example_list/","page":"List of Examples and Setup","title":"List of Examples and Setup","text":"using FiniteVolumeMethod\nusing DelaunayTriangulation\nusing OrdinaryDiffEq \nusing LinearSolve \nusing CairoMakie \nusing Bessels\nusing Test","category":"page"},{"location":"example_list/","page":"List of Examples and Setup","title":"List of Examples and Setup","text":"More detail is given in the tests. ","category":"page"},{"location":"example_list/","page":"List of Examples and Setup","title":"List of Examples and Setup","text":"We list all the examples below, but solve them in their respective sections of the sidebar.","category":"page"},{"location":"example_list/#Example-I:-Diffusion-equation-on-a-square-plate","page":"List of Examples and Setup","title":"Example I: Diffusion equation on a square plate","text":"","category":"section"},{"location":"example_list/","page":"List of Examples and Setup","title":"List of Examples and Setup","text":"This example concerns the solution of the diffusion equation on a square plate, ","category":"page"},{"location":"example_list/","page":"List of Examples and Setup","title":"List of Examples and Setup","text":"beginequation*\nbeginarrayrcll\ndisplaystyle\nfracpartial u(x y t)partial t = dfrac19boldsymbolnabla^2 u(x y t)  (x y) in Omegat0 \nu(x y t) =  0  (x y) in partial Omegat0 \nu(x y 0) =  f(x y) (xy)inOmega\nendarray\nendequation*","category":"page"},{"location":"example_list/","page":"List of Examples and Setup","title":"List of Examples and Setup","text":"where Omega = 0 2^2 and f(x y) = 50 if y leq 1 and f(x y) = 0 if y1.","category":"page"},{"location":"example_list/#Example-II:-Diffusion-equation-in-a-wedge-with-mixed-boundary-conditions","page":"List of Examples and Setup","title":"Example II: Diffusion equation in a wedge with mixed boundary conditions","text":"","category":"section"},{"location":"example_list/","page":"List of Examples and Setup","title":"List of Examples and Setup","text":"This example considers the following problem defined on a wedge with angle alpha and mixed boundary conditions:","category":"page"},{"location":"example_list/","page":"List of Examples and Setup","title":"List of Examples and Setup","text":"beginequation*\nbeginarrayrcll\ndfracpartial u(r theta t)partial t  =  boldsymbolnabla^2 u(r theta t)  0  r  1 0  theta  alpha t0 \ndfracpartial u(r 0 t)partial theta  =  0  0  r  1 t0 \ndfracpartial u(r alphat)partial theta  =  0  0  theta  alpha t0 \nu(rtheta0)  =  f(r theta)  0  r  1 0 theta  alpha\nendarray\nendequation*","category":"page"},{"location":"example_list/","page":"List of Examples and Setup","title":"List of Examples and Setup","text":"We let f(r theta) = 1-r.","category":"page"},{"location":"example_list/#Example-III:-Reaction-diffusion-equation-with-a-time-dependent-Dirichlet-boundary-condition-on-a-disk","page":"List of Examples and Setup","title":"Example III: Reaction-diffusion equation with a time-dependent Dirichlet boundary condition on a disk","text":"","category":"section"},{"location":"example_list/","page":"List of Examples and Setup","title":"List of Examples and Setup","text":"This example considers the following reaction-diffusion equation on a disk:","category":"page"},{"location":"example_list/","page":"List of Examples and Setup","title":"List of Examples and Setup","text":"beginequation*\nbeginarrayrcll\ndfracpartial u(r theta t)partial t  =  boldsymbolnabla boldsymbolcdot uboldsymbolnabla u + u(1-u)  0  r  1 0  theta  2mathrmpi \ndfracmathrmdu(1 theta t)mathrmdt  =  u(1 theta t)  0  theta  2mathrmpi t  0  \nu(r theta 0)  =  sqrtI_0(sqrt2r)\nendarray\nendequation*","category":"page"},{"location":"example_list/","page":"List of Examples and Setup","title":"List of Examples and Setup","text":"where I_0 is the modified Bessel function of the first kind of order zero.","category":"page"},{"location":"example_list/#Example-IV:-Porous-medium-equation","page":"List of Examples and Setup","title":"Example IV: Porous-medium equation","text":"","category":"section"},{"location":"example_list/","page":"List of Examples and Setup","title":"List of Examples and Setup","text":"In this example, the Porous-Medium equation ","category":"page"},{"location":"example_list/","page":"List of Examples and Setup","title":"List of Examples and Setup","text":"dfracpartial upartial t = Dboldsymbolnabla boldsymbolcdot leftu^m-1 boldsymbolnablauright","category":"page"},{"location":"example_list/","page":"List of Examples and Setup","title":"List of Examples and Setup","text":"is considered, where u(x y 0) = Mdelta(x y), delta(x y) is the Dirac delta function, and M = iint_mathbb R^2 u(x y t)mathrmdA. We then extend this to consider ","category":"page"},{"location":"example_list/","page":"List of Examples and Setup","title":"List of Examples and Setup","text":"dfracpartial upartial t = Dboldsymbolnabla boldsymbolcdot leftu^m-1boldsymbolnabla uright + lambda u quad lambda0 ","category":"page"},{"location":"example_list/#Example-V:-Porous-Fisher-equation-and-travelling-waves","page":"List of Examples and Setup","title":"Example V: Porous-Fisher equation and travelling waves","text":"","category":"section"},{"location":"example_list/","page":"List of Examples and Setup","title":"List of Examples and Setup","text":"In this example, the Porous-Fisher equation on a tall rectangle is considered:","category":"page"},{"location":"example_list/","page":"List of Examples and Setup","title":"List of Examples and Setup","text":"beginequation*\nbeginarrayrcll\ndfracpartial u(x y t)partial t = Dboldsymbolnabla boldsymbolcdot u boldsymbolnabla u + lambda u(1-u)  0  x  a 0  y  b t  0 \nu(x 0 t)  =  1  0  x  a t  0 \nu(x b t)  =  0  0  x  a  t  0 \ndfracpartial u(0 y t)partial x  =  0  0  y  b t  0 \ndfracpartial u(a y t)partial x  =  0  0  y  b t  0 \nu(x y 0)  =  f(y)  0 leq x leq a 0 leq y leq b \nendarray\nendequation*","category":"page"},{"location":"example_list/","page":"List of Examples and Setup","title":"List of Examples and Setup","text":"We treat this problem numerically and consider it to a travelling wave from the analogous one-dimensional problem.","category":"page"},{"location":"example_list/#Example-VI:-Using-the-linear-interpolants","page":"List of Examples and Setup","title":"Example VI: Using the linear interpolants","text":"","category":"section"},{"location":"example_list/","page":"List of Examples and Setup","title":"List of Examples and Setup","text":"The purpose of this example is to demonstrate how to efficiently make use of the linear interpolant defined by the method, and we demonstrate it on the same PDE as in Example V.","category":"page"},{"location":"diffusion_equation_on_a_wedge/#Example-II:-Diffusion-equation-in-a-wedge-with-mixed-boundary-conditions","page":"Example II: Diffusion equation in a wedge with mixed boundary conditions","title":"Example II: Diffusion equation in a wedge with mixed boundary conditions","text":"","category":"section"},{"location":"diffusion_equation_on_a_wedge/","page":"Example II: Diffusion equation in a wedge with mixed boundary conditions","title":"Example II: Diffusion equation in a wedge with mixed boundary conditions","text":"Now we consider the following problem defined on a wedge with angle alpha and mixed boundary conditions:","category":"page"},{"location":"diffusion_equation_on_a_wedge/","page":"Example II: Diffusion equation in a wedge with mixed boundary conditions","title":"Example II: Diffusion equation in a wedge with mixed boundary conditions","text":"beginequation*\nbeginarrayrcll\ndfracpartial u(r theta t)partial t  =  boldsymbolnabla^2 u(r theta t)  0  r  1 0  theta  alpha t0 \ndfracpartial u(r 0 t)partial theta  =  0  0  r  1 t0 \ndfracpartial u(r alphat)partial theta  =  0  0  theta  alpha t0 \nu(rtheta0)  =  f(r theta)  0  r  1 0 theta  alpha\nendarray\nendequation*","category":"page"},{"location":"diffusion_equation_on_a_wedge/","page":"Example II: Diffusion equation in a wedge with mixed boundary conditions","title":"Example II: Diffusion equation in a wedge with mixed boundary conditions","text":"(The exact solution to this problem, found by writing u(r theta t) = mathrme^-lambda tv(r theta) and then using separation of variables, can be shown to take the form","category":"page"},{"location":"diffusion_equation_on_a_wedge/","page":"Example II: Diffusion equation in a wedge with mixed boundary conditions","title":"Example II: Diffusion equation in a wedge with mixed boundary conditions","text":"u(r theta t) = frac12sum_m=1^infty A_0mmathrme^-zeta_0m^2tJ_0left(zeta_0mrright) + sum_n=1^inftysum_m=1^infty A_nmmathrme^-zeta_nm^2tJ_nmathrmpialphaleft(zeta_nmathrmpialpha mrright)cosleft(fracnmathrmpithetaalpharight)","category":"page"},{"location":"diffusion_equation_on_a_wedge/","page":"Example II: Diffusion equation in a wedge with mixed boundary conditions","title":"Example II: Diffusion equation in a wedge with mixed boundary conditions","text":"math","category":"page"},{"location":"diffusion_equation_on_a_wedge/","page":"Example II: Diffusion equation in a wedge with mixed boundary conditions","title":"Example II: Diffusion equation in a wedge with mixed boundary conditions","text":"where, assuming f can be expanded into a Fourier-Bessel series,","category":"page"},{"location":"diffusion_equation_on_a_wedge/","page":"Example II: Diffusion equation in a wedge with mixed boundary conditions","title":"Example II: Diffusion equation in a wedge with mixed boundary conditions","text":"A_n m = frac4alpha J_nmathrmpialpha + 1^2left(zeta_nmathrmpialphamright)int_0^1int_0^alpha f(r theta)J_nmathrmpialphaleft(zeta_nmathrmpialphamrright)cosleft(fracnmathrmpithetaalpharight)rmathrmdrmathrmdtheta quad n=012ldotsm=12ldots","category":"page"},{"location":"diffusion_equation_on_a_wedge/","page":"Example II: Diffusion equation in a wedge with mixed boundary conditions","title":"Example II: Diffusion equation in a wedge with mixed boundary conditions","text":"and we write the roots of J_mu, the zeta_mu m such that J_mu(zeta_mu m) = 0, in the form 0  zeta_mu 1  zeta_mu 2  cdots with zeta_mu m to infty as m to infty. This is the exact solution we compare to in the tests; comparisons not shown here.) We take alpha = mathrmpi4 and f(r theta) = 1 - r. ","category":"page"},{"location":"diffusion_equation_on_a_wedge/","page":"Example II: Diffusion equation in a wedge with mixed boundary conditions","title":"Example II: Diffusion equation in a wedge with mixed boundary conditions","text":"Note that the PDE is provided in polar form, but Cartesian coordinates are assumed for the operators in our code. The conversion is easy, noting that the two Neumann conditions are just equations of the form boldsymbolnabla u boldsymbolcdot hatboldsymboln = 0. Moreover, although the right-hand side of the PDE is given as a Laplacian, recall that boldsymbolnabla^2 = boldsymbolnabla boldsymbolcdot boldsymbolnabla, so we can write partial upartial t + boldsymbolnabla boldsymbolcdot boldsymbolq = 0, where boldsymbolq = -boldsymbolnabla u, or q(x, y, t, α, β, γ, p) = (-α, -β) in the notation in our code.","category":"page"},{"location":"diffusion_equation_on_a_wedge/#Setting-up-the-problem","page":"Example II: Diffusion equation in a wedge with mixed boundary conditions","title":"Setting up the problem","text":"","category":"section"},{"location":"diffusion_equation_on_a_wedge/","page":"Example II: Diffusion equation in a wedge with mixed boundary conditions","title":"Example II: Diffusion equation in a wedge with mixed boundary conditions","text":"Let us now solve the problem. Again, we start by defining the mesh. Since the boundary condition is different on each segment, we keep each segment as a different vector.","category":"page"},{"location":"diffusion_equation_on_a_wedge/","page":"Example II: Diffusion equation in a wedge with mixed boundary conditions","title":"Example II: Diffusion equation in a wedge with mixed boundary conditions","text":"using DelaunayTriangulation, FiniteVolumeMethod\n\nn = 500\nα = π / 4\n\n# The bottom edge \nr₁ = LinRange(0, 1, n)\nθ₁ = LinRange(0, 0, n)\nx₁ = @. r₁ * cos(θ₁)\ny₁ = @. r₁ * sin(θ₁)\n\n# Arc \nr₂ = LinRange(1, 1, n)\nθ₂ = LinRange(0, α, n)\nx₂ = @. r₂ * cos(θ₂)\ny₂ = @. r₂ * sin(θ₂)\n\n# Upper edge \nr₃ = LinRange(1, 0, n)\nθ₃ = LinRange(α, α, n)\nx₃ = @. r₃ * cos(θ₃)\ny₃ = @. r₃ * sin(θ₃)\n\n# Combine and create the mesh \nx = [x₁, x₂, x₃]\ny = [y₁, y₂, y₃]\nr = 0.01\n(T, adj, adj2v, DG, points), BN = generate_mesh(x, y, r; gmsh_path=GMSH_PATH)\nmesh = FVMGeometry(T, adj, adj2v, DG, points, BN)\n# You could also do:\n# tri, BN = generate_mesh(x, y, r; gmsh_path=GMSH_PATH)\n# mesh = FVMGeometry(tri, BN) # for DelaunayTriangulation >= v0.3)","category":"page"},{"location":"diffusion_equation_on_a_wedge/","page":"Example II: Diffusion equation in a wedge with mixed boundary conditions","title":"Example II: Diffusion equation in a wedge with mixed boundary conditions","text":"Now we define the boundary conditions.","category":"page"},{"location":"diffusion_equation_on_a_wedge/","page":"Example II: Diffusion equation in a wedge with mixed boundary conditions","title":"Example II: Diffusion equation in a wedge with mixed boundary conditions","text":"lower_bc = ((x, y, t, u::T, p) where {T}) -> zero(T)\narc_bc = ((x, y, t, u::T, p) where {T}) -> zero(T)\nupper_bc = ((x, y, t, u::T, p) where {T}) -> zero(T)\ntypes = (:N, :D, :N)\nboundary_functions = (lower_bc, arc_bc, upper_bc)\nBCs = BoundaryConditions(mesh, boundary_functions, types, BN)","category":"page"},{"location":"diffusion_equation_on_a_wedge/","page":"Example II: Diffusion equation in a wedge with mixed boundary conditions","title":"Example II: Diffusion equation in a wedge with mixed boundary conditions","text":"Next, the PDE itself:","category":"page"},{"location":"diffusion_equation_on_a_wedge/","page":"Example II: Diffusion equation in a wedge with mixed boundary conditions","title":"Example II: Diffusion equation in a wedge with mixed boundary conditions","text":"f = (x, y) -> 1 - sqrt(x^2 + y^2)\nD = ((x, y, t, u::T, p) where {T}) -> one(T)\nu₀ = f.(points[1, :], points[2, :])\nfinal_time = 0.1 # Do not need iip_flux = true or R(x, y, t, u, p) = 0, these are defaults \nprob = FVMProblem(mesh, BCs; diffusion_function=D, initial_condition=u₀, final_time)","category":"page"},{"location":"diffusion_equation_on_a_wedge/","page":"Example II: Diffusion equation in a wedge with mixed boundary conditions","title":"Example II: Diffusion equation in a wedge with mixed boundary conditions","text":"This formulation uses the diffusion function rather than the flux function, but you could also use the flux function formulation:","category":"page"},{"location":"diffusion_equation_on_a_wedge/","page":"Example II: Diffusion equation in a wedge with mixed boundary conditions","title":"Example II: Diffusion equation in a wedge with mixed boundary conditions","text":"flux = (q, x, y, t, α, β, γ, p) -> (q[1] = -α; q[2] = -β; nothing)\nprob2 = FVMProblem(mesh, BCs; diffusion_function=D, initial_condition=u₀, final_time)","category":"page"},{"location":"diffusion_equation_on_a_wedge/#Solving-the-problem-and-visualising-the-solution","page":"Example II: Diffusion equation in a wedge with mixed boundary conditions","title":"Solving the problem and visualising the solution","text":"","category":"section"},{"location":"diffusion_equation_on_a_wedge/","page":"Example II: Diffusion equation in a wedge with mixed boundary conditions","title":"Example II: Diffusion equation in a wedge with mixed boundary conditions","text":"Finally, we can solve and visualise the problem. ","category":"page"},{"location":"diffusion_equation_on_a_wedge/","page":"Example II: Diffusion equation in a wedge with mixed boundary conditions","title":"Example II: Diffusion equation in a wedge with mixed boundary conditions","text":"using OrdinaryDiffEq, LinearSolve\n\nalg = Rosenbrock23(linsolve=UMFPACKFactorization())\nsol = solve(prob, alg; saveat=0.025)","category":"page"},{"location":"diffusion_equation_on_a_wedge/","page":"Example II: Diffusion equation in a wedge with mixed boundary conditions","title":"Example II: Diffusion equation in a wedge with mixed boundary conditions","text":"using CairoMakie \n\npt_mat = Matrix(points')\nT_mat = [collect(T)[i][j] for i in 1:length(T), j in 1:3]\nfig = Figure(resolution=(2131.8438f0, 684.27f0), fontsize=38)\nax = Axis(fig[1, 1], width=600, height=600)\nmesh!(ax, pt_mat, T_mat, color=sol.u[1], colorrange=(0, 0.5), colormap=:matter)\nax = Axis(fig[1, 2], width=600, height=600)\nmesh!(ax, pt_mat, T_mat, color=sol.u[3], colorrange=(0, 0.5), colormap=:matter)\nax = Axis(fig[1, 3], width=600, height=600)\nmesh!(ax, pt_mat, T_mat, color=sol.u[5], colorrange=(0, 0.5), colormap=:matter)","category":"page"},{"location":"diffusion_equation_on_a_wedge/","page":"Example II: Diffusion equation in a wedge with mixed boundary conditions","title":"Example II: Diffusion equation in a wedge with mixed boundary conditions","text":"(Image: Heat equation on a wedge solution)","category":"page"},{"location":"docstrings/#Docstrings","page":"Docstrings","title":"Docstrings","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"Here we give some of the main docstrings.","category":"page"},{"location":"docstrings/#FVMGeometry","page":"Docstrings","title":"FVMGeometry","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"FVMGeometry\nFiniteVolumeMethod.MeshInformation\nFiniteVolumeMethod.BoundaryInformation\nFiniteVolumeMethod.BoundaryEdgeMatrix \nFiniteVolumeMethod.OutwardNormalBoundary\nFiniteVolumeMethod.InteriorInformation \nFiniteVolumeMethod.construct_interior_edge_boundary_element_identifier\nFiniteVolumeMethod.ElementInformation ","category":"page"},{"location":"docstrings/#FiniteVolumeMethod.FVMGeometry","page":"Docstrings","title":"FiniteVolumeMethod.FVMGeometry","text":"FVMGeometry{EL,P,Adj,Adj2V,NGH,TAR,N,BE,IEBEI,T,CT,VS,SS,CS,FT}\n\nGeometric information about the underlying triangular mesh, as needed for the finite volume method. \n\nFields\n\nmesh_information::MeshInformation\n\nInformation about the underlying triangular mesh; see MeshInformation.\n\nboundary_information::BoundaryInformation\n\nInformation about the boundary of the underlying triangular mesh; see BoundaryInformation.\n\ninterior_information::InteriorInformation\n\nInformation about the interior of the underlying triangular mesh; see InteriorInformation.\n\nelement_information_list::Dict{T, ElementInformation}\n\nList that maps each element to the information about that mesh; see ElementInformation.\n\nvolumes::Dict{Int64,FT}\n\nMaps node indices to the volume of its corresponding control volume.\n\nConstructors\n\nFVMGeometry(T::Ts, adj, adj2v, DG, pts, BNV;\n    coordinate_type=Vector{number_type(pts)},\n    control_volume_storage_type_vector=NTuple{3,coordinate_type},\n    control_volume_storage_type_scalar=NTuple{3,number_type(pts)},\n    shape_function_coefficient_storage_type=NTuple{9,number_type(pts)},\n    interior_edge_storage_type=NTuple{2,Int64},\n    interior_edge_pair_storage_type=NTuple{2,interior_edge_storage_type}) where {Ts}\nFVMGeometry(tri::Triangulation, BNV;\n    coordinate_type=Vector{number_type(DelaunayTriangulation.get_points(tri))},\n    control_volume_storage_type_vector=NTuple{3,coordinate_type},\n    control_volume_storage_type_scalar=NTuple{3,number_type(DelaunayTriangulation.get_points(tri))},\n    shape_function_coefficient_storage_type=NTuple{9,number_type(DelaunayTriangulation.get_points(tri))},\n    interior_edge_storage_type=NTuple{2,Int64},\n    interior_edge_pair_storage_type=NTuple{2,interior_edge_storage_type})\n\nConstructor for FVMGeometry.\n\nArguments\n\nFor the first constructor:\n\nT::Ts: The list of triangles. \nadj: The adjacent map; see DelaunayTriangulation.Adjacent.\nadj2v: The adjacent-to-vertex map; see DelaunayTriangulation.Adjacent2Vertex.\nDG: The graph for the mesh connectivity; see DelaunayTriangulation.DelaunayGraph.\npts: The points for the mesh. \nBNV: The boundary node vector. This should be a vector of vectors, where each nested vector is a list of indices that define the nodes for the corresponding segment, and first(BNV[i]) == last(BNV[i-1]). The nodes must be listed in counter-clockwise order.\n\nFor the second constructor:\n\ntri::Triangulation: A triangulation of the domain; see DelaunayTriangulation.Triangulation.\nBNV: As above. \n\nKeyword Arguments\n\ncoordinate_type=Vector{number_type(pts)}: How coordinates are represented.\ncontrol_volume_storage_type_vector=NTuple{3,coordinate_type}: How information for triples of coordinates is represented. The element type must be coordinate_type.\ncontrol_volume_storage_type_scalar=NTuple{3,number_type(pts)}: How information triples of scalars is represented. The element type must be the same as the element type used for pts.\nshape_function_coefficient_storage_type=NTuple{9,number_type(pts)}: How the nine shape function coefficients for each element are stored. The element type must be the same as the element type used for pts.\ninterior_edge_storage_type=NTuple{2,Int64}: How the tuples (v, j), as defined for the interior edge identifier in InteriorInformation, are stored.\ninterior_edge_pair_storage_type=NTuple{2,interior_edge_storage_type}: How the list of tuples for the interior edge tuples, as defined for the interior edge identifier in InteriorInformation, are stored. The element type must be interior_edge_pair_storage_type.\n\nOutputs\n\nThe returned value is the FVMGeometry object storing information about the underlying triangular mesh.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FiniteVolumeMethod.MeshInformation","page":"Docstrings","title":"FiniteVolumeMethod.MeshInformation","text":"MeshInformation{EL,P,Adj,Adj2V,NGH,TAR}\n\nInformation about the underlying triangular mesh. \n\nFields\n\nelements::EL\n\nAll elements of the mesh. \n\npoints::P\n\nThe coordinates for the nodes of the mesh. \n\nadjacent::Adj\n\nThe adjacent map for the triangulation. \n\nadjacent2vertex::Adj2V\n\nThe adjacent-to-vertex map for the triangulation. \n\nneighbours::NGH\n\nThe neighbour map for the triangulation, mapping mesh nodes to all other nodes that share an edge with it. \n\ntotal_area::TAR\n\nThe total area of the mesh.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FiniteVolumeMethod.BoundaryInformation","page":"Docstrings","title":"FiniteVolumeMethod.BoundaryInformation","text":"BoundaryInformation{N,BE}\n\nInformation for the boundary of the domain.\n\nFields\n\nedge_information::BoundaryEdgeMatrix: The BoundaryEdgeMatrix.\nnormal_information::OutwardNormalBoundary{N}: The OutwardNormalBoundary.\nboundary_nodes::Vector{Int64}: The indices for the nodes on the boundary, given in a counter-clockwise order.\nboundary_elements::BE: The elements of the underlying triangular mesh that share at least one edge with the boundary.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FiniteVolumeMethod.BoundaryEdgeMatrix","page":"Docstrings","title":"FiniteVolumeMethod.BoundaryEdgeMatrix","text":"BoundaryEdgeMatrix\n\nInformation for the boundary edges. Boundaries are to be interpreted as being counter-clockwise,  so that an edge has a left and a right node.\n\nFields\n\nleft_nodes::Vector{Int64}: The left nodes for each edge, given as indices for the points.\nright_nodes::Vector{Int64}: The right nodes for each edge, given as indices for the points. \nadjacent_nodes::Vector{Int64}: The adjacent node to each edge, i.e. the node such that (left_nodes[i], right_nodes[i], adjacent_nodes[i]) is a positively oriented triangle in the underlying triangular mesh.\ntypes::Vector{Int64}: The boundaries are split into segments, so types[i] says what segment number the ith edge is on.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FiniteVolumeMethod.OutwardNormalBoundary","page":"Docstrings","title":"FiniteVolumeMethod.OutwardNormalBoundary","text":"OutwardNormalBoundary{N}\n\nInformation for the unit outward normal vector field on the boundary. \n\nFields\n\nx_normals::N: The x-coordinates for the tail of each normal vector, with x_normals[i] the coordinate for the ith edge.\ny_normals::N: The y-coordinates for the tail of each normal vector, with x_normals[i] the coordinate for the ith edge. \ntypes::Vector{Int64}: As in BoundaryEdgeMatrix, types[i] says what segment number the ith edge is on.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FiniteVolumeMethod.InteriorInformation","page":"Docstrings","title":"FiniteVolumeMethod.InteriorInformation","text":"InteriorInformation{EL,IEBEI}\n\nInformation for the interior of the domain. \n\nFields\n\nnodes::Vector{Int64}\n\nIndices for the all the nodes that are in the interior of the domain. \n\nelements::EL\n\nThe elements of the underlying triangular mesh that share no edges with the boundary. \n\ninterior_edge_boundary_element_identifier::IEBEI\n\nGiven a boundary element V (see BoundaryInformation), this maps V to a list of tuples of the form ((v₁, j₁), (v₂, j₂)), where (v₁, v₂) is an edge such that v₁ is a boundary node and v₂ is an interior node, and j₁ and j₂ give the positions of v₁ and v₂, respectively, in V, e.g. V[j₁] == v₁. See also construct_interior_edge_boundary_element_identifier.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FiniteVolumeMethod.construct_interior_edge_boundary_element_identifier","page":"Docstrings","title":"FiniteVolumeMethod.construct_interior_edge_boundary_element_identifier","text":"construct_interior_edge_boundary_element_identifier(boundary_elements, interior_nodes, DT)\n\nCreates a Dict that maps a set of nodal indices v for some boundary element to the the  interior edges, represented as ((v₁, j₁), (v₂, j₂)) (a vector of), with v[j₁] = v₁ → v[j₂] = v₂ an edge of the element that  is in the interior.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#FiniteVolumeMethod.ElementInformation","page":"Docstrings","title":"FiniteVolumeMethod.ElementInformation","text":"ElementInformation{CoordinateType,VectorStorage,ScalarStorage,CoefficientStorage,FloatType}\n\nInformation for an individual element.\n\nFields\n\ncentroid::CoordinateType\n\nThe centroid of the element. \n\nmidpoints::VectorStorage\n\nThe coordinates for the midpoints of each edge. \n\ncontrol_volume_edge_midpoints::VectorStorage\n\nFor each edge, this is the midpoint of the line that connects the edge to the centroid. \n\nlengths::ScalarStorage\n\nThe lengths for each edge. \n\nshape_function_coefficients::CoefficientStorage\n\nThese are the sᵢⱼ coefficients for the element; see their definition in the README.\n\nnormals::VectorStorage\n\nThe outward unit normals to each edge.\n\narea::FloatType\n\nThe area of the element.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#BoundaryConditions","page":"Docstrings","title":"BoundaryConditions","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"BoundaryConditions \nFiniteVolumeMethod.is_dirichlet_type \nFiniteVolumeMethod.is_neumann_type\nFiniteVolumeMethod.is_dudt_type","category":"page"},{"location":"docstrings/#FiniteVolumeMethod.BoundaryConditions","page":"Docstrings","title":"FiniteVolumeMethod.BoundaryConditions","text":"BoundaryConditions{BNV,F,P,DN,NN,DuN,INN,BMI,MBI,TM}\n\nInformation representing the boundary conditions for the PDE. \n\nFields\n\nboundary_node_vector::BNV\n\nThe vector of vectors such that each nested vector is the list of nodes for each segment, given in counter-clockwise order, and such that first(BNV[i]) == last(BNV[i-1]).\n\nfunctions::F\n\nThe Tuple of boundary condition functions for each boundary segment, with functions[i] corresponding to the ith segment. These functions must take the form f(x, y, t, u, p).\n\nparameters::P\n\nThe Tuple of arguments p for each boundary condition function, with parameters[i] corresponding to functions[i].\n\ndirichlet_nodes::DN\n\nThe indices of the nodes on the boundary that are of Dirichlet type. \n\nneumann_nodes::NN\n\nThe indices of the nodes on the boundary that are of Neumann type. \n\ndudt_nodes::DuN\n\nThe indices of the nodes on the boundary that are of time-dependent Dirichlet type, i.e. of the form du/dt = f(x, y, t, u, p).\n\ninterior_or_neumann_nodes::INN`\n\nThe nodes that are either interior or neumann nodes. \n\nboundary_to_mesh_idx::BMI\n\nIf the boundary nodes are in the order (b₁, b₂, …, bᵢ, …), then this is a map that takes the index order i to the corresponding index in the mesh, i.e. to bᵢ.\n\nmesh_to_boundary_idx::MBI\n\nThe inverse map of boundary_to_mesh_idx.\n\ntype_map::TM\n\nGiven a node, maps it to the segment number that it belongs to.\n\nConstructors\n\nBoundaryConditions(mesh::FVMGeometry, functions, types, boundary_node_vector;\n    params=Tuple(nothing for _ in (functions isa Function ? [1] : eachindex(functions))),\n    u_type=Float64, float_type=Float64)\n\nConstructor for the BoundaryConditions struct. \n\nArguments\n\nmesh::FVMGeometry: The FVMGeometry for the mesh. \nfunctions: The functions for each boundary segment, taking the forms f(x, y, t, u, p). Can be a single function, doesn't have to be in a container (as long as only one segment is needed).\ntypes: The classification for the boundary condition type on each segment. See is_dirichlet_type, is_neumann_type, and is_dudt_type for the possible values here. types[i] is the classification for the ith segment. \nboundary_node_vector: The boundary node vector for the struct: The vector of vectors such that each nested vector is the list of nodes for each segment, given in counter-clockwise order, and such that first(boundary_node_vector[i]) == last(boundary_node_vector[i-1]).\n\nKeyword Arguments\n\nparams=Tuple(nothing for _ in (functions isa Function ? [1] : eachindex(functions))): The parameters for the functions, with params[i] giving the argument p in functions[i].\nu_type=Float64: The number type used for the solution. \nfloat_type=Float64: The number type used for representing the coordinates of points. \n\nOutputs\n\nThe returned value is the corresponding BoundaryConditions struct. \n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FiniteVolumeMethod.is_dirichlet_type","page":"Docstrings","title":"FiniteVolumeMethod.is_dirichlet_type","text":"is_dirichlet_type(type)\n\nReturns type ∈ (:Dirichlet, :D, :dirichlet, \"Dirichlet\", \"D\", \"dirichlet\").\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#FiniteVolumeMethod.is_neumann_type","page":"Docstrings","title":"FiniteVolumeMethod.is_neumann_type","text":"is_neumann_type(type)\n\nReturns type ∈ (:Neumann, :N, :neumann, \"Neumann\", \"N\", \"neumann\").\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#FiniteVolumeMethod.is_dudt_type","page":"Docstrings","title":"FiniteVolumeMethod.is_dudt_type","text":"is_dudt_type(type)\n\nReturns type ∈ (:Dudt, :dudt, \"Dudt\", \"dudt\", \"du/dt\").\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#FVMProblem","page":"Docstrings","title":"FVMProblem","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"FVMProblem \nFiniteVolumeMethod.construct_flux_function \nFiniteVolumeMethod.construct_reaction_function ","category":"page"},{"location":"docstrings/#FiniteVolumeMethod.FVMProblem","page":"Docstrings","title":"FiniteVolumeMethod.FVMProblem","text":"FVMProblem{iip_flux,FG,BC,F,FP,R,RP,IC,FT}\n\nStruct representing the PDE problem. \n\nFields\n\nmesh::FG\n\nThe underlying mesh, given as a FVMGeometry struct. \n\nboundary_conditions::BC\n\nThe boundary conditions, given a a BoundaryConditions struct. \n\nflux_function::F\n\nThe function for the flux vector, taking either of the forms flux!(q, x, y, t, α, β, γ, p) (if iip_flux) and flux(x, y, t, α, β, γ, p) (if !iip_flux), where u = αx + βy + γ.\n\nflux_parameters::FP\n\nThe argument p in flux_function.\n\nreaction_function::R\n\nThe function for the reaction term, taking the form R(x, y, t, u, p).\n\nreaction_parameters::RP\n\nThe argument p in reaction_function.\n\ninitial_condition::IC\n\nThe initial condition for the problem, with initial_condition[i] the initial value at the ith node of the mesh. \n\ninitial_time::FT\n\nThe time to start solving the PDE at. \n\nfinal_time::FT\n\nThe time to stop solving the PDE at. \n\nsteady::Bool\n\nWhether ∂u/∂t = 0 or not. Not currently used; only non-steady problems are currently supported (see https://github.com/DanielVandH/FiniteVolumeMethod.jl/issues/16).\n\nConstructor\n\nFVMProblem(mesh, boundary_conditions;\n    iip_flux=true,\n    diffusion_function=nothing,\n    diffusion_parameters=nothing,\n    reaction_function=nothing,\n    reaction_parameters=nothing,\n    delay_function=nothing,\n    delay_parameters=nothing,\n    flux_function=nothing,\n    flux_parameters=nothing,\n    initial_condition,\n    initial_time=0.0,\n    final_time,\n    steady=false,\n    q_storage=SVector{2,Float64})\n\nConstructor for the FVMProblem.\n\nArguments\n\nmesh: The FVMGeometry representing the underlying mesh. \nboundary_conditions: The BoundaryConditions representing the boundary conditions for the problem. \n\nKeyword Arguments\n\niip_flux=true: Whether the flux vector is computed in-place or not.\ndiffusion_function=nothing: If flux_function===nothing, this can be used to provide a diffusion term for the reaction-diffusion formulation, taking the form D(x, y, t, u, p). See also construct_flux_function.\ndiffusion_parameters=nothing: The argument p in the diffusion function. \nreaction_function=nothing: The reaction term, taking the form R(x, y, t, u, p). If not provided, it is set to the zero function. See also construct_reaction_function.\nreaction_parameters=nothing: The argument p in the reaction function. \ndelay_function=nothing: The delay function T(x, y, t, u, p) for the PDE that can be used to scale the diffusion and reaction functions, assuming flux_function===nothing. See also construct_reaction_function and construct_flux_function.\ndelay_parameters=nothing: The argument p in the delay function. \nflux_function=nothing: The flux function, taking either of the forms flux!(q, x, y, t, α, β, γ, p) (if iip_flux) and flux(x, y, t, α, β, γ, p) (if !iip_flux), where u = αx + βy + γ. If flux_function===nothing, thne this function is constructed from the diffusion and delay functions. \nflux_parameters=nothing: The argument p in the flux function. \ninitial_condition: The initial condition for the problem, with initial_condition[i] the initial value at the ith node of the mesh. \ninitial_time=0.0: The time to start solving the PDE at. \nfinal_time: The time to stop solving the PDE at. \nsteady::Bool: Whether ∂u/∂t = 0 or not. Not currently used; only non-steady problems are currently supported.\n\nOutputs\n\nReturns the FVMProblem object.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FiniteVolumeMethod.construct_flux_function","page":"Docstrings","title":"FiniteVolumeMethod.construct_flux_function","text":"construct_flux_function(iip_flux,\n    flux_function,\n    delay_function, delay_parameters,\n    diffusion_function, diffusion_parameters)\n\nConstructs the flux function. The arguments are as in FVMProblem, and the output depends on the following, where D denotes the diffusion function, T the delay function, dₚ the diffusion parameters, and tₚ the delay parameters: \n\nIf flux_function===nothing and delay_function===nothing, defines the flux function as (x, y, t, α, β, γ, _) -> -D(x, y, t, αx + βy + γ, dₚ)[α, β].\nIf flux_function===nothing, defines the flux function as (x, y, t, α, β, γ, _) -> -T(x, y, t, αx + βy + γ, tₚ)D(x, y, t, αx + βy + γ, dₚ)[α, β].\n\nIf iip_flux, then the functions above have an extra argument in the first position, q, that the flux vectors are stored in. Otherwise, the flux vector is  returned as a tuple (q1, q2). If flux_function !== nothing, then just returns flux_function.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#FiniteVolumeMethod.construct_reaction_function","page":"Docstrings","title":"FiniteVolumeMethod.construct_reaction_function","text":"construct_reaction_function(reaction_function, reaction_parameters,\n    delay_function, delay_parameters)\n\nConstructs the reaction function. The arguments are as in FVMProblem, and the output depends on the following, where R             denotes the reaction function, T the delay function, rₚ the reaction parameters, and tₚ the delay parameters: \n\nIf reaction_function===nothing, defines the reaction function as (x, y, t, u, _) = 0.0.\nIf reaction_function !== nothing and delay_function !== nothing, defines the reaction function as (x, y, t, u, _) -> T(x, y, t, u, tₚ)R(x, y, t, u, rₚ).\nOtherwise, just returns reaction_function.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Solving-the-FVMProblem","page":"Docstrings","title":"Solving the FVMProblem","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"FiniteVolumeMethod.solve \nFiniteVolumeMethod.ODEProblem \nFiniteVolumeMethod.jacobian_sparsity","category":"page"},{"location":"docstrings/#CommonSolve.solve","page":"Docstrings","title":"CommonSolve.solve","text":"SciMLBase.solve(prob::FVMProblem, alg;\n    cache_eltype::Type{F}=eltype(get_initial_condition(prob)),\n    jac_prototype=float.(jacobian_sparsity(prob)),\n    parallel=false,\n    specialization::Type{S}=SciMLBase.AutoSpecialize,\n    chunk_size=PreallocationTools.ForwardDiff.pickchunksize(length(get_initial_condition(prob))),\n    kwargs...)\n\nSolves the FVMProblem given by prob using the algorithm alg.\n\nArguments\n\nprob::FVMProblem: The FVMProblem.\nalg: The algorithm to use for solving. See the DifferentialEquations.jl documentation for this.\n\nKeyword Arguments\n\ncache_eltype::Type{F}=eltype(get_initial_condition(prob)): The element type used for the cache vectors. \njac_prototype=float.(jacobian_sparsity(prob)): The prototype for the sparsity pattern of the Jacobian. \nparallel=false: Whether to use multithreading for evaluating the equations. Not currently used.\nspecialization::Type{S}=SciMLBase.AutoSpecialize: The specialisation level for the ODEProblem.\nchunk_size=PreallocationTools.ForwardDiff.pickchunksize(length(get_initial_condition(prob)))): The chunk size for the dual numbers used in the cache vector.\nkwargs...: Extra keyword arguments for solve as used on ODEProblems.\n\nOutput\n\nThe output is a solution struct, as returned from DifferentialEquations.jl.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#SciMLBase.ODEProblem","page":"Docstrings","title":"SciMLBase.ODEProblem","text":"SciMLBase.ODEProblem(prob::FVMProblem;\n    cache_eltype::Type{F}=eltype(get_initial_condition(prob)),\n    jac_prototype=float.(jacobian_sparsity(prob)),\n    parallel=false,\n    no_saveat=true,\n    specialization::Type{S}=SciMLBase.AutoSpecialize,\n    chunk_size=PreallocationTools.ForwardDiff.pickchunksize(length(get_initial_condition(prob)))) where {S,F}\n\nConstructs the ODEProblem for the system of ODEs defined by the finite volume equations corresponding to prob.\n\nArguments\n\nprob::FVMProblem: The FVMProblem.\n\nKeyword Arguments\n\ncache_eltype::Type{F}=eltype(get_initial_condition(prob)): The element type used for the cache vectors. \njac_prototype=float.(jacobian_sparsity(prob)): The prototype for the sparsity pattern of the Jacobian. \nparallel=false: Whether to use multithreading for evaluating the equations.\nno_saveat=true: Whether the solution is saving at specific points. \nspecialization::Type{S}=SciMLBase.AutoSpecialize: The specialisation level for the ODEProblem.\nchunk_size=PreallocationTools.ForwardDiff.pickchunksize(length(get_initial_condition(prob)))): The chunk size for the dual numbers used in the cache vector.\n\nOutputs\n\nReturns the corresponding ODEProblem.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FiniteVolumeMethod.jacobian_sparsity","page":"Docstrings","title":"FiniteVolumeMethod.jacobian_sparsity","text":"jacobian_sparsity(prob::FVMProblem)\n\nConstructs the sparse matrix which has the same sparsity pattern as the Jacobian for the finite volume equations  corresponding to the FVMProblem given by prob.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Linear-Interpolants","page":"Docstrings","title":"Linear Interpolants","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"eval_interpolant ","category":"page"},{"location":"docstrings/#FiniteVolumeMethod.eval_interpolant","page":"Docstrings","title":"FiniteVolumeMethod.eval_interpolant","text":"eval_interpolant!(αβγ, prob::FVMProblem, x, y, T, u)\neval_interpolant(sol, x, y, t_idx::Integer, T)\neval_interpolant(sol, x, y, t::Number, T)\n\nEvaluates the interpolant corresponding to the FVMProblem at the point (x, y) and time t (or sol.t[t_idx]). \n\n\n\n\n\n","category":"function"},{"location":"interface/#Interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"The definition of a PDE requires definitions for (1) the triangular mesh, (2) the boundary conditions, and (3) the PDE itself. We describe here all three of these parts, with demonstrations of them given in the Examples section. Complete docstrings can be found in the sidebar.","category":"page"},{"location":"interface/#FVMGeometry:-Defining-the-mesh","page":"Interface","title":"FVMGeometry: Defining the mesh","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"The struct that defines the underlying geometry is FVMProblem, storing information about the mesh, the boundary, the interior, and individual information about the elements. The mesh has to be triangular, and can be constructed using my other package DelaunayTriangulation.jl. The main constructor that we provided is:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"FVMGeometry(T::Ts, adj, adj2v, DG, pts, BNV; \n    coordinate_type=Vector{number_type(pts)}, \n    control_volume_storage_type_vector=NTuple{3,coordinate_type}, \n    control_volume_storage_type_scalar=NTuple{3,number_type(pts)}, \n    shape_function_coefficient_storage_type=NTuple{9,number_type(pts)}, \n    interior_edge_storage_type=NTuple{2,Int64}, \n    interior_edge_pair_storage_type=NTuple{2,interior_edge_storage_type}) where {Ts}","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Here, T, adj, adj2v, and DG are structs representing the triangles, adjacent map, adjacent-to-vertex map, and the Delaunay graph, as defined in DelaunayTriangulation.jl. You can also provide a Triangulation type from DelaunayTriangulation.jl in place of (T, adj, adj2v, DG, pts). The argument pts represents the points of the mesh, and lastly BNV is used to define the nodes for the separate boundary segments. For example, suppose we have the following domain with boundary Gamma_1 cup Gamma_2 cup Gamma_3 cup Gamma_4:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"(Image: A segmented boundary)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"The colours are used to distinguish between different segments of the boundaries. The boundary node vector BNV would thus be defined as:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Γ₁ = [2, 11, 12, 13, 14, 15, 16, 3];\nΓ₂ = [3, 17, 18, 19, 20, 21, 22, 4];\nΓ₃ = [4, 23, 24, 25, 26, 27, 28, 1];\nΓ₄ = [1, 5, 6, 7, 8, 9, 10, 2];\nBNV = [Γ₁, Γ₂, Γ₃, Γ₄]","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"It is crucial that these nodes are provided in counter-clockwise order, and that their endpoints connect (i.e. the last node of the previous segment is the same as the first node of the current segment).","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"A good way to generate these meshes, and the BNV, is to use generate_mesh from DelaunayTriangulation.jl (provided you have Gmsh installed). Note also that if you already have an existing set of triangular elements, points, and a known set of boundary nodes, the function triangulate (also from DelaunayTriangulation.jl) may be of interest to you.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"The other keyword arguments in the function are just details about how certain variables are stored. See the docstrings in the sidebar.","category":"page"},{"location":"interface/#BoundaryConditions:-Defining-the-boundary-conditions","page":"Interface","title":"BoundaryConditions: Defining the boundary conditions","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"The next component to define is the set of boundary conditions, represented via the struct BoundaryConditions. The boundary condition functions are all assumed to take the form f(x, y, t, u, p), where p are extra parameters that you provide. We provide the following constructor:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"BoundaryConditions(mesh::FVMGeometry, functions, types, boundary_node_vector;\n    params=Tuple(nothing for _ in (functions isa Function ? [1] : eachindex(functions))),\n    u_type=Float64, float_type=Float64)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Here, functions is a tuple for the functions for the boundary condition on each segment, where functions[i] should correspond to the segment represented by BNV[i]. Then, types is used to declare each segment as being of Dirichlet, time-dependent Dirichlet, or Neumann type, with types[i] corresponding to the segment represented by BNV[i]. This variable is defined according to the rules:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"is_dirichlet_type(type) = type ∈ (:Dirichlet, :D, :dirichlet, \"Dirichlet\", \"D\", \"dirichlet\")\nis_neumann_type(type) = type ∈ (:Neumann, :N, :neumann, \"Neumann\", \"N\", \"neumann\")\nis_dudt_type(type) = type ∈ (:Dudt, :dudt, \"Dudt\", \"dudt\", \"du/dt\")","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"For example, types = (:dudt, :neumann, :D, :D) means that the first segment has a time-dependent Dirichlet boundary condition, the second a homogeneous Neumann boundary condition, and the last two segments have Dirichlet boundary conditions (with possibly different functions). The argument boundary_node_vector is the same as BNV. To provide the parameters p for each function, the keyword argument params is provided, letting params[i] be the set of parameters used when calling functions[i]. The type of the solution u can be declared using u_type, and the numbers representing the coordinates can be declared using float_type. Note that the values for any functions corresponding to a Neumann boundary condition are currently ignored (equivalent to assuming the function is zero).","category":"page"},{"location":"interface/#FVMProblem:-Defining-and-solving-the-problem","page":"Interface","title":"FVMProblem: Defining and solving the problem","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"The final piece to define are the flux and reaction functions, or alternatively the diffusion, delay, and reaction functions. Moreover, the initial condition and time span must be defined. This information is represented using the struct FVMProblem, which has constructor:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"FVMProblem(mesh, boundary_conditions;\n    iip_flux=true,\n    diffusion_function=nothing,\n    diffusion_parameters=nothing,\n    reaction_function=nothing,\n    reaction_parameters=nothing,\n    delay_function=nothing,\n    delay_parameters=nothing,\n    flux_function=nothing,\n    flux_parameters=nothing,\n    initial_condition,\n    initial_time=0.0,\n    final_time,\n    steady=false)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"The arguments mesh and boundary_conditions are the FVMGeometry and BoundaryConditions objects defined above. The flux_function keyword argument must take the form flux!(q, x, y, t, α, β, γ, p) (iip_flux = true) or flux!(x, y, t, α, β, γ, p) (iip_flux = false), where p are some parameters (provided by flux_parameters) and q is a cache vector of size 2 (defined in the solver). If iip_flux = false, then the flux vector should be returned as a tuple (q1, q2). The arguments α, β, and γ in the flux function represent the linear interpolant used, u(x y t) approx alpha x + beta y + gamma, for approximating u over a single element, so that boldsymbolnabla u(x y t) is given by (alpha beta)^mathsf T and any instance of u should be replaced by alpha x + beta y + gamma.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"If flux_function === nothing, then a flux function is constructed using the delay and diffusion functions (delay_function and diffusion_function, respectively), each assumed to take the form f(x, y, t, u, p), with the parameters p given by delay_parameters and diffusion_parameters for the delay and diffusion functions, respectively. If delay_function === nothing, it is assumed that the delay fnuction is the identity. The flux function is constructed using the diffusion function as described at the start of the README. ","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"If reaction_function === nothing, then it is assumed that the reaction function is the zero function. Otherwise, the reaction function is assumed to take the form f(x, y, t, u, p), with the parameters p given by reaction_parameters. If delay_function !== nothing, then this reaction function is re-defined to be delay_function(x, y, t, u, p) * reaction_function(x, y, t, u, p).","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"The initial condition can be provided using the initial_condition keyword argument, and should be a vector of values so that initial_condition[i] is the value of u at t = 0 and (x, y) = get_point(pts, i).","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Finally, the time span that the solution is solved over, (initial_time, final_time), can be defined using the keyword arguments initial_time and final_time. ","category":"page"},{"location":"interface/#Solving-the-FVMProblem","page":"Interface","title":"Solving the FVMProblem","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Once the problem has been completely defined and you now have a prob::FVMProblem, you are ready to solve the problem. We build on the interface provided by DifferentialEquations.jl (see here), using a solve command and any solver from OrdinaryDiffEq.jl. For example, we could define ","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"using OrdinaryDiffEq, LinearSlove \nalg = TRBDF2(linsolve=KLUFactorization(), autodiff=true)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"(The code is compatible with automatic differentiation.) With this algorithm, we can easily solve the problem using ","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"sol = solve(prob, alg)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"The solution will be the same type of result returned from OrdinaryDiffEq.jl, with sol.u[i] the solution at sol.t[i], and get_point(sol.u[i], j) is the solution at (x, y, t) = (get_point(pts, j)..., sol.t[i]).","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"The solve command is defined as follows:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"SciMLBase.solve(prob::FVMProblem, alg;\n    cache_eltype::Type{F}=eltype(get_initial_condition(prob)),\n    jac_prototype=float.(jacobian_sparsity(prob)),\n    parallel=false,\n    specialization::Type{S}=SciMLBase.AutoSpecialize,\n    chunk_size=PreallocationTools.ForwardDiff.pickchunksize(length(get_initial_condition(prob))),\n    kwargs...) where {S,F}","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"This cache_eltype keyword sets the element type for the caches used for the flux vector and for (α, β, γ), which is then used for wrapping a cache vector with PreallocationTools.dualcache for allowing automatic differentiation. ","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"The jac_prototype keyword allows for a prototype of the Jacobian to be provided. This is easy to construct with our function jacobian_sparsity, since the Jacobian's non-zero structure is the same as boldsymbolA + boldsymbolI, where boldsymbolA is the adjacency matrix of the triangulation. ","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"The parallel keyword is supported as of v3.0. Be careful that your flux vector is thread-safe if you compute it in-place. This seems to make the code run around 4x as fast in the benchmarks I've run.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"The specialization keyword can be used to set the specialization level for the ODEProblem. See here for more details.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"The chunk_size argument sets the chunk size used for automatic differentiation when defining the cache vectors. ","category":"page"},{"location":"interface/#Linear-Interpolants","page":"Interface","title":"Linear Interpolants","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"We also provide an interface for evaluating the solutions at any point (x y), or at least evaluating the solution's associated linear interpolant. As described in the Mathematical Details section, the solution u(x y t) is assumed to be linear inside a given triangular element T, i.e. u(x y t) approx alpha(t) x + beta(t) y + gamma(t) for (x y) in T. We provide two methods for evaluating this interpolant for a given (x y) and a given T:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"eval_interpolant(sol, x, y, t_idx::Integer, T) \neval_interpolant(sol, x, y, t::Number, T) \neval_interpolant!(αβγ, prob::FVMProblem, x, y, T, u)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"The first method takes a given solution sol (as defined in the last section), a given coordinate (x, y), an index t_idx such that sol.t[t_idx] is the time of interest, and T is the triangle that (x, y) is inside of. The second method takes in a number for the time, instead computing the solution using sol(t). The third method is the one that the first and second call into, where αβγ is a cache vector to store the coefficients of the interpolant, prob is the FVMProblem, and u is the vector of the solution values (i.e. sol.u[t_idx], or sol(t) for example). It is up to you to provide the triangle T that (x, y) is inside of, but the tools in DelaunayTriangulation.jl can make this efficient. Note that αβγ is stored inside sol, so the first and second methods do not have to create an extra cache vector on each call. ","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"An example of how to efficiently evaluate these interpolants is given in the examples.","category":"page"},{"location":"porous_fisher/#Example-V:-Porous-Fisher-equation-and-travelling-waves","page":"Example V: Porous-Fisher equation and travelling waves","title":"Example V: Porous-Fisher equation and travelling waves","text":"","category":"section"},{"location":"porous_fisher/","page":"Example V: Porous-Fisher equation and travelling waves","title":"Example V: Porous-Fisher equation and travelling waves","text":"Please ensure you have read the List of Examples section before proceeding.","category":"page"},{"location":"porous_fisher/","page":"Example V: Porous-Fisher equation and travelling waves","title":"Example V: Porous-Fisher equation and travelling waves","text":"We now consider a more involved example, where we discuss the travelling wave solutions of the Porous-Fisher equation and discuss how we test a more complicated problem. We consider:","category":"page"},{"location":"porous_fisher/","page":"Example V: Porous-Fisher equation and travelling waves","title":"Example V: Porous-Fisher equation and travelling waves","text":"beginequation*\nbeginarrayrcll\ndfracpartial u(x y t)partial t = Dboldsymbolnabla boldsymbolcdot u boldsymbolnabla u + lambda u(1-u)  0  x  a 0  y  b t  0 \nu(x 0 t)  =  1  0  x  a t  0 \nu(x b t)  =  0  0  x  a  t  0 \ndfracpartial u(0 y t)partial x  =  0  0  y  b t  0 \ndfracpartial u(a y t)partial x  =  0  0  y  b t  0 \nu(x y 0)  =  f(y)  0 leq x leq a 0 leq y leq b \nendarray\nendequation*","category":"page"},{"location":"porous_fisher/","page":"Example V: Porous-Fisher equation and travelling waves","title":"Example V: Porous-Fisher equation and travelling waves","text":"This problem is defined on the rectangle 0 a times 0 b, and we assume that b gg a so that the rectangle is much taller than it is wide. This problem has u ranging from u=1 at the bottom of the rectangle down to u=0 at the top of the rectangle, with no flux conditions on the two vertical walls. The function f(y) is taken to be independent of x. This setup implies that the solution along each constant line x = x_0 should be about the same, i.e. the problem is invariant in x. If indeed we have u(x y t) equiv u(y t), then the PDE becomes","category":"page"},{"location":"porous_fisher/","page":"Example V: Porous-Fisher equation and travelling waves","title":"Example V: Porous-Fisher equation and travelling waves","text":"dfracpartial u(y t)partial t = Ddfracpartialpartial yleft(udfracpartial upartial yright) + lambda u(1-u)","category":"page"},{"location":"porous_fisher/","page":"Example V: Porous-Fisher equation and travelling waves","title":"Example V: Porous-Fisher equation and travelling waves","text":"which has travelling wave solutions. Following the analysis from Section 13.4 of Mathematical biology I: An introduction by J. D. Murray (2002), we can show that a travelling wave solution to the one-dimensional problem above is","category":"page"},{"location":"porous_fisher/","page":"Example V: Porous-Fisher equation and travelling waves","title":"Example V: Porous-Fisher equation and travelling waves","text":"u(y t) = left(1 - mathrme^c_minzright)leftz leq 0right","category":"page"},{"location":"porous_fisher/","page":"Example V: Porous-Fisher equation and travelling waves","title":"Example V: Porous-Fisher equation and travelling waves","text":"where c_min = sqrtlambda(2D), c = sqrtDlambda2, and z = x - ct is the travelling wave coordinate. This travelling wave would match our problem exactly if the rectangle were instead 0 a times mathbb R, but by choosing b large enough we can at least emulate the travelling wave behaviour closely; homogeneous Neumann conditions are to ensure no energy is lost, thus allowing the travelling waves to exist. Note also that the approximations of the solution with u(y t) above will only be accurate for large time.","category":"page"},{"location":"porous_fisher/","page":"Example V: Porous-Fisher equation and travelling waves","title":"Example V: Porous-Fisher equation and travelling waves","text":"Let us now solve the problem. For this problem, rather than using generate_mesh we will use a structured triangulation with triangulate_structured. This will make it easier to test the x invariance.","category":"page"},{"location":"porous_fisher/","page":"Example V: Porous-Fisher equation and travelling waves","title":"Example V: Porous-Fisher equation and travelling waves","text":"using DelaunayTriangulation, FiniteVolumeMethod\n\n## Step 1: Define the mesh \na, b, c, d, Nx, Ny = 0.0, 3.0, 0.0, 40.0, 60, 80\n(T, adj, adj2v, DG, points), BN = triangulate_structured(a, b, c, d, Nx, Ny; return_boundary_types=true)\nmesh = FVMGeometry(T, adj, adj2v, DG, points, BN)\n\n## Step 2: Define the boundary conditions \na₁ = ((x, y, t, u::T, p) where {T}) -> one(T)\na₂ = ((x, y, t, u::T, p) where {T}) -> zero(T)\na₃ = ((x, y, t, u::T, p) where {T}) -> zero(T)\na₄ = ((x, y, t, u::T, p) where {T}) -> zero(T)\nbc_fncs = (a₁, a₂, a₃, a₄)\ntypes = (:D, :N, :D, :N)\nBCs = BoundaryConditions(mesh, bc_fncs, types, BN)\n\n## Step 3: Define the actual PDE  \nf = ((x::T, y::T) where {T}) -> zero(T)\ndiff_fnc = (x, y, t, u, p) -> p * u\nreac_fnc = (x, y, t, u, p) -> p * u * (1 - u)\nD, λ = 0.9, 0.99\ndiff_parameters = D\nreac_parameters = λ\nfinal_time = 50.0\nu₀ = [f(points[:, i]...) for i in axes(points, 2)]\nprob = FVMProblem(mesh, BCs; diffusion_function=diff_fnc, reaction_function=reac_fnc,\n    diffusion_parameters=diff_parameters, reaction_parameters=reac_parameters,\n    initial_condition=u₀, final_time)\n\n## Step 4: Solve\nusing LinearSolve, OrdinaryDiffEq\n\nalg = TRBDF2(linsolve=KLUFactorization())\nsol = solve(prob, alg; saveat=0.5)","category":"page"},{"location":"porous_fisher/","page":"Example V: Porous-Fisher equation and travelling waves","title":"Example V: Porous-Fisher equation and travelling waves","text":"This gives us our solution. To verify the x-invariance, something like the following suffices:","category":"page"},{"location":"porous_fisher/","page":"Example V: Porous-Fisher equation and travelling waves","title":"Example V: Porous-Fisher equation and travelling waves","text":"using Test \n\nu_mat = [reshape(u, (Nx, Ny)) for u in sol.u]\nall_errs = zeros(length(sol))\nerr_cache = zeros((Nx - 1) * Ny)\nfor i in eachindex(sol)\n    u = u_mat[i]\n    ctr = 1\n    for j in union(1:((Nx÷2)-1), ((Nx÷2)+1):Nx)\n        for k in 1:Ny\n            err_cache[ctr] = 100abs(u[j, k] .- u[Nx÷2, k])\n            ctr += 1\n        end\n    end\n    all_errs[i] = mean(err_cache)\nend\n@test all(all_errs .< 0.05)","category":"page"},{"location":"porous_fisher/","page":"Example V: Porous-Fisher equation and travelling waves","title":"Example V: Porous-Fisher equation and travelling waves","text":"In this code, we test the x-invariance by seeing if the u(x y) approx u(x_0 y) for each x, where x_0 is the midpoint a2.","category":"page"},{"location":"porous_fisher/","page":"Example V: Porous-Fisher equation and travelling waves","title":"Example V: Porous-Fisher equation and travelling waves","text":"To now see the travelling wave behaviour, we use the following:","category":"page"},{"location":"porous_fisher/","page":"Example V: Porous-Fisher equation and travelling waves","title":"Example V: Porous-Fisher equation and travelling waves","text":"large_time_idx = findfirst(sol.t .== 10)\nc = sqrt(λ / (2D))\ncₘᵢₙ = sqrt(λ * D / 2)\nzᶜ = 0.0\nexact_solution = ((z::T) where {T}) -> ifelse(z ≤ zᶜ, 1 - exp(cₘᵢₙ * (z - zᶜ)), zero(T))\ntravelling_wave_values = zeros(Ny, length(sol) - large_time_idx + 1)\nz_vals = zeros(Ny, length(sol) - large_time_idx + 1)\nfor (i, t_idx) in pairs(large_time_idx:lastindex(sol))\n    u = u_mat[t_idx]\n    τ = sol.t[t_idx]\n    for k in 1:Ny\n        y = c + (k - 1) * (d - c) / (Ny - 1)\n        z = y - c * τ\n        z_vals[k, i] = z\n        travelling_wave_values[k, i] = u[Nx÷2, k]\n    end\nend\nexact_z_vals = collect(LinRange(extrema(z_vals)..., 500))\nexact_travelling_wave_values = exact_solution.(exact_z_vals)","category":"page"},{"location":"porous_fisher/","page":"Example V: Porous-Fisher equation and travelling waves","title":"Example V: Porous-Fisher equation and travelling waves","text":"The results we obtain are shown below, with the exact travelling wave from the one-dimensional problem shown in red in the fourth plot and the numerical solutions are the other curves. ","category":"page"},{"location":"porous_fisher/","page":"Example V: Porous-Fisher equation and travelling waves","title":"Example V: Porous-Fisher equation and travelling waves","text":"using CairoMakie \n\n# The solution \npt_mat = Matrix(points')\nT_mat = [collect(T)[i][j] for i in 1:length(T), j in 1:3]\nfig = Figure(resolution=(3023.5881f0, 684.27f0), fontsize=38)\nax = Axis(fig[1, 1], width=600, height=600)\nmesh!(ax, pt_mat, T_mat, color=sol.u[1], colorrange=(0.0, 1.0), colormap=:matter)\nax = Axis(fig[1, 2], width=600, height=600)\nmesh!(ax, pt_mat, T_mat, color=sol.u[51], colorrange=(0.0, 1.0), colormap=:matter)\nax = Axis(fig[1, 3], width=600, height=600)\nmesh!(ax, pt_mat, T_mat, color=sol.u[101], colorrange=(0.0, 1.0), colormap=:matter)\n\n# The wave comparisons \nax = Axis(fig[1, 4], width=900, height=600)\ncolors = cgrad(:matter, length(sol) - large_time_idx + 1; categorical=false)\n[lines!(ax, z_vals[:, i], travelling_wave_values[:, i], color=colors[i], linewidth=2) for i in 1:(length(sol)-large_time_idx+1)]\nlines!(ax, exact_z_vals, exact_travelling_wave_values, color=:red, linewidth=4, linestyle=:dash)","category":"page"},{"location":"porous_fisher/","page":"Example V: Porous-Fisher equation and travelling waves","title":"Example V: Porous-Fisher equation and travelling waves","text":"(Image: Travelling wave problem)","category":"page"},{"location":"porous_medium/#Example-IV:-Porous-medium-equation","page":"Example IV: Porous-medium equation","title":"Example IV: Porous-medium equation","text":"","category":"section"},{"location":"porous_medium/","page":"Example IV: Porous-medium equation","title":"Example IV: Porous-medium equation","text":"Please ensure you have read the List of Examples section before proceeding.","category":"page"},{"location":"porous_medium/#No-source","page":"Example IV: Porous-medium equation","title":"No source","text":"","category":"section"},{"location":"porous_medium/","page":"Example IV: Porous-medium equation","title":"Example IV: Porous-medium equation","text":"We now consider the Porous medium equation,","category":"page"},{"location":"porous_medium/","page":"Example IV: Porous-medium equation","title":"Example IV: Porous-medium equation","text":"dfracpartial upartial t = Dboldsymbolnabla boldsymbolcdot leftu^m-1 boldsymbolnablauright","category":"page"},{"location":"porous_medium/","page":"Example IV: Porous-medium equation","title":"Example IV: Porous-medium equation","text":"with initial condition u(x y 0) = Mdelta(x y) where delta(x y) is the Dirac delta function and M = iint_mathbb R^2 u(x y t)mathrmdA. The diffusion function here is D(x y t u) = Du^m-1. We approximate delta(x y) by ","category":"page"},{"location":"porous_medium/","page":"Example IV: Porous-medium equation","title":"Example IV: Porous-medium equation","text":"delta(x y) approx g(x y) = frac1varepsilon^2 mathrmpiexpleft-frac1varepsilon^2left(x^2 + y^2right)right","category":"page"},{"location":"porous_medium/","page":"Example IV: Porous-medium equation","title":"Example IV: Porous-medium equation","text":"taking varepsilon = 01. This equation has an exact solution (see e.g. Section 17.5 of the The porous medium equation: Mathematical theory by J. L. Vázquez (2007)) ","category":"page"},{"location":"porous_medium/","page":"Example IV: Porous-medium equation","title":"Example IV: Porous-medium equation","text":"u(x y t) = begincases (Dt)^-1mleftleft(dfracM4mathrmpiright)^(m-1)m - dfracm-14mleft(x^2+y^2right)(Dt)^-1mright^1(m-1)  x^2 + y^2  R_m M(Dt)^1m \n0  x^2 + y^2 geq R_m M(Dt)^1mendcases","category":"page"},{"location":"porous_medium/","page":"Example IV: Porous-medium equation","title":"Example IV: Porous-medium equation","text":"where R_m M = 4m(m-1)M(4mathrmpi)^(m-1)m. This equation has compact support, so we replace mathbb R^2 by the domain Omega = -R_m M^12(DT)^12m R_m M^12(DT)^12m^2, where T is the time that we solve up to, and we take Dirichlet boundary conditions on partialOmega. We solve this problem as follows, taking m = 2, M = 037, D = 253, and T = 12. Note the use of the parameters.","category":"page"},{"location":"porous_medium/","page":"Example IV: Porous-medium equation","title":"Example IV: Porous-medium equation","text":"using DelaunayTriangulation, FiniteVolumeMethod\n\n## Step 0: Define all the parameters \nm = 2\nM = 0.37\nD = 2.53\nfinal_time = 12.0\nε = 0.1\n\n## Step 1: Define the mesh \nRmM = 4m / (m - 1) * (M / (4π))^((m - 1) / m)\nL = sqrt(RmM) * (D * final_time)^(1 / (2m))\nn = 500\nx₁ = LinRange(-L, L, n)\nx₂ = LinRange(L, L, n)\nx₃ = LinRange(L, -L, n)\nx₄ = LinRange(-L, -L, n)\ny₁ = LinRange(-L, -L, n)\ny₂ = LinRange(-L, L, n)\ny₃ = LinRange(L, L, n)\ny₄ = LinRange(L, -L, n)\nx = reduce(vcat, [x₁, x₂, x₃, x₄])\ny = reduce(vcat, [y₁, y₂, y₃, y₄])\nxy = [(x, y) for (x, y) in zip(x, y)]\nunique!(xy)\nx = getx.(xy)\ny = gety.(xy)\nr = 0.1\n(T, adj, adj2v, DG, points), BN = generate_mesh(x, y, r; gmsh_path=GMSH_PATH)\nmesh = FVMGeometry(T, adj, adj2v, DG, points, BN)\n\n## Step 2: Define the boundary conditions \nbc = ((x, y, t, u::T, p) where {T}) -> zero(T)\ntypes = :D\nBCs = BoundaryConditions(mesh, bc, types, BN)\n\n## Step 3: Define the actual PDE  \nf = (x, y) -> M * 1 / (ε^2 * π) * exp(-1 / (ε^2) * (x^2 + y^2))\ndiff_fnc = (x, y, t, u, p) -> p[1] * u^(p[2] - 1)\ndiff_parameters = (D, m)\nu₀ = [f(points[:, i]...) for i in axes(points, 2)]\nprob = FVMProblem(mesh, BCs; diffusion_function=diff_fnc,\n    diffusion_parameters=diff_parameters, initial_condition=u₀, final_time)\n\n## Step 4: Solve\nusing LinearSolve, OrdinaryDiffEq\n\nalg = TRBDF2(linsolve=KLUFactorization())\nsol = solve(prob, alg; saveat=3.0)\n\n## Step 5: Visualisation\nusing CairoMakie\n\npt_mat = Matrix(points')\nT_mat = [collect(T)[i][j] for i in 1:length(T), j in 1:3]\nfig = Figure(resolution=(2131.8438f0, 684.27f0), fontsize=38)\nax = Axis(fig[1, 1], width=600, height=600)\nmesh!(ax, pt_mat, T_mat, color=sol.u[1], colorrange=(0.0, 0.05), colormap=:matter)\nax = Axis(fig[1, 2], width=600, height=600)\nmesh!(ax, pt_mat, T_mat, color=sol.u[3], colorrange=(0.0, 0.05), colormap=:matter)\nax = Axis(fig[1, 3], width=600, height=600)\nmesh!(ax, pt_mat, T_mat, color=sol.u[5], colorrange=(0.0, 0.05), colormap=:matter)","category":"page"},{"location":"porous_medium/","page":"Example IV: Porous-medium equation","title":"Example IV: Porous-medium equation","text":"(Image: Porous-medium equation with m=2)","category":"page"},{"location":"porous_medium/#Linear-source","page":"Example IV: Porous-medium equation","title":"Linear source","text":"","category":"section"},{"location":"porous_medium/","page":"Example IV: Porous-medium equation","title":"Example IV: Porous-medium equation","text":"We can continue this example with the Porous medium equation by considering the same equation except with a linear source:","category":"page"},{"location":"porous_medium/","page":"Example IV: Porous-medium equation","title":"Example IV: Porous-medium equation","text":"dfracpartial upartial t = Dboldsymbolnabla boldsymbolcdot leftu^m-1boldsymbolnabla uright + lambda u quad lambda0 ","category":"page"},{"location":"porous_medium/","page":"Example IV: Porous-medium equation","title":"Example IV: Porous-medium equation","text":"This equation has an exact solution given by ","category":"page"},{"location":"porous_medium/","page":"Example IV: Porous-medium equation","title":"Example IV: Porous-medium equation","text":"u(x y t) = mathrme^lambda tvleft(x y fracDlambda(m-1)leftmathrme^lambda(m-1)t - 1rightright)","category":"page"},{"location":"porous_medium/","page":"Example IV: Porous-medium equation","title":"Example IV: Porous-medium equation","text":"where u(x y 0) = Mdelta(x y) and v is the exact solution we gave above except with D=1. This is what we use for assessing the solution in the tests - not shown here. The domain we use is now Omega = -R_m M^12tau(T)^12m R_mM^12tau(T)^12m^2, where tau(T) = fracDlambda(m-1)mathrme^lambda(m-1)T-1. The code below solves this problem.","category":"page"},{"location":"porous_medium/","page":"Example IV: Porous-medium equation","title":"Example IV: Porous-medium equation","text":"using OrdinaryDiffEq, LinearSolve, FiniteVolumeMethod, DelaunayTriangulation, CairoMakie\n\n## Step 0: Define all the parameters \nm = 3.4\nM = 2.3\nD = 0.581\nλ = 0.2\nfinal_time = 10.0\nε = 0.1\n\n## Step 1: Define the mesh \nRmM = 4m / (m - 1) * (M / (4π))^((m - 1) / m)\nL = sqrt(RmM) * (D / (λ * (m - 1)) * (exp(λ * (m - 1) * final_time) - 1))^(1 / (2m))\nn = 500\nx₁ = LinRange(-L, L, n)\nx₂ = LinRange(L, L, n)\nx₃ = LinRange(L, -L, n)\nx₄ = LinRange(-L, -L, n)\ny₁ = LinRange(-L, -L, n)\ny₂ = LinRange(-L, L, n)\ny₃ = LinRange(L, L, n)\ny₄ = LinRange(L, -L, n)\nx = reduce(vcat, [x₁, x₂, x₃, x₄])\ny = reduce(vcat, [y₁, y₂, y₃, y₄])\nxy = [(x, y) for (x, y) in zip(x, y)]\nunique!(xy)\nx = getx.(xy)\ny = gety.(xy)\nr = 0.07\n(T, adj, adj2v, DG, points), BN = generate_mesh(x, y, r; gmsh_path=GMSH_PATH)\nmesh = FVMGeometry(T, adj, adj2v, DG, points, BN)\n\n## Step 2: Define the boundary conditions \nbc = ((x, y, t, u::T, p) where {T}) -> zero(T)\ntypes = :D\nBCs = BoundaryConditions(mesh, bc, types, BN)\n\n## Step 3: Define the actual PDE  \nf = (x, y) -> M * 1 / (ε^2 * π) * exp(-1 / (ε^2) * (x^2 + y^2))\ndiff_fnc = (x, y, t, u, p) -> p[1] * abs(u)^(p[2] - 1)\nreac_fnc = (x, y, t, u, p) -> p[1] * u\ndiff_parameters = (D, m)\nreact_parameter = λ\nu₀ = [f(points[:, i]...) for i in axes(points, 2)]\nprob = FVMProblem(mesh, BCs; diffusion_function=diff_fnc,\n    diffusion_parameters=diff_parameters,\n    reaction_function=reac_fnc, reaction_parameters=react_parameter,\n    initial_condition=u₀, final_time)\n\n## Step 4: Solve\nalg = TRBDF2(linsolve=KLUFactorization())\nsol = solve(prob, alg; saveat=2.5)\n\n## Step 5: Visualisation \npt_mat = Matrix(points')\nT_mat = [collect(T)[i][j] for i in 1:length(T), j in 1:3]\nfig = Figure(resolution=(2131.8438f0, 684.27f0), fontsize=38)\nax = Axis(fig[1, 1], width=600, height=600)\nmesh!(ax, pt_mat, T_mat, color=sol.u[1], colorrange=(0.0, 0.5), colormap=:matter)\nax = Axis(fig[1, 2], width=600, height=600)\nmesh!(ax, pt_mat, T_mat, color=sol.u[3], colorrange=(0.0, 0.5), colormap=:matter)\nax = Axis(fig[1, 3], width=600, height=600)\nmesh!(ax, pt_mat, T_mat, color=sol.u[5], colorrange=(0.0, 0.5), colormap=:matter)","category":"page"},{"location":"porous_medium/","page":"Example IV: Porous-medium equation","title":"Example IV: Porous-medium equation","text":"(Image: Porous-medium equation with linear source)","category":"page"},{"location":"interpolants/#Example-VI:-Using-the-linear-interpolants","page":"Example VI: Using the linear interpolants","title":"Example VI: Using the linear interpolants","text":"","category":"section"},{"location":"interpolants/","page":"Example VI: Using the linear interpolants","title":"Example VI: Using the linear interpolants","text":"Please ensure you have read the List of Examples section before proceeding. This example also reuses some results from the end of Example V.","category":"page"},{"location":"interpolants/","page":"Example VI: Using the linear interpolants","title":"Example VI: Using the linear interpolants","text":"We now give an example of how one can efficiently evaluate the linear interpolants for a given solution. We illustrate this using the porous medium equation with a linear source example. Letting prob be as we computed in that example, we find the solution:","category":"page"},{"location":"interpolants/","page":"Example VI: Using the linear interpolants","title":"Example VI: Using the linear interpolants","text":"using OrdinaryDiffEq, LinearSolve\n\nalg = TRBDF2(linsolve=KLUFactorization(), autodiff=true)\nsol = solve(prob, alg, saveat=2.5)","category":"page"},{"location":"interpolants/","page":"Example VI: Using the linear interpolants","title":"Example VI: Using the linear interpolants","text":"If we just have a single point (x y) to evaluate the interpolant at, for a given t, we can do the following. First, we define the triple (x y t):","category":"page"},{"location":"interpolants/","page":"Example VI: Using the linear interpolants","title":"Example VI: Using the linear interpolants","text":"x = 0.37 \ny = 0.58\nt_idx = 5 # t = sol.t[t_idx]","category":"page"},{"location":"interpolants/","page":"Example VI: Using the linear interpolants","title":"Example VI: Using the linear interpolants","text":"Next, we must find what triangle contains (x, y). This is done by calling into the point location method provided by DelaunayTriangulation.jl, namely jump_and_march. We provide a simple interface for this using FVMProblem, which we use as follows:","category":"page"},{"location":"interpolants/","page":"Example VI: Using the linear interpolants","title":"Example VI: Using the linear interpolants","text":"using DelaunayTriangulation, Test\n\nV = jump_and_march(x, y, prob)\n@test DelaunayTriangulation.isintriangle(get_point(points, V...)..., (x, y)) == 1","category":"page"},{"location":"interpolants/","page":"Example VI: Using the linear interpolants","title":"Example VI: Using the linear interpolants","text":"(You can also provide keyword arguments to jump_and_march, matching those from DelaunayTriangulation.jl.) Now we can evaluate the interpolant at this point:","category":"page"},{"location":"interpolants/","page":"Example VI: Using the linear interpolants","title":"Example VI: Using the linear interpolants","text":"val = eval_interpolant(sol, x, y, t_idx, V)\n# or eval_interpolant(sol, x, y, sol.t[t_idx], V)","category":"page"},{"location":"interpolants/","page":"Example VI: Using the linear interpolants","title":"Example VI: Using the linear interpolants","text":"This is our approximation to u(037 058 02).","category":"page"},{"location":"interpolants/","page":"Example VI: Using the linear interpolants","title":"Example VI: Using the linear interpolants","text":"A more typical example would involve evaluating this interpolant over a much larger set of points. A good way to do this is to first find all the triangles that correspond to each point. In what follows, we define a lattice of points, and then we find the triangle for each point. To accelerate the procedure, when initiating the jump_and_march function we will tell it to also try starting at the previously found triangle. Note that we also put the grid slightly off the boundary since the generated mesh doesn't exactly lie on the square 0 2^2, hence some points wouldn't be in any triangle if we put some points exactly on this boundary.","category":"page"},{"location":"interpolants/","page":"Example VI: Using the linear interpolants","title":"Example VI: Using the linear interpolants","text":"nx = 250\nny = 250\ngrid_x = LinRange(-L + 1e-1, L - 1e-1, nx)\ngrid_y = LinRange(-L + 1e-1, L - 1e-1, ny)\nV_mat = Matrix{NTuple{3, Int64}}(undef, nx, ny)\nlast_triangle = rand(FVM.get_elements(prob)) # initiate \nfor j in 1:ny \n    for i in 1:nx \n        V_mat[i, j] = jump_and_march(grid_x[i], grid_y[j], prob; try_points = last_triangle)\n        last_triangle = V_mat[i, j]\n    end\nend","category":"page"},{"location":"interpolants/","page":"Example VI: Using the linear interpolants","title":"Example VI: Using the linear interpolants","text":"Now let's evaluate the interpolant at each time.","category":"page"},{"location":"interpolants/","page":"Example VI: Using the linear interpolants","title":"Example VI: Using the linear interpolants","text":"u_vals = zeros(nx, ny, length(sol))\nfor k in eachindex(sol)\n    for j in 1:ny\n        for i in 1:nx\n            V = V_mat[i, j]\n            u_vals[i, j, k] = eval_interpolant(sol, grid_x[i], grid_y[j], k, V)\n        end\n    end\nend","category":"page"},{"location":"interpolants/","page":"Example VI: Using the linear interpolants","title":"Example VI: Using the linear interpolants","text":"This setup now makes it easy to use surface! from Makie.jl to visualise the solution, thanks to our regular grid.","category":"page"},{"location":"interpolants/","page":"Example VI: Using the linear interpolants","title":"Example VI: Using the linear interpolants","text":"using CairoMakie\n\nfig = Figure(resolution=(2744.0f0, 692.0f0))\nfor k in 1:4\n    ax = Axis3(fig[1, k])\n    zlims!(ax, 0, 1), xlims!(ax, -L - 1e-1, L + 1e-1), ylims!(ax, -L - 1e-1, L + 1e-1)\n    surface!(ax, grid_x, grid_y, u_vals[:, :, k+1], colormap=:matter)\nend ","category":"page"},{"location":"interpolants/","page":"Example VI: Using the linear interpolants","title":"Example VI: Using the linear interpolants","text":"(Image: Surface plots)","category":"page"},{"location":"reaction_diffusion/#Example-III:-Reaction-diffusion-equation-with-a-time-dependent-Dirichlet-boundary-condition-on-a-disk","page":"Example III: Reaction-diffusion equation with a time-dependent Dirichlet boundary condition on a disk","title":"Example III: Reaction-diffusion equation with a time-dependent Dirichlet boundary condition on a disk","text":"","category":"section"},{"location":"reaction_diffusion/","page":"Example III: Reaction-diffusion equation with a time-dependent Dirichlet boundary condition on a disk","title":"Example III: Reaction-diffusion equation with a time-dependent Dirichlet boundary condition on a disk","text":"Please ensure you have read the List of Examples section before proceeding.","category":"page"},{"location":"reaction_diffusion/","page":"Example III: Reaction-diffusion equation with a time-dependent Dirichlet boundary condition on a disk","title":"Example III: Reaction-diffusion equation with a time-dependent Dirichlet boundary condition on a disk","text":"Now we consider","category":"page"},{"location":"reaction_diffusion/","page":"Example III: Reaction-diffusion equation with a time-dependent Dirichlet boundary condition on a disk","title":"Example III: Reaction-diffusion equation with a time-dependent Dirichlet boundary condition on a disk","text":"beginequation*\nbeginarrayrcll\ndfracpartial u(r theta t)partial t  =  boldsymbolnabla boldsymbolcdot uboldsymbolnabla u + u(1-u)  0  r  1 0  theta  2mathrmpi \ndfracmathrmdu(1 theta t)mathrmdt  =  u(1 theta t)  0  theta  2mathrmpi t  0  \nu(r theta 0)  =  sqrtI_0(sqrt2r)\nendarray\nendequation*","category":"page"},{"location":"reaction_diffusion/","page":"Example III: Reaction-diffusion equation with a time-dependent Dirichlet boundary condition on a disk","title":"Example III: Reaction-diffusion equation with a time-dependent Dirichlet boundary condition on a disk","text":"where I_0 is the modified Bessel function of the first kind of order zero. (The solution to this problem is u(r theta t) = mathrme^tsqrtI_0(sqrt2r) (see Bokhari et al. (2008)) This is what we compare to in the tests, and again these comparisons are not shown here.) In this case, the diffusion function is D(x y t u) = u and the reaction function is R(x y t u) = u(1-u), or equivalently the flux function is ","category":"page"},{"location":"reaction_diffusion/","page":"Example III: Reaction-diffusion equation with a time-dependent Dirichlet boundary condition on a disk","title":"Example III: Reaction-diffusion equation with a time-dependent Dirichlet boundary condition on a disk","text":"boldsymbolq(x y t alpha beta gamma) = left(-alphaleft(alpha x + beta y + gammaright) -betaleft(alpha x + beta y + gammaright)right)^mathsf T ","category":"page"},{"location":"reaction_diffusion/","page":"Example III: Reaction-diffusion equation with a time-dependent Dirichlet boundary condition on a disk","title":"Example III: Reaction-diffusion equation with a time-dependent Dirichlet boundary condition on a disk","text":"The following code solves this problem numerically.","category":"page"},{"location":"reaction_diffusion/","page":"Example III: Reaction-diffusion equation with a time-dependent Dirichlet boundary condition on a disk","title":"Example III: Reaction-diffusion equation with a time-dependent Dirichlet boundary condition on a disk","text":"using FiniteVolumeMethod, DelaunayTriangulation\n\n## Step 1: Generate the mesh \nn = 500\nr = LinRange(1, 1, 1000)\nθ = LinRange(0, 2π, 1000)\nx = @. r * cos(θ)\ny = @. r * sin(θ)\nr = 0.05\n(T, adj, adj2v, DG, points), BN = generate_mesh(x, y, r; gmsh_path=GMSH_PATH)\nmesh = FVMGeometry(T, adj, adj2v, DG, points, BN)\n\n## Step 2: Define the boundary conditions \nbc = (x, y, t, u, p) -> u\ntypes = :dudt\nBCs = BoundaryConditions(mesh, bc, types, BN)\n\n## Step 3: Define the actual PDE  \nusing Bessels\n\nf = (x, y) -> sqrt(besseli(0.0, sqrt(2) * sqrt(x^2 + y^2)))\nD = (x, y, t, u, p) -> u\nR = (x, y, t, u, p) -> u * (1 - u)\nu₀ = [f(points[:, i]...) for i in axes(points, 2)]\nfinal_time = 0.10\nprob = FVMProblem(mesh, BCs; diffusion_function=D, reaction_function=R, initial_condition=u₀, final_time)\n\n## Step 4: Solve\nusing OrdinaryDiffEq, LinearSolve\n\nalg = FBDF(linsolve=UMFPACKFactorization())\nsol = solve(prob, alg; saveat=0.025)\n\n## Step 5: Visualisation \nusing CairoMakie \n\npt_mat = Matrix(points')\nT_mat = [collect(T)[i][j] for i in 1:length(T), j in 1:3]\nfig = Figure(resolution=(2131.8438f0, 684.27f0), fontsize=38)\nax = Axis(fig[1, 1], width=600, height=600)\nmesh!(ax, pt_mat, T_mat, color=sol.u[1], colorrange=(1, 1.1), colormap=:matter)\nax = Axis(fig[1, 2], width=600, height=600)\nmesh!(ax, pt_mat, T_mat, color=sol.u[3], colorrange=(1, 1.1), colormap=:matter)\nax = Axis(fig[1, 3], width=600, height=600)\nmesh!(ax, pt_mat, T_mat, color=sol.u[5], colorrange=(1, 1.1), colormap=:matter)","category":"page"},{"location":"reaction_diffusion/","page":"Example III: Reaction-diffusion equation with a time-dependent Dirichlet boundary condition on a disk","title":"Example III: Reaction-diffusion equation with a time-dependent Dirichlet boundary condition on a disk","text":"(Image: Reaction-diffusion equation on a circle solution)","category":"page"},{"location":"math/#Mathematical-Details","page":"Mathematical Details","title":"Mathematical Details","text":"","category":"section"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"We now describe the mathematical details involved with the finite volume method as we have applied it. We assume that we have some triangulation of Omega, like a (constrained) Delaunay triangulation mathcal Dmathcal T(Omega). ","category":"page"},{"location":"math/#Interior-discretisation","page":"Mathematical Details","title":"Interior discretisation","text":"","category":"section"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"This triangulation is used to define control volumes around each point. This is illustrated in the following figure, where (a) shows the domain Omega and its triangulation mathcal T(Omega), together with the boundary partialOmega shown in blue. (b) shows the mesh in (a) along with the dual mesh shown in blue, with red points showing the centroids of each triangle in mathcalT(Omega). The blue polygons around each nodal point are the control volumes, and we denote the control volume around some point boldsymbolx_i by Omega_i and its boundary is partialOmega_i. (Note that this is the so-called ``vertex-centred approach'' to the finite volume method.)","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"(Image: Dual mesh)","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"To be more precise, consider some interior point boldsymbolx_i  = (x_i y_i)^mathsf T in Omega which is a point in mathcal T(Omega), i.e. one of the black points on the figure above. We take the centroids of the neighbouring triangles of boldsymbolx_i and connect these centroids to the midpoints of the associated triangle. These connections defined a closed polygon around boldsymbolx_i which we denote by partialOmega_i, and its interior will be Omega_i with some volume V_i. This polygon will be comprised of a set of edges mathcal E_i, and for each boldsymbolx_sigma inmathcal E_i there will be a length L_sigma, a midpoint boldsymbolx_sigma, and a unit normal vector hatboldsymboln_i sigma which is normal to sigma and directed outwards to Omega_i with hatboldsymboln_isigma = 1. This notation is elucidated in the figure below. In this figure, the green area shows Omega_i, and its boundary partialOmega_i is in blue. The edge sigma is shown in blue. Lastly, the cyan points show an example ordering (v_k1 v_k2 v_k3) of a triangle T_k in mathcal T(Omega). It is with these control volumes that we can now discretise our PDE partial_t u + boldsymbolnabla boldsymbolcdot boldsymbolq = R.","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"(Image: Control volume)","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"Let us start by integrating our equations around Omega_i and moving the time-derivative outside the integral:","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"beginequation\ndfracmathrm dmathrm dtiint_Omega_i u mathrmdV + iint_Omega_i boldsymbolnabla boldsymbolcdot boldsymbolq mathrmdV = iint_Omega_i R mathrmdV \nendequation ","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"Using the divergence theorem, the second integral becomes","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"beginequation\niint_Omega_i  boldsymbolnabla boldsymbolcdot boldsymbolqmathrmdV = oint_partialOmega_i boldsymbolq boldsymbolcdot hatboldsymboln_i sigmamathrmds = sum_sigmain mathcal E_i int_sigma boldsymbolq boldsymbolcdot hatboldsymboln_i sigmamathrmds\nendequation","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"where the last equality follows from integrating over each individual line segment that defines partialOmega_i. We now define the control volume averages,","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"beginequation\nbar u_i = frac1V_iiint_Omega_i umathrm dV qquad bar R_i = frac1V_iiint_Omega_i Rmathrm dV\nendequation","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"so that our integral formulation becomes","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"beginequation\ndfracmathrm dbar u_imathrm dt + frac1V_isum_sigmainmathcal E_iint_sigma boldsymbolq boldsymbolcdot hatboldsymboln_i sigmamathrm ds = bar R_i \nendequation","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"The line integrals can be approximated using a midpoint rule, ","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"beginequation\nint_sigma boldsymbolq boldsymbolcdot hatboldsymboln_i sigmamathrm ds approx leftboldsymbolq(x_sigma y_sigma t u) boldsymbolcdot hatboldsymboln_i sigmaright L_sigma \nendequation ","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"Lastly, the control volume averages can be approximated by simply replacing them by their value at (x_i y_i). We thus obtain the following approximation, where tilde u_i denotes an approximation to the exact solution u at (x_i y_i):","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"beginequation \nfracmathrm dtilde u_imathrm dt + frac1V_isum_sigma in mathcal E_i leftboldsymbolq(x_sigma y_sigma t u) boldsymbolcdot hatboldsymboln_i sigmaright L_sigma = tilde R_i\nendequation ","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"where tilde R_i is the approximation to bar R_i at (x_i y_i). This approximation is what we use in the interior of Omega for approximating the value of u at each node. ","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"We still need to discuss how we compute boldsymbolq(x_sigma y_sigma t u). To deal with this function, let mathcal T_i be the set of triangles in mathcal T(Omega) that have boldsymbolx_i as a node, and consider a triangle T_k in mathcal T_i. We will inteprolate tilde u with a linear shape function in T_k, so that ","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"beginequation\ntilde u(x y t) = alpha_k x + beta_ky + gamma_k quad (x y) in T_k\nendequation ","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"(The dependence of the coefficients alpha_k, beta_k, and gamma_k on t is suppressed.) We suppose that the three nodes defining T_k are (v_k1 v_k2 v_k3), and these points are given in a counter-clockwise order. An example of how these points are defined was shown in the control volume schematic figure. We can find alpha_k, beta_k, and gamma_k by noting that we know the values of tilde u at the nodes v_k1, v_k2, and v_k3, either from the initial condition or from the previous time-step of the integration. We will denote the value of tilde u at v_ki by tilde u_v_ki, i=123. We then have the system of equations, ","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"beginequation \ntilde u_v_ki = alpha_k x_v_ki + beta_k y_v_ki + gamma_k quad i=123 \nendequation ","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"where x_v_ki and y_v_ki denote the x- and y-coordinates of the point v_ki, respectively, for i=123. The system can be written in matrix form as ","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"beginbmatrix \nx_v_k1  y_v_k1  1  x_v_k2  y_v_k2  1  x_v_k3  y_v_k3  1 endbmatrixbeginbmatrix alpha_k  beta_k  gamma_k endbmatrix = beginbmatrix tilde u_v_k1  tilde u_v_k2  tilde u_v_k3\nendbmatrix ","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"Using Cramer's rule, we can define ","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"beginequation \nbeginarraylcllcllcl\ns_k1 = dfracy_v_k2 - y_v_k3Delta_k  s_k2 = dfracy_v_k3-y_v_k1Delta_k  s_k3 = dfracy_v_k1-y_v_k2Delta_k \ns_k4 = dfracx_v_k3-x_v_k2Delta_k s_k5 = dfracx_v_k1-x_v_k3Delta_k  s_k6 = dfracx_v_k2-x_v_k1Delta_k \ns_k7 = dfracx_v_k2y_v_k3-x_v_k3y_v_k2Delta_k  s_k8 = dfracx_v_k3y_v_k1-x_v_k1y_v_k3Delta_k s_k9 = dfracx_v_k1y_v_k2-x_v_k2y_v_k1Delta_k \nendarray \nendequation ","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"and ","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"beginequation\nDelta_k = x_v_k1y_v_k2-x_v_k2y_v_k1-x_v_k1y_v_k3+x_v_k3y_v_k1+x_v_k2y_v_k3-x_v_k3y_v_k2\nendequation","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"With this notation, ","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"beginequation \nbeginarrayrcl\nalpha_k = s_k1tilde u_v_k1 + s_k2tilde u_v_k2 + s_k3tilde u_v_k3 \nbeta_k =  s_k4tilde u_v_k1 + s_k5tilde u_v_k2 + s_k6tilde u_v_k3 \ngamma_k = s_k7tilde u_v_k1 + s_k8tilde u_v_k2 + s_k9tilde u_v_k3\nendarray\nendequation ","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"With these coefficients, our approximation becomes ","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"beginequation \nfracmathrm du_imathrm dt + frac1V_isum_sigmainmathcal E_i leftboldsymbolqleft(x_sigma y_sigma t alpha_k(sigma)x_sigma + beta_k(sigma)y_sigma + gamma_k(sigma)right) boldsymbolcdot hatboldsymboln_i sigmaright L_sigma = R_i\nendequation ","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"where we now drop the tilde notation and make the approximations implicit, and now the k(sigma) notation is used to refer to the edge sigma inside triangle T_k(sigma). This linear shape function also allows to compute gradients like boldsymbolnabla u(x_sigma y_sigma), since boldsymbolnabla u(x_sigma y_sigma) = (alpha_k(sigma) beta_k(sigma))^mathsf T.","category":"page"},{"location":"math/#Boundary-conditions","page":"Mathematical Details","title":"Boundary conditions","text":"","category":"section"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"As discussed at the start, we only support boundary conditions of the form ","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"beginarrayrcl\nboldsymbolq(x y t u) boldsymbolcdot hatboldsymboln(x y) = 0 \nmathrm du(x y t)mathrm dt = a(x y t u) \nu(x y t) = a(x y t u)\nendarray quad (x y)^mathsf T in partialOmega","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"For the Neumann boundary condition, recall that the integral form of our PDE was ","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"beginequation\ndfracmathrm dbar u_imathrm dt + frac1V_isum_sigmainmathcal E_iint_sigma boldsymbolq boldsymbolcdot hatboldsymboln_i sigmamathrm ds = bar R_i \nendequation","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"Thus, if sigma is an edge such that boldsymbolq boldsymbolcdot hatboldsymboln = 0, then the contribution from sigma to the above sum is zero. Thus, in our code, we simply skip over such a sigma when computing the sum. ","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"For the time-dependent Dirichlet boundary condition, we can skip over nodes with this condition and simply set mathrm du_imathrm dt = a(x y t u). ","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"Lastly, for the Dirichlet boundary conditions, we leave mathrm du_imathrm dt = 0 and simply update the value of u_i with a(x y t u_i) at the end of each iteration. This is done using callbacks.","category":"page"},{"location":"diffusion_equation/#Example-I:-Diffusion-Equation-on-a-Square-Plate","page":"Example I: Diffusion equation on a square plate","title":"Example I: Diffusion Equation on a Square Plate","text":"","category":"section"},{"location":"diffusion_equation/","page":"Example I: Diffusion equation on a square plate","title":"Example I: Diffusion equation on a square plate","text":"Please ensure you have read the List of Examples section before proceeding.","category":"page"},{"location":"diffusion_equation/","page":"Example I: Diffusion equation on a square plate","title":"Example I: Diffusion equation on a square plate","text":"We first consider the problem of diffusion on a square plate,","category":"page"},{"location":"diffusion_equation/","page":"Example I: Diffusion equation on a square plate","title":"Example I: Diffusion equation on a square plate","text":"beginequation*\nbeginarrayrcll\ndisplaystyle\nfracpartial u(x y t)partial t = dfrac19boldsymbolnabla^2 u(x y t)  (x y) in Omegat0 \nu(x y t) =  0  (x y) in partial Omegat0 \nu(x y 0) =  f(x y) (xy)inOmega\nendarray\nendequation*","category":"page"},{"location":"diffusion_equation/","page":"Example I: Diffusion equation on a square plate","title":"Example I: Diffusion equation on a square plate","text":"where Omega = 0 2^2 and f(x y) = 50 if y leq 1 and f(x y) = 0 if y1. (This problem has an exact solution ","category":"page"},{"location":"diffusion_equation/","page":"Example I: Diffusion equation on a square plate","title":"Example I: Diffusion equation on a square plate","text":"u(x y t) = dfrac200mathrmpi^2sum_m=1^inftysum_n=1^infty fracleft1+(-1)^m+1rightleft1-cosleft(fracnmathrmpi2right)rightmnsinleft(fracmmathrmpix2right)sinleft(fracnmathrmpiy2right)mathrme^-frac136mathrmpi^2(m^2+n^2)t","category":"page"},{"location":"diffusion_equation/","page":"Example I: Diffusion equation on a square plate","title":"Example I: Diffusion equation on a square plate","text":"and we compare our results to this exact solution in the tests. See e.g. here for a derivation of the exact solution. Comparisons not shown here.)","category":"page"},{"location":"diffusion_equation/#Setting-up-the-problem","page":"Example I: Diffusion equation on a square plate","title":"Setting up the problem","text":"","category":"section"},{"location":"diffusion_equation/","page":"Example I: Diffusion equation on a square plate","title":"Example I: Diffusion equation on a square plate","text":"The first step is to define the mesh:","category":"page"},{"location":"diffusion_equation/","page":"Example I: Diffusion equation on a square plate","title":"Example I: Diffusion equation on a square plate","text":"using FiniteVolumeMethod, DelaunayTriangulation\n\na, b, c, d = 0.0, 2.0, 0.0, 2.0\nn = 500\nx₁ = LinRange(a, b, n)\nx₂ = LinRange(b, b, n)\nx₃ = LinRange(b, a, n)\nx₄ = LinRange(a, a, n)\ny₁ = LinRange(c, c, n)\ny₂ = LinRange(c, d, n)\ny₃ = LinRange(d, d, n)\ny₄ = LinRange(d, c, n)\nx = reduce(vcat, [x₁, x₂, x₃, x₄])\ny = reduce(vcat, [y₁, y₂, y₃, y₄])\nxy = [[x[i], y[i]] for i in eachindex(x)]\nunique!(xy)\nx = getx.(xy)\ny = gety.(xy)\nr = 0.03\n(T, adj, adj2v, DG, points), BN = generate_mesh(x, y, r; gmsh_path=GMSH_PATH)\nmesh = FVMGeometry(T, adj, adj2v, DG, points, BN)","category":"page"},{"location":"diffusion_equation/","page":"Example I: Diffusion equation on a square plate","title":"Example I: Diffusion equation on a square plate","text":"Here I start by defining the square boundary as four segments, but then to have a single boundary segment I combine the segments into a single vector. I then create the mesh using generate_mesh, and then put the geometry together using FVMGeometry. ","category":"page"},{"location":"diffusion_equation/","page":"Example I: Diffusion equation on a square plate","title":"Example I: Diffusion equation on a square plate","text":"Now having defined the mesh, let us define the boundary conditions. We have a homogeneous Dirichlet condition, so let us simply set","category":"page"},{"location":"diffusion_equation/","page":"Example I: Diffusion equation on a square plate","title":"Example I: Diffusion equation on a square plate","text":"bc = ((x, y, t, u::T, p) where {T}) -> zero(T)\ntype = :Dirichlet # or :D or :dirichlet or \"D\" or \"Dirichlet\"\nBCs = BoundaryConditions(mesh, bc, type, BN)","category":"page"},{"location":"diffusion_equation/","page":"Example I: Diffusion equation on a square plate","title":"Example I: Diffusion equation on a square plate","text":"Next we must define the actual PDE. The initial condition, diffusion, and reaction functions are defined as follows:","category":"page"},{"location":"diffusion_equation/","page":"Example I: Diffusion equation on a square plate","title":"Example I: Diffusion equation on a square plate","text":"f = (x, y) -> y ≤ 1.0 ? 50.0 : 0.0 # initial condition \nD = (x, y, t, u, p) -> 1 / 9 # You could also define flux = (q, x, y, t, α, β, γ, p) -> (q[1] = -α/9; q[2] = -β/9)\nR = ((x, y, t, u::T, p) where {T}) -> zero(T)","category":"page"},{"location":"diffusion_equation/","page":"Example I: Diffusion equation on a square plate","title":"Example I: Diffusion equation on a square plate","text":"Using f, we compute the initial condition vector:","category":"page"},{"location":"diffusion_equation/","page":"Example I: Diffusion equation on a square plate","title":"Example I: Diffusion equation on a square plate","text":"u₀ = @views f.(points[1, :], points[2, :])","category":"page"},{"location":"diffusion_equation/","page":"Example I: Diffusion equation on a square plate","title":"Example I: Diffusion equation on a square plate","text":"We want the flux function to be computed in-place when it is constructed from D, so we will set iip_flux = true. Lastly, we want to solve up to t = 0.5, so final_time = 0.5 (initial_time = 0.0 is the default for the initial time). ","category":"page"},{"location":"diffusion_equation/","page":"Example I: Diffusion equation on a square plate","title":"Example I: Diffusion equation on a square plate","text":"iip_flux = true\nfinal_time = 0.5\nprob = FVMProblem(mesh, BCs; iip_flux,\n    diffusion_function=D, reaction_function=R,\n    initial_condition=u₀, final_time)","category":"page"},{"location":"diffusion_equation/","page":"Example I: Diffusion equation on a square plate","title":"Example I: Diffusion equation on a square plate","text":"This now defines our problem. Note that the delay function has been defined as the identity function, and the flux function has been computed from the diffusion function so that boldsymbolq(x y t alpha beta gamma) = (-alpha9-beta9)^mathsf T.","category":"page"},{"location":"diffusion_equation/#Solving-the-problem","page":"Example I: Diffusion equation on a square plate","title":"Solving the problem","text":"","category":"section"},{"location":"diffusion_equation/","page":"Example I: Diffusion equation on a square plate","title":"Example I: Diffusion equation on a square plate","text":"Now having the problem, we can solve it:","category":"page"},{"location":"diffusion_equation/","page":"Example I: Diffusion equation on a square plate","title":"Example I: Diffusion equation on a square plate","text":"using OrdinaryDiffEq, LinearSolve\n\nalg = TRBDF2(linsolve=KLUFactorization(), autodiff=true)\nsol = solve(prob, alg; specialization=SciMLBase.FullSpecialize, saveat=0.05)","category":"page"},{"location":"diffusion_equation/","page":"Example I: Diffusion equation on a square plate","title":"Example I: Diffusion equation on a square plate","text":"julia> sol\nretcode: Success\nInterpolation: 1st order linear\nt: 11-element Vector{Float64}:\n 0.0\n 0.05\n 0.1\n ⋮\n 0.45\n 0.5\nu: 11-element Vector{Vector{Float64}}:\n [50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0  …  0.0, 50.0, 50.0, 50.0, 0.0, 50.0, 50.0, 0.0, 0.0, 50.0]\n [...] (truncated)","category":"page"},{"location":"diffusion_equation/#Visualising-the-solution","page":"Example I: Diffusion equation on a square plate","title":"Visualising the solution","text":"","category":"section"},{"location":"diffusion_equation/","page":"Example I: Diffusion equation on a square plate","title":"Example I: Diffusion equation on a square plate","text":"You can use sol as you would any other solution from DifferentialEquations.jl (e.g. sol(t) returns the solution at time t). To visualise the solution at the times t = 0.0, t = 0.25, and t = 0.5, the following code can be used:","category":"page"},{"location":"diffusion_equation/","page":"Example I: Diffusion equation on a square plate","title":"Example I: Diffusion equation on a square plate","text":"using CairoMakie\n\npt_mat = Matrix(points')\nT_mat = [collect(T)[i][j] for i in 1:length(T), j in 1:3]\nfig = Figure(resolution=(2068.72f0, 686.64f0), fontsize=38)\nax = Axis(fig[1, 1], width=600, height=600)\nxlims!(ax, a, b)\nylims!(ax, c, d)\nmesh!(ax, pt_mat, T_mat, color=sol.u[1], colorrange=(0, 50), colormap=:matter)\nax = Axis(fig[1, 2], width=600, height=600)\nxlims!(ax, a, b)\nylims!(ax, c, d)\nmesh!(ax, pt_mat, T_mat, color=sol.u[6], colorrange=(0, 50), colormap=:matter)\nax = Axis(fig[1, 3], width=600, height=600)\nxlims!(ax, a, b)\nylims!(ax, c, d)\nmesh!(ax, pt_mat, T_mat, color=sol.u[11], colorrange=(0, 50), colormap=:matter)","category":"page"},{"location":"diffusion_equation/","page":"Example I: Diffusion equation on a square plate","title":"Example I: Diffusion equation on a square plate","text":"(Image: Heat equation solution)","category":"page"},{"location":"#FiniteVolumeMethod","page":"Home","title":"FiniteVolumeMethod","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: DOI)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is a package for solving partial differential equations (PDEs) of the form ","category":"page"},{"location":"","page":"Home","title":"Home","text":"dfracpartial u(x y t)partial t + boldsymbolnabla boldsymbolcdot boldsymbolq(x y t u) = R(x y t u) quad (x y)^mathsf T in Omega subset mathbb R^2t0","category":"page"},{"location":"","page":"Home","title":"Home","text":"with flux and reaction functions boldsymbolq and R, respectively, using the finite volume method. The boundary conditions are assumed to take on any of the three forms:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginarrayrcl\nboldsymbolq(x y t u) boldsymbolcdot hatboldsymboln(x y) = 0 \nmathrm du(x y t)mathrm dt = a(x y t u) \nu(x y t) = a(x y t u)\nendarray quad (x y)^mathsf T in partialOmega","category":"page"},{"location":"","page":"Home","title":"Home","text":"This first condition is a homogeneous Neumann boundary condition, letting hatboldsymboln(x y) be the unit outward normal vector field on partialOmega (the boundary of Omega); it is possible to extend this to the inhomogeneous case, it just has not been done yet. The second condition is a time-dependent Dirichlet condition, and the last condition is a Dirichlet condition. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"An interface is also provided for solving equations of the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"fracpartial u(x y t)partial t = boldsymbolnabla boldsymbolcdot leftT(x y t u)D(x y t u)boldsymbolnabla u(x y t)right + T(x y t u)R(x y t u)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where T is called the delay function, D the diffusion function, and R the reaction function; the same delay is assumed to scale both diffusion and reaction. The conversion is done by noting that the corresponding flux function boldsymbolq = (q_1 q_2)^mathsf T is simply q_i(x y t u) = -T(x y t u)D(x y t u)g_i, i=12, where (g_1 g_2)^mathsf T equiv boldsymbolnablau(x y t) (gradients are approximated using linear interpolants; more on this in the Mathematical Details section). Similarly, the reaction function is modified so that tildeR(x y t u) = T(x y t u)R(x y t u).","category":"page"}]
}
