<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interface · FiniteVolumeMethod.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FiniteVolumeMethod.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Interface</a><ul class="internal"><li><a class="tocitem" href="#FVMGeometry:-Defining-the-mesh"><span>FVMGeometry: Defining the mesh</span></a></li><li><a class="tocitem" href="#BoundaryConditions:-Defining-the-boundary-conditions"><span>BoundaryConditions: Defining the boundary conditions</span></a></li><li><a class="tocitem" href="#FVMProblem:-Defining-and-solving-the-problem"><span>FVMProblem: Defining and solving the problem</span></a></li><li><a class="tocitem" href="#Linear-Interpolants"><span>Linear Interpolants</span></a></li></ul></li><li><a class="tocitem" href="../docstrings/">Docstrings</a></li><li><a class="tocitem" href="../example_list/">List of Examples and Setup</a></li><li><a class="tocitem" href="../diffusion_equation/">Example I: Diffusion equation on a square plate</a></li><li><a class="tocitem" href="../diffusion_equation_on_a_wedge/">Example II: Diffusion equation in a wedge with mixed boundary conditions</a></li><li><a class="tocitem" href="../reaction_diffusion/">Example III: Reaction-diffusion equation with a time-dependent Dirichlet boundary condition on a disk</a></li><li><a class="tocitem" href="../porous_medium/">Example IV: Porous-medium equation</a></li><li><a class="tocitem" href="../porous_fisher/">Example V: Porous-Fisher equation and travelling waves</a></li><li><a class="tocitem" href="../interpolants/">Example VI: Using the linear interpolants</a></li><li><a class="tocitem" href="../math/">Mathematical Details</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Interface</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/main/docs/src/interface.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Interface"><a class="docs-heading-anchor" href="#Interface">Interface</a><a id="Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Interface" title="Permalink"></a></h1><p>The definition of a PDE requires definitions for (1) the triangular mesh, (2) the boundary conditions, and (3) the PDE itself. We describe here all three of these parts, with demonstrations of them given in the Examples section. Complete docstrings can be found in the sidebar.</p><h2 id="FVMGeometry:-Defining-the-mesh"><a class="docs-heading-anchor" href="#FVMGeometry:-Defining-the-mesh">FVMGeometry: Defining the mesh</a><a id="FVMGeometry:-Defining-the-mesh-1"></a><a class="docs-heading-anchor-permalink" href="#FVMGeometry:-Defining-the-mesh" title="Permalink"></a></h2><p>The struct that defines the underlying geometry is <code>FVMProblem</code>, storing information about the mesh, the boundary, the interior, and individual information about the elements. The mesh has to be triangular, and can be constructed using my other package <a href="https://github.com/DanielVandH/DelaunayTriangulation.jl">DelaunayTriangulation.jl</a>. The main constructor that we provided is:</p><pre><code class="language-julia hljs">FVMGeometry(T::Ts, adj, adj2v, DG, pts, BNV; 
    coordinate_type=Vector{number_type(pts)}, 
    control_volume_storage_type_vector=NTuple{3,coordinate_type}, 
    control_volume_storage_type_scalar=NTuple{3,number_type(pts)}, 
    shape_function_coefficient_storage_type=NTuple{9,number_type(pts)}, 
    interior_edge_storage_type=NTuple{2,Int64}, 
    interior_edge_pair_storage_type=NTuple{2,interior_edge_storage_type}) where {Ts}</code></pre><p>Here, <code>T</code>, <code>adj</code>, <code>adj2v</code>, and <code>DG</code> are structs representing the triangles, adjacent map, adjacent-to-vertex map, and the Delaunay graph, as defined in <a href="https://github.com/DanielVandH/DelaunayTriangulation.jl">DelaunayTriangulation.jl</a>. You can also provide a <code>Triangulation</code> type from DelaunayTriangulation.jl in place of <code>(T, adj, adj2v, DG, pts)</code>. The argument <code>pts</code> represents the points of the mesh, and lastly <code>BNV</code> is used to define the nodes for the separate boundary segments. For example, suppose we have the following domain with boundary <span>$\Gamma_1 \cup \Gamma_2 \cup \Gamma_3 \cup \Gamma_4$</span>:</p><p><img src="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/main/test/figures/boundary_condition_example.png?raw=true" alt="A segmented boundary"/></p><p>The colours are used to distinguish between different segments of the boundaries. The boundary node vector <code>BNV</code> would thus be defined as:</p><pre><code class="language-julia hljs">Γ₁ = [2, 11, 12, 13, 14, 15, 16, 3];
Γ₂ = [3, 17, 18, 19, 20, 21, 22, 4];
Γ₃ = [4, 23, 24, 25, 26, 27, 28, 1];
Γ₄ = [1, 5, 6, 7, 8, 9, 10, 2];
BNV = [Γ₁, Γ₂, Γ₃, Γ₄]</code></pre><p>It is crucial that these nodes are provided in counter-clockwise order, and that their endpoints connect (i.e. the last node of the previous segment is the same as the first node of the current segment).</p><p>A good way to generate these meshes, and the <code>BNV</code>, is to use <code>generate_mesh</code> from <a href="https://github.com/DanielVandH/DelaunayTriangulation.jl">DelaunayTriangulation.jl</a> (provided you have Gmsh installed). Note also that if you already have an existing set of triangular elements, points, and a known set of boundary nodes, the function <code>triangulate</code> (also from <a href="https://github.com/DanielVandH/DelaunayTriangulation.jl">DelaunayTriangulation.jl</a>) may be of interest to you.</p><p>The other keyword arguments in the function are just details about how certain variables are stored. See the docstrings in the sidebar.</p><h2 id="BoundaryConditions:-Defining-the-boundary-conditions"><a class="docs-heading-anchor" href="#BoundaryConditions:-Defining-the-boundary-conditions">BoundaryConditions: Defining the boundary conditions</a><a id="BoundaryConditions:-Defining-the-boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#BoundaryConditions:-Defining-the-boundary-conditions" title="Permalink"></a></h2><p>The next component to define is the set of boundary conditions, represented via the struct <code>BoundaryConditions</code>. The boundary condition functions are all assumed to take the form <code>f(x, y, t, u, p)</code>, where <code>p</code> are extra parameters that you provide. We provide the following constructor:</p><pre><code class="language-julia hljs">BoundaryConditions(mesh::FVMGeometry, functions, types, boundary_node_vector;
    params=Tuple(nothing for _ in (functions isa Function ? [1] : eachindex(functions))),
    u_type=Float64, float_type=Float64)</code></pre><p>Here, <code>functions</code> is a tuple for the functions for the boundary condition on each segment, where <code>functions[i]</code> should correspond to the segment represented by <code>BNV[i]</code>. Then, <code>types</code> is used to declare each segment as being of <em>Dirichlet</em>, <em>time-dependent Dirichlet</em>, or <em>Neumann</em> type, with <code>types[i]</code> corresponding to the segment represented by <code>BNV[i]</code>. This variable is defined according to the rules:</p><pre><code class="language-julia hljs">is_dirichlet_type(type) = type ∈ (:Dirichlet, :D, :dirichlet, &quot;Dirichlet&quot;, &quot;D&quot;, &quot;dirichlet&quot;)
is_neumann_type(type) = type ∈ (:Neumann, :N, :neumann, &quot;Neumann&quot;, &quot;N&quot;, &quot;neumann&quot;)
is_dudt_type(type) = type ∈ (:Dudt, :dudt, &quot;Dudt&quot;, &quot;dudt&quot;, &quot;du/dt&quot;)</code></pre><p>For example, <code>types = (:dudt, :neumann, :D, :D)</code> means that the first segment has a time-dependent Dirichlet boundary condition, the second a homogeneous Neumann boundary condition, and the last two segments have Dirichlet boundary conditions (with possibly different functions). The argument <code>boundary_node_vector</code> is the same as <code>BNV</code>. To provide the parameters <code>p</code> for each function, the keyword argument <code>params</code> is provided, letting <code>params[i]</code> be the set of parameters used when calling <code>functions[i]</code>. The type of the solution <code>u</code> can be declared using <code>u_type</code>, and the numbers representing the coordinates can be declared using <code>float_type</code>. Note that the values for any functions corresponding to a Neumann boundary condition are currently ignored (equivalent to assuming the function is zero).</p><h2 id="FVMProblem:-Defining-and-solving-the-problem"><a class="docs-heading-anchor" href="#FVMProblem:-Defining-and-solving-the-problem">FVMProblem: Defining and solving the problem</a><a id="FVMProblem:-Defining-and-solving-the-problem-1"></a><a class="docs-heading-anchor-permalink" href="#FVMProblem:-Defining-and-solving-the-problem" title="Permalink"></a></h2><p>The final piece to define are the flux and reaction functions, or alternatively the diffusion, delay, and reaction functions. Moreover, the initial condition and time span must be defined. This information is represented using the struct <code>FVMProblem</code>, which has constructor:</p><pre><code class="language-julia hljs">FVMProblem(mesh, boundary_conditions;
    iip_flux=true,
    diffusion_function=nothing,
    diffusion_parameters=nothing,
    reaction_function=nothing,
    reaction_parameters=nothing,
    delay_function=nothing,
    delay_parameters=nothing,
    flux_function=nothing,
    flux_parameters=nothing,
    initial_condition,
    initial_time=0.0,
    final_time,
    steady=false)</code></pre><p>The arguments <code>mesh</code> and <code>boundary_conditions</code> are the <code>FVMGeometry</code> and <code>BoundaryConditions</code> objects defined above. The <code>flux_function</code> keyword argument must take the form <code>flux!(q, x, y, t, α, β, γ, p)</code> (<code>iip_flux = true</code>) or <code>flux!(x, y, t, α, β, γ, p)</code> (<code>iip_flux = false</code>), where <code>p</code> are some parameters (provided by <code>flux_parameters</code>) and <code>q</code> is a cache vector of size 2 (defined in the solver). If <code>iip_flux = false</code>, then the flux vector should be returned as a tuple <code>(q1, q2)</code>. The arguments <code>α</code>, <code>β</code>, and <code>γ</code> in the flux function represent the linear interpolant used, <span>$u(x, y, t) \approx \alpha x + \beta y + \gamma$</span>, for approximating <span>$u$</span> over a single element, so that <span>$\boldsymbol{\nabla} u(x, y, t)$</span> is given by <span>$(\alpha, \beta)^{\mathsf T}$</span> and any instance of <span>$u$</span> should be replaced by <span>$\alpha x + \beta y + \gamma$</span>.</p><p>If <code>flux_function === nothing</code>, then a flux function is constructed using the delay and diffusion functions (<code>delay_function</code> and <code>diffusion_function</code>, respectively), each assumed to take the form <code>f(x, y, t, u, p)</code>, with the parameters <code>p</code> given by <code>delay_parameters</code> and <code>diffusion_parameters</code> for the delay and diffusion functions, respectively. If <code>delay_function === nothing</code>, it is assumed that the delay fnuction is the identity. The flux function is constructed using the diffusion function as described at the start of the README. </p><p>If <code>reaction_function === nothing</code>, then it is assumed that the reaction function is the zero function. Otherwise, the reaction function is assumed to take the form <code>f(x, y, t, u, p)</code>, with the parameters <code>p</code> given by <code>reaction_parameters</code>. If <code>delay_function !== nothing</code>, then this reaction function is re-defined to be <code>delay_function(x, y, t, u, p) * reaction_function(x, y, t, u, p)</code>.</p><p>The initial condition can be provided using the <code>initial_condition</code> keyword argument, and should be a vector of values so that <code>initial_condition[i]</code> is the value of <code>u</code> at <code>t = 0</code> and <code>(x, y) = get_point(pts, i)</code>.</p><p>Finally, the time span that the solution is solved over, <code>(initial_time, final_time)</code>, can be defined using the keyword arguments <code>initial_time</code> and <code>final_time</code>. </p><h3 id="Solving-the-FVMProblem"><a class="docs-heading-anchor" href="#Solving-the-FVMProblem">Solving the FVMProblem</a><a id="Solving-the-FVMProblem-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-the-FVMProblem" title="Permalink"></a></h3><p>Once the problem has been completely defined and you now have a <code>prob::FVMProblem</code>, you are ready to solve the problem. We build on the interface provided by <code>DifferentialEquations.jl</code> (see <a href="https://diffeq.sciml.ai/stable/">here</a>), using a <code>solve</code> command and any solver from <code>OrdinaryDiffEq.jl</code>. For example, we could define </p><pre><code class="language-julia hljs">using OrdinaryDiffEq, LinearSlove 
alg = TRBDF2(linsolve=KLUFactorization(), autodiff=true)</code></pre><p>(The code is compatible with automatic differentiation.) With this algorithm, we can easily solve the problem using </p><pre><code class="language-julia hljs">sol = solve(prob, alg)</code></pre><p>The solution will be the same type of result returned from <code>OrdinaryDiffEq.jl</code>, with <code>sol.u[i]</code> the solution at <code>sol.t[i]</code>, and <code>get_point(sol.u[i], j)</code> is the solution at <code>(x, y, t) = (get_point(pts, j)..., sol.t[i])</code>.</p><p>The <code>solve</code> command is defined as follows:</p><pre><code class="language-julia hljs">SciMLBase.solve(prob::FVMProblem, alg;
    cache_eltype::Type{F}=eltype(get_initial_condition(prob)),
    jac_prototype=float.(jacobian_sparsity(prob)),
    parallel=false,
    specialization::Type{S}=SciMLBase.AutoSpecialize,
    chunk_size=PreallocationTools.ForwardDiff.pickchunksize(length(get_initial_condition(prob))),
    kwargs...) where {S,F}</code></pre><p>This <code>cache_eltype</code> keyword sets the element type for the caches used for the flux vector and for <code>(α, β, γ)</code>, which is then used for wrapping a cache vector with <code>PreallocationTools.dualcache</code> for allowing automatic differentiation. </p><p>The <code>jac_prototype</code> keyword allows for a prototype of the Jacobian to be provided. This is easy to construct with our function <code>jacobian_sparsity</code>, since the Jacobian&#39;s non-zero structure is the same as <span>$\boldsymbol{A} + \boldsymbol{I}$</span>, where <span>$\boldsymbol{A}$</span> is the adjacency matrix of the triangulation. </p><p>The <code>parallel</code> keyword is supported as of v3.0. Be careful that your flux vector is thread-safe if you compute it in-place. This seems to make the code run around 4x as fast in the benchmarks I&#39;ve run.</p><p>The <code>specialization</code> keyword can be used to set the specialization level for the <code>ODEProblem</code>. <a href="https://diffeq.sciml.ai/stable/features/low_dep/#Controlling-Function-Specialization-and-Precompilation">See here for more details</a>.</p><p>The <code>chunk_size</code> argument sets the chunk size used for automatic differentiation when defining the cache vectors. </p><h2 id="Linear-Interpolants"><a class="docs-heading-anchor" href="#Linear-Interpolants">Linear Interpolants</a><a id="Linear-Interpolants-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Interpolants" title="Permalink"></a></h2><p>We also provide an interface for evaluating the solutions at any point <span>$(x, y)$</span>, or at least evaluating the solution&#39;s associated linear interpolant. As described in the Mathematical Details section, the solution <span>$u(x, y, t)$</span> is assumed to be linear inside a given triangular element <span>$T$</span>, i.e. <span>$u(x, y, t) \approx \alpha(t) x + \beta(t) y + \gamma(t)$</span> for <span>$(x, y) \in T$</span>. We provide two methods for evaluating this interpolant for a given <span>$(x, y)$</span> and a given <span>$T$</span>:</p><pre><code class="language-julia hljs">eval_interpolant(sol, x, y, t_idx::Integer, T) 
eval_interpolant(sol, x, y, t::Number, T) 
eval_interpolant!(αβγ, prob::FVMProblem, x, y, T, u)</code></pre><p>The first method takes a given solution <code>sol</code> (as defined in the last section), a given coordinate <code>(x, y)</code>, an index <code>t_idx</code> such that <code>sol.t[t_idx]</code> is the time of interest, and <code>T</code> is the triangle that <code>(x, y)</code> is inside of. The second method takes in a number for the time, instead computing the solution using <code>sol(t)</code>. The third method is the one that the first and second call into, where <code>αβγ</code> is a cache vector to store the coefficients of the interpolant, <code>prob</code> is the <code>FVMProblem</code>, and <code>u</code> is the vector of the solution values (i.e. <code>sol.u[t_idx]</code>, or <code>sol(t)</code> for example). It is up to you to provide the triangle <code>T</code> that <code>(x, y)</code> is inside of, but the tools in DelaunayTriangulation.jl can make this efficient. Note that <code>αβγ</code> is stored inside <code>sol</code>, so the first and second methods do not have to create an extra cache vector on each call. </p><p>An example of how to efficiently evaluate these interpolants is given in the examples.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../docstrings/">Docstrings »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Wednesday 21 December 2022 18:10">Wednesday 21 December 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
