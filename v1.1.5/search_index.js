var documenterSearchIndex = {"docs":
[{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"EditURL = \"https://github.com/SciML/FiniteVolumeMethod.jl/tree/main/docs/src/literate_tutorials/mean_exit_time.jl\"","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"using DisplayAs #hide\ntc = DisplayAs.withcontext(:displaysize => (15, 80), :limit => true); #hide\nnothing #hide","category":"page"},{"location":"tutorials/mean_exit_time/#Mean-Exit-Time","page":"Mean Exit Time","title":"Mean Exit Time","text":"","category":"section"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"Pages = [\"mean_exit_time.md\"]","category":"page"},{"location":"tutorials/mean_exit_time/#Definition-of-the-problem","page":"Mean Exit Time","title":"Definition of the problem","text":"","category":"section"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"In this tutorial, we consider the problem of mean exit time, based on some of my previous work.[1] Typically, mean exit time problems with linear diffusion take the form","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"beginequationlabeleqmet\nbeginaligned\nDgrad^2T(vb x) = -1  vb x in Omega \nT(vb x) = 0  vb x in partial Omega\nendaligned\nendequation","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"for some diffusivity D. T(vb x) is the mean exit time at vb x, meaning the average time it would take a particle starting at vb x to exit the domain through partialOmega. For this interpretation of T, we are letting D = mathcal Pdelta^2(4tau), where delta  0 is the step length of the particle, tau0 is the duration between steps, and mathcal P in 0 1 is the probability that the particle actually moves at a given time step.","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"[1]: See Simpson et al. (2021) and Carr et al. (2022).","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"In this previous work, we also use the finite volume method, but the problems are instead formulated  as linear problems, which makes the solution significantly simpler to implement. The approach we give here  is more generally applicable for other nonlinear problems, though.","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"A more complicated extension of \\eqref{eq:met} is to allow the particle to be moving through a heterogenous media, so that the diffusivity depends on vb x. In particular, let us consider a compound disk Omega = 0  r  R_1 cup R_1  r  R_2, and let mathcal P (the probability of movement) be piecewise constant across Omega (and thus also D):","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"P = begincases P_1  0rR_1P_2R_1rR_2endcasesquad D=begincasesD_10rR_1D_2R_1rR_2endcases","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"where D_1 = P_1delta^2(4tau) and D_2=P_2delta^2(4tau). The inner region, where 0  r  R_1, and the outer region, where R_1rR_2, are separated by an interface at r=R_1 and we apply an absorbing boundary condition at r=R_2, meaning particles that reach r=R_2 exit the domain. For this problem, \\eqref{eq:met} is instead given by","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"beginequationlabeleqmet2\nbeginaligned\nfracD_1rdvrleft(rdvT^(1)rright) = -1  0 rR_1 6pt\nfracD_2rdvrleft(rdvT^(2)rright) = -1  R_1rR_26pt\nT^(1)(R_1) = T^(2)(R_1) \nD_1dvT^(1)r(R_1) = D_2dvT^(2)r(R_1) 6pt\ndvT^(1)r(0) = 0 6pt\nT^(2)(R_2) = 0\nendaligned\nendequation","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"which we describe using polar coordinates, and we let T^(1)(r) be the mean exit time for 0  r  R_1, and T^(2)(r) be the mean exit time for R_1  r  R_2. The boundary conditions at the interface are to enforce continuity of T and continuity of the flux of T across the interface, and the condition mathrm dT^(1)mathrm dr = 0 at r=0 is to ensure that T^(1) is finite at r=0. This problem actually has an exact solution,","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"beginequationlabeleqmet2exact\nbeginaligned\nT^(1)(r) = fracR_1^2-r^24D_1+fracR_2^2-R_1^24D_2 \nT^(2)(r) = fracR_2^2-r^24D_2\nendaligned\nendequation","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"which will be useful later.","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"One other extension we can make is to allow the interface to be more complicated than just a circle. We take a perturbed interface, mathcal R_1(theta), so that the inner region is now 0  r  mathcal R_1(theta) and the outer region is mathcal R_1(theta)  r  R_2. The function mathcal R_1(theta) is written in the form mathcal R_1(theta) = R_1(1+varepsilon g(theta)), where varepsilon ll 1 is a perturbation parameter, R_1 is the radius of the unperturbed interface, and g(theta) is a smooth mathcal O(1) periodic function with period 2pi; we let g(theta) = sin(3theta) + cos(5theta) and varepsilon=005 for this tutorial. With this setup, \\eqref{eq:met2} now becomes","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"beginequationlabeleqmet3\nbeginaligned\nD_1grad^2 T^(1)(vb x) = -1  0  r  mathcal R_1(theta) \nD_2grad^2 T^(2)(vb x) = -1  mathcal R_1(theta)  r  R_2 \nT^(1)(mathcal R_1(theta)theta) = T^(2)(mathcal R_1(theta)theta) \nD_1grad T^(1)(mathcal R_1(theta) theta) vdot vu n(theta) = D_2grad T^(2)(mathcal R_1(theta) theta) vdot vu n(theta) \nT^(2)(R_2 theta) = 0 \nendaligned\nendequation","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"This problem has no exact solution (it has a perturbation solution, though, derived in Carr et al. (2022)).","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"At the end of this tutorial, we also consider modifying \\eqref{eq:met3} even further so that there are holes in the domain, and an internal Dirichlet condition at the origin.","category":"page"},{"location":"tutorials/mean_exit_time/#Unperturbed-interface","page":"Mean Exit Time","title":"Unperturbed interface","text":"","category":"section"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"Let us start by solving the problem on an unperturbed interface. We note that, while \\eqref{eq:met2} is defined so that there are two variables T^(1) and T^(2), which therefore requires continuity equations across the interface, numerically we can solve this in terms of a single variable T with a space-varying diffusivity. Moreover, the finiteness condition at the origin is not needed. Thus, we can solve","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"beginequation\nbeginaligned\nD(vb x)grad^2 T(vb x) = -1  vb x in mathcal D(0 R_2) \nT(vb x) = 0  vb x in partial mathcal D(0 R_2)\nendaligned\nendequation","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"Here, mathcal D(0R_2) is the circle of radius R_2 centred at the origin, and","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"D(vb x) = begincases D_1  vb x  R_1  D_2  R_1 leq vb x leq R_2 endcases","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"The mesh is defined as follows. To help the accuracy of the solution, we add more triangles around the interior circle by putting some constrained edges there.","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"using DelaunayTriangulation, FiniteVolumeMethod, CairoMakie\nR₁, R₂ = 2.0, 3.0\ncircle = CircularArc((0.0, R₂), (0.0, R₂), (0.0, 0.0))\npoints = NTuple{2,Float64}[]\ntri = triangulate(points; boundary_nodes=[circle])\nθ = LinRange(0, 2π, 250)\nxin = @views @. R₁ * cos(θ)[begin:end-1]\nyin = @views @. R₁ * sin(θ)[begin:end-1]\nadd_point!(tri, xin[1], yin[1])\nfor i in 2:length(xin)\n    add_point!(tri, xin[i], yin[i])\n    n = DelaunayTriangulation.num_points(tri)\n    add_segment!(tri, n - 1, n)\nend\nn = DelaunayTriangulation.num_points(tri)\nadd_segment!(tri, n - 1, n)\nrefine!(tri; max_area=1e-3get_area(tri))\ntriplot(tri)","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"mesh = FVMGeometry(tri)","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"The boundary conditions are simple absorbing conditions.","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"BCs = BoundaryConditions(mesh, ((x, y, t, u, p) -> zero(u),), (Dirichlet,))","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"For the problem, let us first define the diffusivity.","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"D₁, D₂ = 6.25e-4, 6.25e-5\ndiffusion_function = (x, y, t, u, p) -> let r = sqrt(x^2 + y^2)\n    return ifelse(r < p.R₁, p.D₁, p.D₂)\nend\ndiffusion_parameters = (R₁=R₁, D₁=D₁, D₂=D₂)","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"For the initial condition, which recall is the initial guess for the steady problem, let us use the exact solution for the mean exit time problem on a disk with a uniform diffusivity, which is given by (R_2^2 - r^2)(4D_2).","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"f = (x, y) -> let r = sqrt(x^2 + y^2)\n    return (R₂^2 - r^2) / (4D₂)\nend\ninitial_condition = [f(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)]\ninitial_condition |> tc #hide","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"We now define the problem.","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"source_function = (x, y, t, u, p) -> one(u)\nprob = FVMProblem(mesh, BCs;\n    diffusion_function, diffusion_parameters,\n    source_function, initial_condition,\n    final_time=Inf)","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"steady_prob = SteadyFVMProblem(prob)","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"We now solve this problem as we've done for any previous problem.","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"using SteadyStateDiffEq, LinearSolve, OrdinaryDiffEq\nsol = solve(steady_prob, DynamicSS(Rosenbrock23()))\nsol |> tc #hide","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"fig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=\"x\", ylabel=\"y\")\ntricontourf!(ax, tri, sol.u, levels=0:500:20000, extendhigh=:auto)\nfig","category":"page"},{"location":"tutorials/mean_exit_time/#Perturbed-interface","page":"Mean Exit Time","title":"Perturbed interface","text":"","category":"section"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"Let us now solve the problem with a perturbed interface. The mesh is defined as follows.","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"g = θ -> sin(3θ) + cos(5θ)\nε = 0.05\nR1_f = θ -> R₁ * (1 + ε * g(θ))\npoints = NTuple{2,Float64}[]\ncircle = CircularArc((0.0, R₂), (0.0, R₂), (0.0, 0.0))\ntri = triangulate(points; boundary_nodes=[circle])\nxin = @views (@. R1_f(θ) * cos(θ))[begin:end-1]\nyin = @views (@. R1_f(θ) * sin(θ))[begin:end-1]\nadd_point!(tri, xin[1], yin[1])\nfor i in 2:length(xin)\n    add_point!(tri, xin[i], yin[i])\n    n = DelaunayTriangulation.num_points(tri)\n    add_segment!(tri, n - 1, n)\nend\nn = DelaunayTriangulation.num_points(tri)\nadd_segment!(tri, n - 1, n)\nrefine!(tri; max_area=1e-3get_area(tri))\ntriplot(tri)","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"mesh = FVMGeometry(tri)","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"The boundary conditions are simple absorbing conditions.","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"BCs = BoundaryConditions(mesh, (x, y, t, u, p) -> zero(u), Dirichlet)","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"Now we define the problem. For the initial condition that we use, we will use the exact solution for the problem with an unperturbed interface.","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"function T_exact(x, y)\n    r = sqrt(x^2 + y^2)\n    if r < R₁\n        return (R₁^2 - r^2) / (4D₁) + (R₂^2 - R₁^2) / (4D₂)\n    else\n        return (R₂^2 - r^2) / (4D₂)\n    end\nend\ndiffusion_function = (x, y, t, u, p) -> let r = sqrt(x^2 + y^2), θ = atan(y, x)\n    interface_val = p.R1_f(θ)\n    return ifelse(r < interface_val, p.D₁, p.D₂)\nend\ndiffusion_parameters = (D₁=D₁, D₂=D₂, R1_f=R1_f)\ninitial_condition = [T_exact(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)]\nsource_function = (x, y, t, u, p) -> one(u)\nprob = FVMProblem(mesh, BCs;\n    diffusion_function, diffusion_parameters,\n    source_function, initial_condition,\n    final_time=Inf)\nsteady_prob = SteadyFVMProblem(prob)","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"sol = solve(steady_prob, DynamicSS(Rosenbrock23()))\nsol |> tc #hide","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"fig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=\"x\", ylabel=\"y\")\ntricontourf!(ax, tri, sol.u, levels=0:500:20000, extendhigh=:auto)\nlines!(ax, [xin; xin[1]], [yin; yin[1]], color=:magenta, linewidth=5)\nfig","category":"page"},{"location":"tutorials/mean_exit_time/#Adding-obstacles","page":"Mean Exit Time","title":"Adding obstacles","text":"","category":"section"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"Let us now add some obstacles into the problem. We add in components one at a time, exploring the impact of each component individually. When we update the triangulation, we do need to update the mesh since it is constructed from the initial tri.","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"The first obstacle we consider adding is a single hole at the origin, which we accomplish by adding a point at the origin and then using InternalConditions. This point will be used to absorb any nearby particles, i.e. T(00)=0.","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"add_point!(tri, 0.0, 0.0)\nmesh = FVMGeometry(tri)\nICs = InternalConditions((x, y, t, u, p) -> zero(u), dirichlet_nodes=Dict(DelaunayTriangulation.num_points(tri) => 1))\nBCs = BoundaryConditions(mesh, (x, y, t, u, p) -> zero(u), Dirichlet)\ninitial_condition = [T_exact(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)]\nprob = FVMProblem(mesh, BCs, ICs;\n    diffusion_function, diffusion_parameters,\n    source_function, initial_condition,\n    final_time=Inf)\nsteady_prob = SteadyFVMProblem(prob)\nsol = solve(steady_prob, DynamicSS(Rosenbrock23()))\nfig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=\"x\", ylabel=\"y\")\ntricontourf!(ax, tri, sol.u, levels=0:500:10000, extendhigh=:auto)\nlines!(ax, [xin; xin[1]], [yin; yin[1]], color=:magenta, linewidth=5)\nfig","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"We see that the hole has changed the interior significantly. For the next constraint, let us change the boundary so that we only allow particles to exit through a small part of the boundary, reflecting off all other parts. For the reflecting boundary condition, this is enforced by using Neumann boundary conditions.","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"ϵr = 0.25\ndirichlet_circle = CircularArc((R₂ * cos(ϵr), R₂ * sin(ϵr)), (R₂ * cos(2π - ϵr), R₂ * sin(2π - ϵr)), (0.0, 0.0))\nneumann_circle = CircularArc((R₂ * cos(2π - ϵr), R₂ * sin(2π - ϵr)), (R₂ * cos(ϵr), R₂ * sin(ϵr)), (0.0, 0.0))\nboundary_nodes = [[dirichlet_circle], [neumann_circle]]\npoints = NTuple{2,Float64}[]\ntri = triangulate(points; boundary_nodes)\nxin = @views (@. R1_f(θ) * cos(θ))[begin:end-1]\nyin = @views (@. R1_f(θ) * sin(θ))[begin:end-1]\nadd_point!(tri, xin[1], yin[1])\nfor i in 2:length(xin)\n    add_point!(tri, xin[i], yin[i])\n    n = DelaunayTriangulation.num_points(tri)\n    add_segment!(tri, n - 1, n)\nend\nn = DelaunayTriangulation.num_points(tri)\nadd_segment!(tri, n - 1, n)\nadd_point!(tri, 0.0, 0.0)\norigin_idx = DelaunayTriangulation.num_points(tri)\nrefine!(tri; max_area=1e-3get_area(tri))\ntriplot(tri)","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"mesh = FVMGeometry(tri)\nzero_f = (x, y, t, u, p) -> zero(u)\nBCs = BoundaryConditions(mesh, (zero_f, zero_f), (Neumann, Dirichlet))\nICs = InternalConditions((x, y, t, u, p) -> zero(u), dirichlet_nodes=Dict(origin_idx => 1))\ninitial_condition = [T_exact(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)]\nprob = FVMProblem(mesh, BCs, ICs;\n    diffusion_function, diffusion_parameters,\n    source_function, initial_condition,\n    final_time=Inf)\nsteady_prob = SteadyFVMProblem(prob)\nsol = solve(steady_prob, DynamicSS(Rosenbrock23()))\nfig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=\"x\", ylabel=\"y\")\ntricontourf!(ax, tri, sol.u, levels=0:2500:35000, extendhigh=:auto)\nlines!(ax, [xin; xin[1]], [yin; yin[1]], color=:magenta, linewidth=5)\nfig","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"Now, as a last constraint, let's add a hole. We'll put hole at the origin,  and we'll move the point hole to (-2 0) rather than at the origin, and we'll also put a hole at (0 295).","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"hole = CircularArc((0.0, 1.0), (0.0, 1.0), (0.0, 0.0), positive=false)\nboundary_nodes = [[[dirichlet_circle], [neumann_circle]], [[hole]]]\npoints = NTuple{2,Float64}[]\ntri = triangulate(points; boundary_nodes)\nxin = @views (@. R1_f(θ) * cos(θ))[begin:end-1]\nyin = @views (@. R1_f(θ) * sin(θ))[begin:end-1]\nadd_point!(tri, xin[1], yin[1])\nfor i in 2:length(xin)\n    add_point!(tri, xin[i], yin[i])\n    n = DelaunayTriangulation.num_points(tri)\n    add_segment!(tri, n - 1, n)\nend\nn = DelaunayTriangulation.num_points(tri)\nadd_segment!(tri, n - 1, n)\nadd_point!(tri, -2.0, 0.0)\nadd_point!(tri, 0.0, 2.95)\npointhole_idxs = [DelaunayTriangulation.num_points(tri), DelaunayTriangulation.num_points(tri) - 1]\nrefine!(tri; max_area=1e-3get_area(tri))\ntriplot(tri)","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"The boundary condition we'll use at the new interior hole will be an absorbing boundary condition.","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"mesh = FVMGeometry(tri)\nzero_f = (x, y, t, u, p) -> zero(u)\nBCs = BoundaryConditions(mesh, (zero_f, zero_f, zero_f), (Neumann, Dirichlet, Dirichlet))\nICs = InternalConditions((x, y, t, u, p) -> zero(u), dirichlet_nodes=Dict(pointhole_idxs .=> 1))\ninitial_condition = [T_exact(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)]\nprob = FVMProblem(mesh, BCs, ICs;\n    diffusion_function, diffusion_parameters,\n    source_function, initial_condition,\n    final_time=Inf)\nsteady_prob = SteadyFVMProblem(prob)\nsol = solve(steady_prob, DynamicSS(Rosenbrock23()))\nfig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=\"x\", ylabel=\"y\")\ntricontourf!(ax, tri, sol.u, levels=0:1000:15000, extendhigh=:auto)\nlines!(ax, [xin; xin[1]], [yin; yin[1]], color=:magenta, linewidth=5)\nfig","category":"page"},{"location":"tutorials/mean_exit_time/#Just-the-code","page":"Mean Exit Time","title":"Just the code","text":"","category":"section"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"using DelaunayTriangulation, FiniteVolumeMethod, CairoMakie\nR₁, R₂ = 2.0, 3.0\ncircle = CircularArc((0.0, R₂), (0.0, R₂), (0.0, 0.0))\npoints = NTuple{2,Float64}[]\ntri = triangulate(points; boundary_nodes=[circle])\nθ = LinRange(0, 2π, 250)\nxin = @views @. R₁ * cos(θ)[begin:end-1]\nyin = @views @. R₁ * sin(θ)[begin:end-1]\nadd_point!(tri, xin[1], yin[1])\nfor i in 2:length(xin)\n    add_point!(tri, xin[i], yin[i])\n    n = DelaunayTriangulation.num_points(tri)\n    add_segment!(tri, n - 1, n)\nend\nn = DelaunayTriangulation.num_points(tri)\nadd_segment!(tri, n - 1, n)\nrefine!(tri; max_area=1e-3get_area(tri))\ntriplot(tri)\n\nmesh = FVMGeometry(tri)\n\nBCs = BoundaryConditions(mesh, ((x, y, t, u, p) -> zero(u),), (Dirichlet,))\n\nD₁, D₂ = 6.25e-4, 6.25e-5\ndiffusion_function = (x, y, t, u, p) -> let r = sqrt(x^2 + y^2)\n    return ifelse(r < p.R₁, p.D₁, p.D₂)\nend\ndiffusion_parameters = (R₁=R₁, D₁=D₁, D₂=D₂)\n\nf = (x, y) -> let r = sqrt(x^2 + y^2)\n    return (R₂^2 - r^2) / (4D₂)\nend\ninitial_condition = [f(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)]\n\nsource_function = (x, y, t, u, p) -> one(u)\nprob = FVMProblem(mesh, BCs;\n    diffusion_function, diffusion_parameters,\n    source_function, initial_condition,\n    final_time=Inf)\n\nsteady_prob = SteadyFVMProblem(prob)\n\nusing SteadyStateDiffEq, LinearSolve, OrdinaryDiffEq\nsol = solve(steady_prob, DynamicSS(Rosenbrock23()))\n\nfig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=\"x\", ylabel=\"y\")\ntricontourf!(ax, tri, sol.u, levels=0:500:20000, extendhigh=:auto)\nfig\n\ng = θ -> sin(3θ) + cos(5θ)\nε = 0.05\nR1_f = θ -> R₁ * (1 + ε * g(θ))\npoints = NTuple{2,Float64}[]\ncircle = CircularArc((0.0, R₂), (0.0, R₂), (0.0, 0.0))\ntri = triangulate(points; boundary_nodes=[circle])\nxin = @views (@. R1_f(θ) * cos(θ))[begin:end-1]\nyin = @views (@. R1_f(θ) * sin(θ))[begin:end-1]\nadd_point!(tri, xin[1], yin[1])\nfor i in 2:length(xin)\n    add_point!(tri, xin[i], yin[i])\n    n = DelaunayTriangulation.num_points(tri)\n    add_segment!(tri, n - 1, n)\nend\nn = DelaunayTriangulation.num_points(tri)\nadd_segment!(tri, n - 1, n)\nrefine!(tri; max_area=1e-3get_area(tri))\ntriplot(tri)\n\nmesh = FVMGeometry(tri)\n\nBCs = BoundaryConditions(mesh, (x, y, t, u, p) -> zero(u), Dirichlet)\n\nfunction T_exact(x, y)\n    r = sqrt(x^2 + y^2)\n    if r < R₁\n        return (R₁^2 - r^2) / (4D₁) + (R₂^2 - R₁^2) / (4D₂)\n    else\n        return (R₂^2 - r^2) / (4D₂)\n    end\nend\ndiffusion_function = (x, y, t, u, p) -> let r = sqrt(x^2 + y^2), θ = atan(y, x)\n    interface_val = p.R1_f(θ)\n    return ifelse(r < interface_val, p.D₁, p.D₂)\nend\ndiffusion_parameters = (D₁=D₁, D₂=D₂, R1_f=R1_f)\ninitial_condition = [T_exact(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)]\nsource_function = (x, y, t, u, p) -> one(u)\nprob = FVMProblem(mesh, BCs;\n    diffusion_function, diffusion_parameters,\n    source_function, initial_condition,\n    final_time=Inf)\nsteady_prob = SteadyFVMProblem(prob)\n\nsol = solve(steady_prob, DynamicSS(Rosenbrock23()))\n\nfig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=\"x\", ylabel=\"y\")\ntricontourf!(ax, tri, sol.u, levels=0:500:20000, extendhigh=:auto)\nlines!(ax, [xin; xin[1]], [yin; yin[1]], color=:magenta, linewidth=5)\nfig\n\nadd_point!(tri, 0.0, 0.0)\nmesh = FVMGeometry(tri)\nICs = InternalConditions((x, y, t, u, p) -> zero(u), dirichlet_nodes=Dict(DelaunayTriangulation.num_points(tri) => 1))\nBCs = BoundaryConditions(mesh, (x, y, t, u, p) -> zero(u), Dirichlet)\ninitial_condition = [T_exact(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)]\nprob = FVMProblem(mesh, BCs, ICs;\n    diffusion_function, diffusion_parameters,\n    source_function, initial_condition,\n    final_time=Inf)\nsteady_prob = SteadyFVMProblem(prob)\nsol = solve(steady_prob, DynamicSS(Rosenbrock23()))\nfig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=\"x\", ylabel=\"y\")\ntricontourf!(ax, tri, sol.u, levels=0:500:10000, extendhigh=:auto)\nlines!(ax, [xin; xin[1]], [yin; yin[1]], color=:magenta, linewidth=5)\nfig\n\nϵr = 0.25\ndirichlet_circle = CircularArc((R₂ * cos(ϵr), R₂ * sin(ϵr)), (R₂ * cos(2π - ϵr), R₂ * sin(2π - ϵr)), (0.0, 0.0))\nneumann_circle = CircularArc((R₂ * cos(2π - ϵr), R₂ * sin(2π - ϵr)), (R₂ * cos(ϵr), R₂ * sin(ϵr)), (0.0, 0.0))\nboundary_nodes = [[dirichlet_circle], [neumann_circle]]\npoints = NTuple{2,Float64}[]\ntri = triangulate(points; boundary_nodes)\nxin = @views (@. R1_f(θ) * cos(θ))[begin:end-1]\nyin = @views (@. R1_f(θ) * sin(θ))[begin:end-1]\nadd_point!(tri, xin[1], yin[1])\nfor i in 2:length(xin)\n    add_point!(tri, xin[i], yin[i])\n    n = DelaunayTriangulation.num_points(tri)\n    add_segment!(tri, n - 1, n)\nend\nn = DelaunayTriangulation.num_points(tri)\nadd_segment!(tri, n - 1, n)\nadd_point!(tri, 0.0, 0.0)\norigin_idx = DelaunayTriangulation.num_points(tri)\nrefine!(tri; max_area=1e-3get_area(tri))\ntriplot(tri)\n\nmesh = FVMGeometry(tri)\nzero_f = (x, y, t, u, p) -> zero(u)\nBCs = BoundaryConditions(mesh, (zero_f, zero_f), (Neumann, Dirichlet))\nICs = InternalConditions((x, y, t, u, p) -> zero(u), dirichlet_nodes=Dict(origin_idx => 1))\ninitial_condition = [T_exact(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)]\nprob = FVMProblem(mesh, BCs, ICs;\n    diffusion_function, diffusion_parameters,\n    source_function, initial_condition,\n    final_time=Inf)\nsteady_prob = SteadyFVMProblem(prob)\nsol = solve(steady_prob, DynamicSS(Rosenbrock23()))\nfig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=\"x\", ylabel=\"y\")\ntricontourf!(ax, tri, sol.u, levels=0:2500:35000, extendhigh=:auto)\nlines!(ax, [xin; xin[1]], [yin; yin[1]], color=:magenta, linewidth=5)\nfig\n\nhole = CircularArc((0.0, 1.0), (0.0, 1.0), (0.0, 0.0), positive=false)\nboundary_nodes = [[[dirichlet_circle], [neumann_circle]], [[hole]]]\npoints = NTuple{2,Float64}[]\ntri = triangulate(points; boundary_nodes)\nxin = @views (@. R1_f(θ) * cos(θ))[begin:end-1]\nyin = @views (@. R1_f(θ) * sin(θ))[begin:end-1]\nadd_point!(tri, xin[1], yin[1])\nfor i in 2:length(xin)\n    add_point!(tri, xin[i], yin[i])\n    n = DelaunayTriangulation.num_points(tri)\n    add_segment!(tri, n - 1, n)\nend\nn = DelaunayTriangulation.num_points(tri)\nadd_segment!(tri, n - 1, n)\nadd_point!(tri, -2.0, 0.0)\nadd_point!(tri, 0.0, 2.95)\npointhole_idxs = [DelaunayTriangulation.num_points(tri), DelaunayTriangulation.num_points(tri) - 1]\nrefine!(tri; max_area=1e-3get_area(tri))\ntriplot(tri)\n\nmesh = FVMGeometry(tri)\nzero_f = (x, y, t, u, p) -> zero(u)\nBCs = BoundaryConditions(mesh, (zero_f, zero_f, zero_f), (Neumann, Dirichlet, Dirichlet))\nICs = InternalConditions((x, y, t, u, p) -> zero(u), dirichlet_nodes=Dict(pointhole_idxs .=> 1))\ninitial_condition = [T_exact(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)]\nprob = FVMProblem(mesh, BCs, ICs;\n    diffusion_function, diffusion_parameters,\n    source_function, initial_condition,\n    final_time=Inf)\nsteady_prob = SteadyFVMProblem(prob)\nsol = solve(steady_prob, DynamicSS(Rosenbrock23()))\nfig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=\"x\", ylabel=\"y\")\ntricontourf!(ax, tri, sol.u, levels=0:1000:15000, extendhigh=:auto)\nlines!(ax, [xin; xin[1]], [yin; yin[1]], color=:magenta, linewidth=5)\nfig","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"EditURL = \"https://github.com/SciML/FiniteVolumeMethod.jl/tree/main/docs/src/literate_tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk.jl\"","category":"page"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"using DisplayAs #hide\ntc = DisplayAs.withcontext(:displaysize => (15, 80), :limit => true); #hide\nnothing #hide","category":"page"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/#Reaction-Diffusion-Equation-with-a-Time-dependent-Dirichlet-Boundary-Condition-on-a-Disk","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"","category":"section"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"In this tutorial, we consider a reaction-diffusion equation on a disk with a boundary condition of the form mathrm dumathrm dt = u:","category":"page"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"beginequation*\nbeginaligned\npdvu(r theta t)t = divugrad u + u(1-u)  0r10theta2pi6pt\ndvu(1 theta t)t = u(1thetat)  0theta2pit06pt\nu(rtheta0) = sqrtI_0(sqrt2r)  0r10theta2pi\nendaligned\nendequation*","category":"page"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"where I_0 is the modified Bessel function of the first kind of order zero. For this problem the diffusion function is D(vb x t u) = u and the source function is R(vb x t u) = u(1-u), or equivalently the force function is","category":"page"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"vb q(vb x t alphabetagamma) = left(-alpha(alpha x + beta y + gamma) -beta(alpha x + beta y + gamma)right)^mkern-15mumathsfT","category":"page"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"As usual, we start by generating the mesh.","category":"page"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"using FiniteVolumeMethod, DelaunayTriangulation, ElasticArrays\nr = 1.0\ncircle = CircularArc((0.0, r), (0.0, r), (0.0, 0.0))\npoints = NTuple{2, Float64}[]\nboundary_nodes = [circle]\ntri = triangulate(points; boundary_nodes)\nA = get_area(tri)\nrefine!(tri; max_area=1e-4A)\nmesh = FVMGeometry(tri)","category":"page"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"using CairoMakie\ntriplot(tri)","category":"page"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"Now we define the boundary conditions and the PDE.","category":"page"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"using Bessels\nBCs = BoundaryConditions(mesh, (x, y, t, u, p) -> u, Dudt)","category":"page"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"f = (x, y) -> sqrt(besseli(0.0, sqrt(2) * sqrt(x^2 + y^2)))\nD = (x, y, t, u, p) -> u\nR = (x, y, t, u, p) -> u * (1 - u)\ninitial_condition = [f(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)]\nfinal_time = 0.10\nprob = FVMProblem(mesh, BCs;\n    diffusion_function=D,\n    source_function=R,\n    final_time,\n    initial_condition)","category":"page"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"We can now solve.","category":"page"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"using OrdinaryDiffEq, LinearSolve\nalg = FBDF(linsolve=UMFPACKFactorization(), autodiff=false)\nsol = solve(prob, alg, saveat=0.01)\nsol |> tc #hide","category":"page"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"fig = Figure(fontsize=38)\nfor (i, j) in zip(1:3, (1, 6, 11))\n    ax = Axis(fig[1, i], width=600, height=600,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[j])\",\n        titlealign=:left)\n    tricontourf!(ax, tri, sol.u[j], levels=1:0.01:1.4, colormap=:matter)\n    tightlimits!(ax)\nend\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/#Just-the-code","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Just the code","text":"","category":"section"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"using FiniteVolumeMethod, DelaunayTriangulation, ElasticArrays\nr = 1.0\ncircle = CircularArc((0.0, r), (0.0, r), (0.0, 0.0))\npoints = NTuple{2, Float64}[]\nboundary_nodes = [circle]\ntri = triangulate(points; boundary_nodes)\nA = get_area(tri)\nrefine!(tri; max_area=1e-4A)\nmesh = FVMGeometry(tri)\n\nusing CairoMakie\ntriplot(tri)\n\nusing Bessels\nBCs = BoundaryConditions(mesh, (x, y, t, u, p) -> u, Dudt)\n\nf = (x, y) -> sqrt(besseli(0.0, sqrt(2) * sqrt(x^2 + y^2)))\nD = (x, y, t, u, p) -> u\nR = (x, y, t, u, p) -> u * (1 - u)\ninitial_condition = [f(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)]\nfinal_time = 0.10\nprob = FVMProblem(mesh, BCs;\n    diffusion_function=D,\n    source_function=R,\n    final_time,\n    initial_condition)\n\nusing OrdinaryDiffEq, LinearSolve\nalg = FBDF(linsolve=UMFPACKFactorization(), autodiff=false)\nsol = solve(prob, alg, saveat=0.01)\n\nfig = Figure(fontsize=38)\nfor (i, j) in zip(1:3, (1, 6, 11))\n    ax = Axis(fig[1, i], width=600, height=600,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[j])\",\n        titlealign=:left)\n    tricontourf!(ax, tri, sol.u[j], levels=1:0.01:1.4, colormap=:matter)\n    tightlimits!(ax)\nend\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"","category":"page"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"EditURL = \"https://github.com/SciML/FiniteVolumeMethod.jl/tree/main/docs/src/literate_tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems.jl\"","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"using DisplayAs #hide\ntc = DisplayAs.withcontext(:displaysize => (15, 80), :limit => true); #hide\nnothing #hide","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/#Equilibrium-Temperature-Distribution-with-Mixed-Boundary-Conditions-and-using-EnsembleProblems","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"","category":"section"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"For this tutorial, we consider the following problem:","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"beginequation\nbeginaligned\ngrad^2 T = 0  vb x in Omega \ngrad T vdot vu n = 0  vb x in Gamma_1 \nT = 40  vb x in Gamma_2 \nkgrad T vdot vu n = h(T_infty - T)  vb x in Gamma_3 \nT = 70  vb x in Gamma_4 \nendaligned\nendequation","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"This domain Omega with boundary partialOmega=Gamma_1cupGamma_2cupGamma_3cupGamma_4 is shown below.","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"using CairoMakie #hide\nA = (0.0, 0.06) #hide\nB = (0.03, 0.06) #hide\nF = (0.03, 0.05) #hide\nG = (0.05, 0.03) #hide\nC = (0.06, 0.03) #hide\nD = (0.06, 0.0) #hide\nE = (0.0, 0.0) #hide\nfig = Figure(fontsize=33) #hide\nax = Axis(fig[1, 1], xlabel=\"x\", ylabel=\"y\") #hide\nlines!(ax, [A, E, D], color=:red, linewidth=5) #hide\nlines!(ax, [B, F, G, C], color=:blue, linewidth=5) #hide\nlines!(ax, [C, D], color=:black, linewidth=5) #hide\nlines!(ax, [A, B], color=:magenta, linewidth=5) #hide\ntext!(ax, [(0.03, 0.001)], text=L\"\\Gamma_1\", fontsize=44) #hide\ntext!(ax, [(0.055, 0.01)], text=L\"\\Gamma_2\", fontsize=44) #hide\ntext!(ax, [(0.04, 0.04)], text=L\"\\Gamma_3\", fontsize=44) #hide\ntext!(ax, [(0.015, 0.053)], text=L\"\\Gamma_4\", fontsize=44) #hide\ntext!(ax, [(0.001, 0.03)], text=L\"\\Gamma_1\", fontsize=44) #hide\nfig #hide","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"Let us start by defining the mesh.","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"using DelaunayTriangulation, FiniteVolumeMethod, CairoMakie\nA, B, C, D, E, F, G = (0.0, 0.0),\n(0.06, 0.0),\n(0.06, 0.03),\n(0.05, 0.03),\n(0.03, 0.05),\n(0.03, 0.06),\n(0.0, 0.06)\nbn1 = [G, A, B]\nbn2 = [B, C]\nbn3 = [C, D, E, F]\nbn4 = [F, G]\nbn = [bn1, bn2, bn3, bn4]\nboundary_nodes, points = convert_boundary_points_to_indices(bn)\ntri = triangulate(points; boundary_nodes)\nrefine!(tri; max_area=1e-4get_area(tri))\ntriplot(tri)","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"mesh = FVMGeometry(tri)","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"For the boundary conditions, the parameters that we use are k = 3, h = 20, and T_infty = 20 for thermal conductivity, heat transfer coefficient, and ambient temperature, respectively.","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"k = 3.0\nh = 20.0\nT∞ = 20.0\nbc1 = (x, y, t, T, p) -> zero(T) # ∇T⋅n=0\nbc2 = (x, y, t, T, p) -> oftype(T, 40.0) # T=40\nbc3 = (x, y, t, T, p) -> -p.h * (p.T∞- T) / p.k # k∇T⋅n=h(T∞-T). The minus is since q = -∇T\nbc4 = (x, y, t, T, p) -> oftype(T, 70.0) # T=70\nparameters = (nothing, nothing, (h=h, T∞=T∞, k=k), nothing)\nBCs = BoundaryConditions(mesh, (bc1, bc2, bc3, bc4),\n    (Neumann, Dirichlet, Neumann, Dirichlet);\n    parameters)","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"Now we can define the actual problem. For the initial condition, which recall is used as an initial guess for steady state problems, let us use an initial condition which ranges from T=70 at y=006 down to T=40 at y=0.","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"diffusion_function = (x, y, t, T, p) -> one(T)\nf = (x, y) -> 500y + 40\ninitial_condition = [f(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)]\nfinal_time = Inf\nprob = FVMProblem(mesh, BCs;\n    diffusion_function,\n    initial_condition,\n    final_time)","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"steady_prob = SteadyFVMProblem(prob)","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"Now we can solve.","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"using OrdinaryDiffEq, SteadyStateDiffEq\nsol = solve(steady_prob, DynamicSS(Rosenbrock23()))\nsol |> tc #hide","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"fig, ax, sc = tricontourf(tri, sol.u, levels=40:70, axis=(xlabel=\"x\", ylabel=\"y\"))\nfig","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/#Just-the-code","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Just the code","text":"","category":"section"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"using DelaunayTriangulation, FiniteVolumeMethod, CairoMakie\nA, B, C, D, E, F, G = (0.0, 0.0),\n(0.06, 0.0),\n(0.06, 0.03),\n(0.05, 0.03),\n(0.03, 0.05),\n(0.03, 0.06),\n(0.0, 0.06)\nbn1 = [G, A, B]\nbn2 = [B, C]\nbn3 = [C, D, E, F]\nbn4 = [F, G]\nbn = [bn1, bn2, bn3, bn4]\nboundary_nodes, points = convert_boundary_points_to_indices(bn)\ntri = triangulate(points; boundary_nodes)\nrefine!(tri; max_area=1e-4get_area(tri))\ntriplot(tri)\n\nmesh = FVMGeometry(tri)\n\nk = 3.0\nh = 20.0\nT∞ = 20.0\nbc1 = (x, y, t, T, p) -> zero(T) # ∇T⋅n=0\nbc2 = (x, y, t, T, p) -> oftype(T, 40.0) # T=40\nbc3 = (x, y, t, T, p) -> -p.h * (p.T∞- T) / p.k # k∇T⋅n=h(T∞-T). The minus is since q = -∇T\nbc4 = (x, y, t, T, p) -> oftype(T, 70.0) # T=70\nparameters = (nothing, nothing, (h=h, T∞=T∞, k=k), nothing)\nBCs = BoundaryConditions(mesh, (bc1, bc2, bc3, bc4),\n    (Neumann, Dirichlet, Neumann, Dirichlet);\n    parameters)\n\ndiffusion_function = (x, y, t, T, p) -> one(T)\nf = (x, y) -> 500y + 40\ninitial_condition = [f(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)]\nfinal_time = Inf\nprob = FVMProblem(mesh, BCs;\n    diffusion_function,\n    initial_condition,\n    final_time)\n\nsteady_prob = SteadyFVMProblem(prob)\n\nusing OrdinaryDiffEq, SteadyStateDiffEq\nsol = solve(steady_prob, DynamicSS(Rosenbrock23()))\n\nfig, ax, sc = tricontourf(tri, sol.u, levels=40:70, axis=(xlabel=\"x\", ylabel=\"y\"))\nfig","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"EditURL = \"https://github.com/SciML/FiniteVolumeMethod.jl/tree/main/docs/src/literate_tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation.jl\"","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"using DisplayAs #hide\ntc = DisplayAs.withcontext(:displaysize => (15, 80), :limit => true); #hide\nnothing #hide","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/#Piecewise-Linear-and-Natural-Neighbour-Inteprolation-for-an-Advection-Diffusion-Equation","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Inteprolation for an Advection-Diffusion Equation","text":"","category":"section"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"In this tutorial, we have three aims:","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"Demonstrate how to solve an advection-diffusion equation.\nDemonstrate how piecewise linear interpolation can be applied to a PDE solution at each time.\nDemonstrate how  NaturalNeighbours.jl can be applied to compute more accurate interpolants than piecewise linear interpolation at each time.","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"The equation we will be considering is","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"beginequationlabeleqadvdiffeq\nbeginaligned\npdvut = Dpdv2ux + Dpdv2uy - nupdvux\nendaligned\nendequation","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"with u(vb x 0) = delta(vb x) and homogeneous Dirichlet conditions, where delta is the Dirac delta function. This equation is defined on mathbb R^2, but we will replace mathbb R^2 with Omega = -L L^2 for L = 30.","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/#Solving-the-problem","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Solving the problem","text":"","category":"section"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"We start by defining and solving the problem associated with \\eqref{eq:advdiffeq}. For the mesh, we could use triangulate_rectangle, but we want to put most of the triangles near the origin, so we need to use refine! on an initial mesh.","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"using DelaunayTriangulation, FiniteVolumeMethod, LinearAlgebra, CairoMakie\nL = 30\ntri = triangulate_rectangle(-L, L, -L, L, 2, 2, single_boundary=true)\ntot_area = get_area(tri)\nmax_area_function = (A, r) -> 1e-6tot_area * r^2 / A\narea_constraint = (_tri, T) -> begin\n    u, v, w = triangle_vertices(T)\n    p, q, r = get_point(_tri, u, v, w)\n    c = (p .+ q .+ r) ./ 3\n    dist_to_origin = norm(c)\n    A = DelaunayTriangulation.triangle_area(p, q, r)\n    flag = A ≥ max_area_function(A, dist_to_origin)\n    return flag\nend\nrefine!(tri; min_angle=33.0, custom_constraint=area_constraint)\ntriplot(tri)","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"mesh = FVMGeometry(tri)","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"The boundary conditions are homogeneous Dirichlet conditions.","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"BCs = BoundaryConditions(mesh, (x, y, t, u, p) -> zero(u), Dirichlet)","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"We now need to define the actual problem. We need to write \\eqref{eq:advdiffeq} in the form","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"pdvut + divvb q = 0","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"To do this, write:","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"beginalign*\ndiv vb q = nupdvux - Dpdv2ux - Dpdv2uy \n= pdvxleft(nu u - Dpdvuxright) - pdvyleft(Dpdvuyright) \n= div beginbmatrix nu u - Dpdvux  -Dpdvuy endbmatrix^mkern-15mumathsfT \n= div left(boldsymbolnu u - Dgrad uright)\nendalign*","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"where boldsymbolnu = (nu 0)^mkern-15mumathsfT. Thus, we can write","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"vb q = boldsymbolnu u - Dgrad u","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"We now have our flux function. Next, let us define the initial condition. We approximate by","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"delta(vb x) approx g(vb x) approx frac1varepsilon^2piexpleft-frac1varepsilon^2left(x^2+y^2right)right","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"taking varepsilon=110. We can now define the problem. Remember that the flux function takes argument (alpha beta gamma) rather than u, replacing u with u(x y) = alpha x + beta y + gamma, and it returns a Tuple representing the vector. We let D = 002 and nu = 005.","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"ε = 1 / 10\nf = (x, y) -> 1 / (ε^2 * π) * exp(-(x^2 + y^2) / ε^2)\ninitial_condition = [f(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)]\nflux_function = (x, y, t, α, β, γ, p) -> begin\n    ∂x = α\n    ∂y = β\n    u = α * x + β * y + γ\n    qx = p.ν * u - p.D * ∂x\n    qy = -p.D * ∂y\n    return (qx, qy)\nend\nflux_parameters = (D=0.02, ν=0.05)\nfinal_time = 250.0\nprob = FVMProblem(mesh, BCs;\n    initial_condition,\n    flux_function,\n    flux_parameters,\n    final_time)","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"Now we can solve and visualise the solution.","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"using OrdinaryDiffEq, LinearSolve\ntimes = [0, 10, 25, 50, 100, 200, 250]\nsol = solve(prob, TRBDF2(linsolve=KLUFactorization()), saveat=times)\nsol |> tc #hide","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"using CairoMakie\nfig = Figure(fontsize=38)\nfor i in eachindex(sol)\n    ax = Axis(fig[1, i], width=400, height=400,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[i])\",\n        titlealign=:left)\n    tricontourf!(ax, tri, sol.u[i], levels=0:0.00001:0.001, extendhigh=:auto, extendlow=:auto, colormap=:matter)\n    tightlimits!(ax)\n    ylims!(ax, -10, 10)\nend\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/#Piecewise-linear-interpolation","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise linear interpolation","text":"","category":"section"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"As mentioned in mathematical details section, a key part of the finite volume method is the assumption that u is piecewise linear between each triangular element, letting u(x y) = alpha x + beta y + gamma. Thus, it may be natural to want to interpolate the solution using piecewise linear interpolation. This could be done by making use of jump_and_march from DelaunayTriangulation.jl to find the triangle containing a given point (x y) and then use pl_interpolate to interpolate the solution at the point; we do not provide a method that gets this triangle for you and then interpolates without this intermediate jump_and_march, as it is typically more efficient to first obtain all the triangles you need and then interpolate. In what follows, we:","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"Define a grid to interpolate over.\nFind the triangles containing each point in the grid.\nInterpolate at each point for the given times.","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"We consider the times t = 10 25 50 100 200 250. You could also of course amend the procedure so that you evaluate the interpolant at each time for a given point first, allowing you to avoid storing the triangle since you only consider each point a single time.","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"x = LinRange(-L, L, 250)\ny = LinRange(-L, L, 250)\ntriangles = Matrix{NTuple{3,Int}}(undef, length(x), length(y))\nfor j in eachindex(y)\n    for i in eachindex(x)\n        triangles[i, j] = jump_and_march(tri, (x[i], y[j]))\n    end\nend\ninterpolated_vals = zeros(length(x), length(y), length(sol))\nfor k in eachindex(sol)\n    for j in eachindex(y)\n        for i in eachindex(x)\n            interpolated_vals[i, j, k] = pl_interpolate(prob, triangles[i, j], sol.u[k], x[i], y[j])\n        end\n    end\nend","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"Let's visualise these results to check their accuracy. We compute the triangulation of our grid to make the tricontourf call faster.","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"_tri = triangulate([[x for x in x, _ in y] |> vec [y for _ in x, y in y] |> vec]')\nfig = Figure(fontsize=38)\nfor i in eachindex(sol)\n    ax = Axis(fig[1, i], width=400, height=400,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[i])\",\n        titlealign=:left)\n    tricontourf!(ax, _tri, interpolated_vals[:, :, i] |> vec, levels=0:0.00001:0.001, extendhigh=:auto, extendlow=:auto, colormap=:matter)\n    tightlimits!(ax)\n    ylims!(ax, -10, 10)\nend\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/#Natural-neighbour-interpolation","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Natural neighbour interpolation","text":"","category":"section"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"Since the solution is defined over a triangulation, the most natural form of inteprolation to use, other than piecewise linear interpolation, is natural neighbour interpolation. We can use NaturalNeighbours.jl for this; NaturalNeighbours.jl also provides the same piecewise linear interpolant above via its Triangle() interpolator, which may be more efficient as it has multithreading built in.","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"The way to construct a natural neighbour interpolant is as follows, where we provide the interpolant with the solution at t = 50.","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"using NaturalNeighbours\nitp = interpolate(tri, sol.u[4], derivatives=true) # sol.t[4] == 50\nsol |> tc #hide","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"We need derivatives = true so that we can use the higher order interpolants Sibson(1), Hiyoshi(2), and Farin() below - if you don't use those, then you shouldn't need this option (unless you want to later differentiate the interpolant using differentiate, then yes you do need it).","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"We can then evaluate this interpolant by simply calling it. The most efficient way to call it is by providing it with a vector of points, rather than broadcasting over points, since multithreading can be used in this case. Let us interpolate at the grid from before, which requires us to collect it into a vector:","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"_x = [x for x in x, _ in y] |> vec\n_y = [y for _ in x, y in y] |> vec;\nnothing #hide","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"We will look at all the interpolants provided by NaturalNeighbours.jl.[1]","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"[1]: This list is available from ?NaturalNeighbours.AbstractInterpolator. Look at the help page (?) for the respective interpolators or NaturalNeighbours.jl's documentation for more information.","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"sibson_vals = itp(_x, _y; method=Sibson())\ntriangle_vals = itp(_x, _y; method=Triangle()) # this is the same as pl_interpolate\nlaplace_vals = itp(_x, _y; method=Laplace())\nsibson_1_vals = itp(_x, _y; method=Sibson(1))\nnearest_vals = itp(_x, _y; method=Nearest())\nfarin_vals = itp(_x, _y; method=Farin())\nhiyoshi_vals = itp(_x, _y; method=Hiyoshi(2))\npde_vals = sol.u[4];\nnothing #hide","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"We visualise these results as follows.","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"fig = Figure(fontsize=38)\nall_vals = (sibson_vals, triangle_vals, laplace_vals, sibson_1_vals, nearest_vals, farin_vals, hiyoshi_vals, pde_vals)\ntitles = (\"(a): Sibson\", \"(b): Triangle\", \"(c): Laplace\", \"(d): Sibson-1\", \"(e): Nearest\", \"(f): Farin\", \"(g): Hiyoshi\", \"(h): PDE\")\nfig = Figure(fontsize=55, resolution=(6350, 1550)) # resolution from resize_to_layout!(fig) - had to manually adjust to fix missing ticks\nfor (i, (vals, title)) in enumerate(zip(all_vals, titles))\n    ax2d = Axis(fig[1, i], xlabel=\"x\", ylabel=\"y\", width=600, height=600, title=title, titlealign=:left)\n    ax3d = Axis3(fig[2, i], xlabel=\"x\", ylabel=\"y\", width=600, height=600, title=title, titlealign=:left)\n    ax3d.zlabeloffset[] = 125\n    xlims!(ax2d, -4, 6)\n    ylims!(ax2d, -4, 4)\n    xlims!(ax3d, -4, 6)\n    ylims!(ax3d, -4, 4)\n    if vals ≠ pde_vals\n        contourf!(ax2d, _x, _y, vals, colormap=:matter, levels=0:0.001:0.1, extendlow=:auto, extendhigh=:auto)\n        vals = copy(vals)\n        vals[(_x.<-4).|(_x.>6)] .= NaN\n        vals[(_y.<-4).|(_y.>4)] .= NaN # This is the only way to fix the weird issues with Axis3 when changing the (x/y/z)lims...\n        surface!(ax3d, _x, _y, vals, color=vals, colormap=:matter, colorrange=(0, 0.1))\n    else\n        tricontourf!(ax2d, tri, vals, colormap=:matter, levels=0:0.001:0.1, extendlow=:auto, extendhigh=:auto)\n        triangles = [T[j] for T in each_solid_triangle(tri), j in 1:3]\n        x = getx.(get_points(tri))\n        y = gety.(get_points(tri))\n        vals = copy(vals)\n        vals[(x.<-4).|(x.>6)] .= NaN\n        vals[(y.<-4).|(y.>4)] .= NaN # This is the only way to fix the weird issues with Axis3 when changing the (x/y/z)lims...\n        mesh!(ax3d, hcat(x, y, vals), triangles, color=vals, colormap=:matter, colorrange=(0, 0.1))\n    end\nend\nfig","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"We note that natural neighbour interpolation is not technically well defined for constrained triangulations. In this case it is fine, but for regions with, say, holes or non-convex boundaries, you may run into issues. For such cases, you should usually call the interpolant with project=false to at least help the procedure a bit. You may also be interested in identify_exterior_points. We consider interpolating data over a region with holes in this annulus example.","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/#Just-the-code","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Just the code","text":"","category":"section"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"using DelaunayTriangulation, FiniteVolumeMethod, LinearAlgebra, CairoMakie\nL = 30\ntri = triangulate_rectangle(-L, L, -L, L, 2, 2, single_boundary=true)\ntot_area = get_area(tri)\nmax_area_function = (A, r) -> 1e-6tot_area * r^2 / A\narea_constraint = (_tri, T) -> begin\n    u, v, w = triangle_vertices(T)\n    p, q, r = get_point(_tri, u, v, w)\n    c = (p .+ q .+ r) ./ 3\n    dist_to_origin = norm(c)\n    A = DelaunayTriangulation.triangle_area(p, q, r)\n    flag = A ≥ max_area_function(A, dist_to_origin)\n    return flag\nend\nrefine!(tri; min_angle=33.0, custom_constraint=area_constraint)\ntriplot(tri)\n\nmesh = FVMGeometry(tri)\n\nBCs = BoundaryConditions(mesh, (x, y, t, u, p) -> zero(u), Dirichlet)\n\nε = 1 / 10\nf = (x, y) -> 1 / (ε^2 * π) * exp(-(x^2 + y^2) / ε^2)\ninitial_condition = [f(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)]\nflux_function = (x, y, t, α, β, γ, p) -> begin\n    ∂x = α\n    ∂y = β\n    u = α * x + β * y + γ\n    qx = p.ν * u - p.D * ∂x\n    qy = -p.D * ∂y\n    return (qx, qy)\nend\nflux_parameters = (D=0.02, ν=0.05)\nfinal_time = 250.0\nprob = FVMProblem(mesh, BCs;\n    initial_condition,\n    flux_function,\n    flux_parameters,\n    final_time)\n\nusing OrdinaryDiffEq, LinearSolve\ntimes = [0, 10, 25, 50, 100, 200, 250]\nsol = solve(prob, TRBDF2(linsolve=KLUFactorization()), saveat=times)\n\nusing CairoMakie\nfig = Figure(fontsize=38)\nfor i in eachindex(sol)\n    ax = Axis(fig[1, i], width=400, height=400,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[i])\",\n        titlealign=:left)\n    tricontourf!(ax, tri, sol.u[i], levels=0:0.00001:0.001, extendhigh=:auto, extendlow=:auto, colormap=:matter)\n    tightlimits!(ax)\n    ylims!(ax, -10, 10)\nend\nresize_to_layout!(fig)\nfig\n\nx = LinRange(-L, L, 250)\ny = LinRange(-L, L, 250)\ntriangles = Matrix{NTuple{3,Int}}(undef, length(x), length(y))\nfor j in eachindex(y)\n    for i in eachindex(x)\n        triangles[i, j] = jump_and_march(tri, (x[i], y[j]))\n    end\nend\ninterpolated_vals = zeros(length(x), length(y), length(sol))\nfor k in eachindex(sol)\n    for j in eachindex(y)\n        for i in eachindex(x)\n            interpolated_vals[i, j, k] = pl_interpolate(prob, triangles[i, j], sol.u[k], x[i], y[j])\n        end\n    end\nend\n\n_tri = triangulate([[x for x in x, _ in y] |> vec [y for _ in x, y in y] |> vec]')\nfig = Figure(fontsize=38)\nfor i in eachindex(sol)\n    ax = Axis(fig[1, i], width=400, height=400,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[i])\",\n        titlealign=:left)\n    tricontourf!(ax, _tri, interpolated_vals[:, :, i] |> vec, levels=0:0.00001:0.001, extendhigh=:auto, extendlow=:auto, colormap=:matter)\n    tightlimits!(ax)\n    ylims!(ax, -10, 10)\nend\nresize_to_layout!(fig)\nfig\n\nusing NaturalNeighbours\nitp = interpolate(tri, sol.u[4], derivatives=true) # sol.t[4] == 50\n\n_x = [x for x in x, _ in y] |> vec\n_y = [y for _ in x, y in y] |> vec;\n\nsibson_vals = itp(_x, _y; method=Sibson())\ntriangle_vals = itp(_x, _y; method=Triangle()) # this is the same as pl_interpolate\nlaplace_vals = itp(_x, _y; method=Laplace())\nsibson_1_vals = itp(_x, _y; method=Sibson(1))\nnearest_vals = itp(_x, _y; method=Nearest())\nfarin_vals = itp(_x, _y; method=Farin())\nhiyoshi_vals = itp(_x, _y; method=Hiyoshi(2))\npde_vals = sol.u[4];\n\nfig = Figure(fontsize=38)\nall_vals = (sibson_vals, triangle_vals, laplace_vals, sibson_1_vals, nearest_vals, farin_vals, hiyoshi_vals, pde_vals)\ntitles = (\"(a): Sibson\", \"(b): Triangle\", \"(c): Laplace\", \"(d): Sibson-1\", \"(e): Nearest\", \"(f): Farin\", \"(g): Hiyoshi\", \"(h): PDE\")\nfig = Figure(fontsize=55, resolution=(6350, 1550)) # resolution from resize_to_layout!(fig) - had to manually adjust to fix missing ticks\nfor (i, (vals, title)) in enumerate(zip(all_vals, titles))\n    ax2d = Axis(fig[1, i], xlabel=\"x\", ylabel=\"y\", width=600, height=600, title=title, titlealign=:left)\n    ax3d = Axis3(fig[2, i], xlabel=\"x\", ylabel=\"y\", width=600, height=600, title=title, titlealign=:left)\n    ax3d.zlabeloffset[] = 125\n    xlims!(ax2d, -4, 6)\n    ylims!(ax2d, -4, 4)\n    xlims!(ax3d, -4, 6)\n    ylims!(ax3d, -4, 4)\n    if vals ≠ pde_vals\n        contourf!(ax2d, _x, _y, vals, colormap=:matter, levels=0:0.001:0.1, extendlow=:auto, extendhigh=:auto)\n        vals = copy(vals)\n        vals[(_x.<-4).|(_x.>6)] .= NaN\n        vals[(_y.<-4).|(_y.>4)] .= NaN # This is the only way to fix the weird issues with Axis3 when changing the (x/y/z)lims...\n        surface!(ax3d, _x, _y, vals, color=vals, colormap=:matter, colorrange=(0, 0.1))\n    else\n        tricontourf!(ax2d, tri, vals, colormap=:matter, levels=0:0.001:0.1, extendlow=:auto, extendhigh=:auto)\n        triangles = [T[j] for T in each_solid_triangle(tri), j in 1:3]\n        x = getx.(get_points(tri))\n        y = gety.(get_points(tri))\n        vals = copy(vals)\n        vals[(x.<-4).|(x.>6)] .= NaN\n        vals[(y.<-4).|(y.>4)] .= NaN # This is the only way to fix the weird issues with Axis3 when changing the (x/y/z)lims...\n        mesh!(ax3d, hcat(x, y, vals), triangles, color=vals, colormap=:matter, colorrange=(0, 0.1))\n    end\nend\nfig","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"EditURL = \"https://github.com/SciML/FiniteVolumeMethod.jl/tree/main/docs/src/literate_wyos/diffusion_equations.jl\"","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"using DisplayAs #hide\ntc = DisplayAs.withcontext(:displaysize => (15, 80), :limit => true); #hide\nnothing #hide","category":"page"},{"location":"wyos/diffusion_equations/#Diffusion-Equations","page":"Diffusion Equations","title":"Diffusion Equations","text":"","category":"section"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"Pages = [\"diffusion_equations.md\"]","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"We start by writing a specialised solver for solving diffusion equations. What we produce in this section can also be accessed in FiniteVolumeMethod.DiffusionEquation.","category":"page"},{"location":"wyos/diffusion_equations/#Mathematical-Details","page":"Diffusion Equations","title":"Mathematical Details","text":"","category":"section"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"Let us start by considering the mathematical details. The equation we consider is","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"beginequation\nbeginaligned\npdvut = divleftD(vb x)grad uright  vb x in Omega\nendaligned\nendequation","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"From the mathematical details section (where we also define the notation that follows), we know that discretising this problem leads to an equation of the form","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"dvu_it + frac1V_isum_sigmainmathcal E_ileftvb qleft(vb x_sigma t alpha_k(sigma)x_sigma+beta_k(sigma)y_sigma+gamma_k(sigma)right)vdotvu nrightL_sigma = S_i","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"For the diffusion equation, the flux function is vb q = -Dgrad u, meaning for an interior node we have","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"vb q(vb x_sigma t alpha_k(sigma)x_sigma+beta_k(sigma)y_sigma+gamma_k(sigma)) = -D(vb x_sigma)(alpha_k(sigma) beta_k(sigma))^mkern-15mumathsfT","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"Thus, also using S_i=0,","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"dvu_it = frac1V_isum_sigmainmathcal E_i D(vb x_sigma)leftalpha_k(sigma)n_sigma^x + beta_k(sigma)n_sigma^yrightL_sigma","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"where vu n = (n_sigma^x n_sigma^y)^mkern-15mumathsfT. It is still not immediately obvious how we can turn this into a linear problem. To see the linearity, note that","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"beginequation\nbeginaligned\nalpha_k(sigma) = s_k(sigma) 11u_k(sigma)1 + s_k(sigma) 12u_k(sigma)2 + s_k(sigma) 13u_k(sigma)3 \nbeta_k(sigma) = s_k(sigma) 21u_k(sigma)1 + s_k(sigma) 22u_k(sigma)2 + s_k(sigma)23u_k(sigma)3 \nendaligned\nendequation","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"thus, now writing k=k(sigma) for simplicity,","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"beginequation*\nbeginaligned\ndvu_it = frac1V_isum_sigmain mathcal E_i D(vb x_sigma)leftleft(s_k 11u_k1 + s_k 12u_k2 + s_k13u_k3right)n_sigma^x + left(s_k 21u_k1 + s_k 22u_k2 + s_k 23u_k3right)n_sigma^yrightL_sigma \n= frac1V_isum_sigmainmathcal E_i D(vb x_sigma)leftleft(s_k 11n_sigma^x + s_k 21n_sigma^yright)u_k1 + left(s_k 12n_sigma^x + s_k 22n_sigma^yright)u_k2 + left(s_k 13n_sigma^x + s_k 23n_sigma^yright)u_k3rightL_sigma \n= vb a_i^mkern-15mumathsfTvb u\nendaligned\nendequation*","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"Now, the result","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"beginequationlabeleqdisc1\ndvu_it = vb a_i^mkern-15mumathsfTvb u + b_i\nendequation","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"where b_i=0, is for the case that i is an interior node. We need to think about how boundary conditions get incorporated. For this problem, we will not allow the boundary conditions to depend on u or t.[1]","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"[1]: It would be fine to allow the boundary conditions to depend on t - we would still have linearity. The issue would just be that we need to reconstruct the matrix at every time step. So, for simplicity, let's not allow it so that the template we build is efficient for the most common case (where there is no t dependence).","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"Let's think about what we each type of boundary condition would to our problem.","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"For a Dirichlet boundary condition, we have u_i = a(vb x_i) for some vb x_i.  To implement this, we let the ith row of vb A be zero and b_i=0. Then,  as long as we start the Dirichlet nodes at u_i=a(vb x_i), they will stay at  that value as u_i = 0 there.[2]\nSuppose we have a Neumann boundary condition, say grad u vdot vu n = a(vb x),  we need to write the sum over sigma in mathcal E_i so that the differences  between the boundary edges and the interior edges are made explicit. Over these  boundary edges, we get sums that go into vb b rather than into vb A.\nFor conditions of the form mathrm du_imathrm dt = a(vb x_i), we should just  set vb a_i = vb 0 and b_i = a(vb x_i). Note that here vb A is singular.","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"[2]: If the boundary condition was non-autonomous, we could use a mass matrix instead, or build the condition into vb A and vb b directly by using the exact values of u where applicable.","category":"page"},{"location":"wyos/diffusion_equations/#Implementation","page":"Diffusion Equations","title":"Implementation","text":"","category":"section"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"We now know enough to implement our solver. Let us walk through this slowly, defining our function and then iterating it slowly to incorporate different features. The function signature will be similar to how we define an FVMProblem, namely","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"function diffusion_equation(mesh::FVMGeometry,\n    BCs::BoundaryConditions,\n    ICs::InternalConditions=InternalConditions();\n    diffusion_function,\n    diffusion_parameters=nothing,\n    initial_condition,\n    initial_time=0.0,\n    final_time)\n    # return the ODEProblem\nend","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"For the boundary and internal conditions, we'll assume that the functions take the same form, i.e. (x, y, t, u, p) -> Number, but the t and u arguments will both be passed as nothing. The diffusion function should be of the form (x, y, p) -> Number, or simply a Number.","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"We need to first write a function that will construct (vb A vb b). The idea for this is to loop over each triangle and then pick up the contributions, and then over all the boundary edges, just as we describe in the mathematical details section. The main difference being that, rather than adding terms to mathrm du_imathrm dt, we are picking out terms for b_i and also to put into vb A.","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"Let us start by writing out the contribution from all the triangles.","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"using FiniteVolumeMethod\nconst FVM = FiniteVolumeMethod\nfunction triangle_contributions!(A, mesh, conditions, diffusion_function, diffusion_parameters)\n    for T in each_solid_triangle(mesh.triangulation)\n        ijk = triangle_vertices(T)\n        i, j, k = ijk\n        props = FVM.get_triangle_props(mesh, i, j, k)\n        s₁₁, s₁₂, s₁₃, s₂₁, s₂₂, s₂₃, s₃₁, s₃₂, s₃₃ = props.shape_function_coefficients\n        for (edge_index, (e1, e2)) in enumerate(((i, j), (j, k), (k, i)))\n            x, y, nx, ny, ℓ = FVM.get_cv_components(props, edge_index)\n            D = diffusion_function(x, y, diffusion_parameters)\n            Dℓ = D * ℓ\n            a123 = (Dℓ * (s₁₁ * nx + s₂₁ * ny),\n                Dℓ * (s₁₂ * nx + s₂₂ * ny),\n                Dℓ * (s₁₃ * nx + s₂₃ * ny))\n            e1_hascond = FVM.has_condition(conditions, e1)\n            e2_hascond = FVM.has_condition(conditions, e2)\n            for vert in 1:3\n                e1_hascond || (A[e1, ijk[vert]] += a123[vert] / FVM.get_volume(mesh, e1))\n                e2_hascond || (A[e2, ijk[vert]] -= a123[vert] / FVM.get_volume(mesh, e2))\n            end\n        end\n    end\nend","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"Now we need the function that gets the contributions from the boundary edges.","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"function boundary_edge_contributions!(A, b, mesh, conditions,\n    diffusion_function, diffusion_parameters)\n    for e in keys(get_boundary_edge_map(mesh.triangulation))\n        i, j = DelaunayTriangulation.edge_vertices(e)\n        nx, ny, mᵢx, mᵢy, mⱼx, mⱼy, ℓ, T, props = FVM.get_boundary_cv_components(mesh, i, j)\n        ijk = triangle_vertices(T)\n        s₁₁, s₁₂, s₁₃, s₂₁, s₂₂, s₂₃, s₃₁, s₃₂, s₃₃ = props.shape_function_coefficients\n        Dᵢ = diffusion_function(mᵢx, mᵢy, diffusion_parameters)\n        Dⱼ = diffusion_function(mⱼx, mⱼy, diffusion_parameters)\n        i_hascond = FVM.has_condition(conditions, i)\n        j_hascond = FVM.has_condition(conditions, j)\n        if FVM.is_neumann_edge(conditions, i, j)\n            fidx = FVM.get_neumann_fidx(conditions, i, j)\n            aᵢ = FVM.eval_condition_fnc(conditions, fidx, mᵢx, mᵢy, nothing, nothing)\n            aⱼ = FVM.eval_condition_fnc(conditions, fidx, mⱼx, mⱼy, nothing, nothing)\n            i_hascond || (b[i] += Dᵢ * aᵢ * ℓ / FVM.get_volume(mesh, i))\n            j_hascond || (b[j] += Dⱼ * aⱼ * ℓ / FVM.get_volume(mesh, j))\n        else\n            aᵢ123 = (Dᵢ * ℓ * (s₁₁ * nx + s₂₁ * ny),\n                Dᵢ * ℓ * (s₁₂ * nx + s₂₂ * ny),\n                Dᵢ * ℓ * (s₁₃ * nx + s₂₃ * ny))\n            aⱼ123 = (Dⱼ * ℓ * (s₁₁ * nx + s₂₁ * ny),\n                Dⱼ * ℓ * (s₁₂ * nx + s₂₂ * ny),\n                Dⱼ * ℓ * (s₁₃ * nx + s₂₃ * ny))\n            for vert in 1:3\n                i_hascond || (A[i, ijk[vert]] += aᵢ123[vert] / FVM.get_volume(mesh, i))\n                j_hascond || (A[j, ijk[vert]] += aⱼ123[vert] / FVM.get_volume(mesh, i))\n            end\n        end\n    end\nend","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"Now that we have the parts for handling the main flux contributions, we need to consider the boundary conditions. Note that in the code above we have alredy taken not to update vb A or vb b if there a boundary condition at the associated node, so we do not need to worry about e.g. zeroing out rows of vb A for a node with a boundary condition.","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"function apply_dirichlet_conditions!(initial_condition, mesh, conditions)\n    for (i, function_index) in FVM.get_dirichlet_nodes(conditions)\n        x, y = get_point(mesh, i)\n        initial_condition[i] = FVM.eval_condition_fnc(conditions, function_index, x, y, nothing, nothing)\n    end\nend\nfunction apply_dudt_conditions!(b, mesh, conditions)\n    for (i, function_index) in FVM.get_dudt_nodes(conditions)\n        if !FVM.is_dirichlet_node(conditions, i) # overlapping edges can be both Dudt and Dirichlet. Dirichlet takes precedence\n            x, y = get_point(mesh, i)\n            b[i] = FVM.eval_condition_fnc(conditions, function_index, x, y, nothing, nothing)\n        end\n    end\nend","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"Now let's define diffusion_equation. For this, we note we want to write the problem in the form","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"dvvb ut = vb Avb u","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"to get the most out of our linearity in OrdinaryDiffEq.jl, whereas we currently have","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"dvvb ut = vb Avb u + vb b","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"To get around this, we define","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"tildevb u = beginbmatrix vb u  1 endbmatrix quad tildevb A = beginbmatrixvb A  vb b  vb 0^mkern-15mumathsfT  0 endbmatrix","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"so that","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"dvtildevb ut = beginbmatrix vb u  0 endbmatrix = beginbmatrix vb Avb u + vb b  0 endbmatrix = tildevb Atildevb u","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"Note that this also requires that we append a 1 to the initial condition.","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"function diffusion_equation(mesh::FVMGeometry,\n    BCs::BoundaryConditions,\n    ICs::InternalConditions=InternalConditions();\n    diffusion_function,\n    diffusion_parameters=nothing,\n    initial_condition,\n    initial_time=0.0,\n    final_time)\n    conditions = Conditions(mesh, BCs, ICs)\n    n = DelaunayTriangulation.num_solid_vertices(mesh.triangulation)\n    Afull = zeros(n + 1, n + 1)\n    A = @views Afull[begin:end-1, begin:end-1]\n    b = @views Afull[begin:end-1, end]\n    _ic = vcat(initial_condition, 1)\n    triangle_contributions!(A, mesh, conditions, diffusion_function, diffusion_parameters)\n    boundary_edge_contributions!(A, b, mesh, conditions, diffusion_function, diffusion_parameters)\n    apply_dudt_conditions!(b, mesh, conditions)\n    apply_dirichlet_conditions!(_ic, mesh, conditions)\n    A_op = MatrixOperator(sparse(Afull))\n    prob = ODEProblem(A_op, _ic, (initial_time, final_time))\n    return prob\nend","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"Let's now test the function. We use the same problem as in this tutorial.","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"using DelaunayTriangulation, OrdinaryDiffEq, LinearAlgebra, SparseArrays\ntri = triangulate_rectangle(0, 2, 0, 2, 50, 50, single_boundary=true)\nmesh = FVMGeometry(tri)\nBCs = BoundaryConditions(mesh, (x, y, t, u, p) -> zero(x), Dirichlet)\ndiffusion_function = (x, y, p) -> 1 / 9\ninitial_condition = [y ≤ 1.0 ? 50.0 : 0.0 for (x, y) in DelaunayTriangulation.each_point(tri)]\nfinal_time = 0.5\nprob = diffusion_equation(mesh, BCs;\n    diffusion_function,\n    initial_condition,\n    final_time)\nsol = solve(prob, Tsit5(); saveat=0.05)\nsol |> tc #hide","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"(It would be nice to use LinearExponential() in the call above, but it just seems to be extremely numerically unstable, so it's unusable.) Note also that sol contains an extra component:","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"length(sol.u[1])","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"DelaunayTriangulation.num_solid_vertices(tri)","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"This is because we needed to add in an extra component to represent the problem as a linear problem. So, the solution is in sol[begin:end-1, :], and you should ignore sol[end, :]. (The same applies to DiffusionEquation that we introduce later.)","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"Let's now plot.","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"using CairoMakie\nfig = Figure(fontsize=38)\nfor (i, j) in zip(1:3, (1, 6, 11))\n    ax = Axis(fig[1, i], width=600, height=600,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[j])\",\n        titlealign=:left)\n    u = j == 1 ? initial_condition : sol.u[j] # sol.u[1] is modified slightly to force the Dirichlet conditions at t = 0\n    tricontourf!(ax, tri, u, levels=0:5:50, colormap=:matter, extendlow=:auto, extendhigh=:auto) # don't need to do u[begin:end-1], since tri doesn't have that extra vertex.\n    tightlimits!(ax)\nend\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"This is exactly the solution we expect!","category":"page"},{"location":"wyos/diffusion_equations/#Using-the-Provided-Template","page":"Diffusion Equations","title":"Using the Provided Template","text":"","category":"section"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"Let's now use the built-in DiffusionEquation() which implements the above template inside FiniteVolumeMethod.jl.","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"diff_eq = DiffusionEquation(mesh, BCs;\n    diffusion_function,\n    initial_condition,\n    final_time)","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"Let's compare DiffusionEquation to the FVMProblem approach.","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"fvm_prob = FVMProblem(mesh, BCs;\n    diffusion_function=let D = diffusion_function\n        (x, y, t, u, p) -> D(x, y, p)\n    end,\n    initial_condition,\n    final_time)","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"using BenchmarkTools\n@btime solve($diff_eq, $Tsit5(), saveat=$0.05);","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"  5.736 ms (82 allocations: 552.42 KiB)","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"using LinearSolve\n@btime solve($fvm_prob, $TRBDF2(linsolve=KLUFactorization()), saveat=$0.05);","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"  49.237 ms (91755 allocations: 32.02 MiB)","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"Much better! The DiffusionEquation approach is about 10 times faster.","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"To finish this example, let's solve a diffusion equation with constant Neumann boundary conditions:","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"beginequation*\nbeginaligned\npdvut = 2grad^2 u  vb x in Omega \ngrad u vdot vu n = 2  vb x in partialOmega\nendaligned\nendequation*","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"Here, Omega = 0 320^2.","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"L = 320.0\ntri = triangulate_rectangle(0, L, 0, L, 100, 100, single_boundary=true)\nmesh = FVMGeometry(tri)\nBCs = BoundaryConditions(mesh, (x, y, t, u, p) -> 2.0, Neumann)\ndiffusion_function = (x, y, p) -> 2.0\ninitf = (x, y) -> begin\n    if 0.4L ≤ y ≤ 0.6L\n        return 1.0\n    else\n        return 0.0\n    end\nend\nfinal_time = 500.0\ninitial_condition = [initf(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)]\nprob = DiffusionEquation(mesh, BCs;\n    diffusion_function,\n    initial_condition,\n    final_time)","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"Let's solve and plot.","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"sol = solve(prob, Tsit5(); saveat=100.0)\nsol |> tc #hide","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"fig = Figure(fontsize=38)\nfor j in eachindex(sol)\n    ax = Axis(fig[1, j], width=600, height=600,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[j])\",\n        titlealign=:left)\n    u = j == 1 ? initial_condition : sol.u[j]\n    tricontourf!(ax, tri, u, levels=0:0.1:1, colormap=:turbo, extendlow=:auto, extendhigh=:auto)\n    tightlimits!(ax)\nend\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"For the corresponding FVMProblem, note that the Neumann boundary conditions need to be defined in terms of vb q = -D(vb x)grad u rather than grad u vdot vu n. So, since grad u vdot vu n = 2, we have -Dgrad u vdot vu n = -2D = -4, so vb q vdot vu n = -4. Here is a comparison of the two solutions.","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"BCs_prob = BoundaryConditions(mesh, (x, y, t, u, p) -> -4, Neumann)\nfvm_prob = FVMProblem(mesh, BCs_prob;\n    diffusion_function=let D = diffusion_function\n        (x, y, t, u, p) -> D(x, y, p)\n    end,\n    initial_condition,\n    final_time)\nfvm_sol = solve(fvm_prob, TRBDF2(linsolve=KLUFactorization()); saveat=100.0)\nfvm_sol |> tc #hide\n\nfor j in eachindex(fvm_sol)\n    ax = Axis(fig[2, j], width=600, height=600,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(fvm_sol.t[j])\",\n        titlealign=:left)\n    u = j == 1 ? initial_condition : fvm_sol.u[j]\n    tricontourf!(ax, tri, u, levels=0:0.1:1, colormap=:turbo, extendlow=:auto, extendhigh=:auto)\n    tightlimits!(ax)\nend\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"Here is a benchmark comparison.","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"@btime solve($prob, $Tsit5(), saveat=$100.0);","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"  78.761 ms (71 allocations: 1.76 MiB)","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"using Sundials\n@btime solve($fvm_prob, $CVODE_BDF(linear_solver=:GMRES), saveat=$100.0);","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"  94.839 ms (111666 allocations: 56.07 MiB)","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"These problems also work with the pl_interpolate function:","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"q = (30.0, 45.0)\nT = jump_and_march(tri, q)\nval = pl_interpolate(prob, T, sol.u[3], q[1], q[2])","category":"page"},{"location":"wyos/diffusion_equations/#Just-the-code","page":"Diffusion Equations","title":"Just the code","text":"","category":"section"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"using FiniteVolumeMethod\nconst FVM = FiniteVolumeMethod\nfunction triangle_contributions!(A, mesh, conditions, diffusion_function, diffusion_parameters)\n    for T in each_solid_triangle(mesh.triangulation)\n        ijk = triangle_vertices(T)\n        i, j, k = ijk\n        props = FVM.get_triangle_props(mesh, i, j, k)\n        s₁₁, s₁₂, s₁₃, s₂₁, s₂₂, s₂₃, s₃₁, s₃₂, s₃₃ = props.shape_function_coefficients\n        for (edge_index, (e1, e2)) in enumerate(((i, j), (j, k), (k, i)))\n            x, y, nx, ny, ℓ = FVM.get_cv_components(props, edge_index)\n            D = diffusion_function(x, y, diffusion_parameters)\n            Dℓ = D * ℓ\n            a123 = (Dℓ * (s₁₁ * nx + s₂₁ * ny),\n                Dℓ * (s₁₂ * nx + s₂₂ * ny),\n                Dℓ * (s₁₃ * nx + s₂₃ * ny))\n            e1_hascond = FVM.has_condition(conditions, e1)\n            e2_hascond = FVM.has_condition(conditions, e2)\n            for vert in 1:3\n                e1_hascond || (A[e1, ijk[vert]] += a123[vert] / FVM.get_volume(mesh, e1))\n                e2_hascond || (A[e2, ijk[vert]] -= a123[vert] / FVM.get_volume(mesh, e2))\n            end\n        end\n    end\nend\n\nfunction boundary_edge_contributions!(A, b, mesh, conditions,\n    diffusion_function, diffusion_parameters)\n    for e in keys(get_boundary_edge_map(mesh.triangulation))\n        i, j = DelaunayTriangulation.edge_vertices(e)\n        nx, ny, mᵢx, mᵢy, mⱼx, mⱼy, ℓ, T, props = FVM.get_boundary_cv_components(mesh, i, j)\n        ijk = triangle_vertices(T)\n        s₁₁, s₁₂, s₁₃, s₂₁, s₂₂, s₂₃, s₃₁, s₃₂, s₃₃ = props.shape_function_coefficients\n        Dᵢ = diffusion_function(mᵢx, mᵢy, diffusion_parameters)\n        Dⱼ = diffusion_function(mⱼx, mⱼy, diffusion_parameters)\n        i_hascond = FVM.has_condition(conditions, i)\n        j_hascond = FVM.has_condition(conditions, j)\n        if FVM.is_neumann_edge(conditions, i, j)\n            fidx = FVM.get_neumann_fidx(conditions, i, j)\n            aᵢ = FVM.eval_condition_fnc(conditions, fidx, mᵢx, mᵢy, nothing, nothing)\n            aⱼ = FVM.eval_condition_fnc(conditions, fidx, mⱼx, mⱼy, nothing, nothing)\n            i_hascond || (b[i] += Dᵢ * aᵢ * ℓ / FVM.get_volume(mesh, i))\n            j_hascond || (b[j] += Dⱼ * aⱼ * ℓ / FVM.get_volume(mesh, j))\n        else\n            aᵢ123 = (Dᵢ * ℓ * (s₁₁ * nx + s₂₁ * ny),\n                Dᵢ * ℓ * (s₁₂ * nx + s₂₂ * ny),\n                Dᵢ * ℓ * (s₁₃ * nx + s₂₃ * ny))\n            aⱼ123 = (Dⱼ * ℓ * (s₁₁ * nx + s₂₁ * ny),\n                Dⱼ * ℓ * (s₁₂ * nx + s₂₂ * ny),\n                Dⱼ * ℓ * (s₁₃ * nx + s₂₃ * ny))\n            for vert in 1:3\n                i_hascond || (A[i, ijk[vert]] += aᵢ123[vert] / FVM.get_volume(mesh, i))\n                j_hascond || (A[j, ijk[vert]] += aⱼ123[vert] / FVM.get_volume(mesh, i))\n            end\n        end\n    end\nend\n\nfunction apply_dirichlet_conditions!(initial_condition, mesh, conditions)\n    for (i, function_index) in FVM.get_dirichlet_nodes(conditions)\n        x, y = get_point(mesh, i)\n        initial_condition[i] = FVM.eval_condition_fnc(conditions, function_index, x, y, nothing, nothing)\n    end\nend\nfunction apply_dudt_conditions!(b, mesh, conditions)\n    for (i, function_index) in FVM.get_dudt_nodes(conditions)\n        if !FVM.is_dirichlet_node(conditions, i) # overlapping edges can be both Dudt and Dirichlet. Dirichlet takes precedence\n            x, y = get_point(mesh, i)\n            b[i] = FVM.eval_condition_fnc(conditions, function_index, x, y, nothing, nothing)\n        end\n    end\nend\n\nfunction diffusion_equation(mesh::FVMGeometry,\n    BCs::BoundaryConditions,\n    ICs::InternalConditions=InternalConditions();\n    diffusion_function,\n    diffusion_parameters=nothing,\n    initial_condition,\n    initial_time=0.0,\n    final_time)\n    conditions = Conditions(mesh, BCs, ICs)\n    n = DelaunayTriangulation.num_solid_vertices(mesh.triangulation)\n    Afull = zeros(n + 1, n + 1)\n    A = @views Afull[begin:end-1, begin:end-1]\n    b = @views Afull[begin:end-1, end]\n    _ic = vcat(initial_condition, 1)\n    triangle_contributions!(A, mesh, conditions, diffusion_function, diffusion_parameters)\n    boundary_edge_contributions!(A, b, mesh, conditions, diffusion_function, diffusion_parameters)\n    apply_dudt_conditions!(b, mesh, conditions)\n    apply_dirichlet_conditions!(_ic, mesh, conditions)\n    A_op = MatrixOperator(sparse(Afull))\n    prob = ODEProblem(A_op, _ic, (initial_time, final_time))\n    return prob\nend\n\nusing DelaunayTriangulation, OrdinaryDiffEq, LinearAlgebra, SparseArrays\ntri = triangulate_rectangle(0, 2, 0, 2, 50, 50, single_boundary=true)\nmesh = FVMGeometry(tri)\nBCs = BoundaryConditions(mesh, (x, y, t, u, p) -> zero(x), Dirichlet)\ndiffusion_function = (x, y, p) -> 1 / 9\ninitial_condition = [y ≤ 1.0 ? 50.0 : 0.0 for (x, y) in DelaunayTriangulation.each_point(tri)]\nfinal_time = 0.5\nprob = diffusion_equation(mesh, BCs;\n    diffusion_function,\n    initial_condition,\n    final_time)\nsol = solve(prob, Tsit5(); saveat=0.05)\n\nlength(sol.u[1])\n\nDelaunayTriangulation.num_solid_vertices(tri)\n\nusing CairoMakie\nfig = Figure(fontsize=38)\nfor (i, j) in zip(1:3, (1, 6, 11))\n    ax = Axis(fig[1, i], width=600, height=600,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[j])\",\n        titlealign=:left)\n    u = j == 1 ? initial_condition : sol.u[j] # sol.u[1] is modified slightly to force the Dirichlet conditions at t = 0\n    tricontourf!(ax, tri, u, levels=0:5:50, colormap=:matter, extendlow=:auto, extendhigh=:auto) # don't need to do u[begin:end-1], since tri doesn't have that extra vertex.\n    tightlimits!(ax)\nend\nresize_to_layout!(fig)\nfig\n\ndiff_eq = DiffusionEquation(mesh, BCs;\n    diffusion_function,\n    initial_condition,\n    final_time)\n\nfvm_prob = FVMProblem(mesh, BCs;\n    diffusion_function=let D = diffusion_function\n        (x, y, t, u, p) -> D(x, y, p)\n    end,\n    initial_condition,\n    final_time)\n\nL = 320.0\ntri = triangulate_rectangle(0, L, 0, L, 100, 100, single_boundary=true)\nmesh = FVMGeometry(tri)\nBCs = BoundaryConditions(mesh, (x, y, t, u, p) -> 2.0, Neumann)\ndiffusion_function = (x, y, p) -> 2.0\ninitf = (x, y) -> begin\n    if 0.4L ≤ y ≤ 0.6L\n        return 1.0\n    else\n        return 0.0\n    end\nend\nfinal_time = 500.0\ninitial_condition = [initf(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)]\nprob = DiffusionEquation(mesh, BCs;\n    diffusion_function,\n    initial_condition,\n    final_time)\n\nsol = solve(prob, Tsit5(); saveat=100.0)\n\nfig = Figure(fontsize=38)\nfor j in eachindex(sol)\n    ax = Axis(fig[1, j], width=600, height=600,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[j])\",\n        titlealign=:left)\n    u = j == 1 ? initial_condition : sol.u[j]\n    tricontourf!(ax, tri, u, levels=0:0.1:1, colormap=:turbo, extendlow=:auto, extendhigh=:auto)\n    tightlimits!(ax)\nend\nresize_to_layout!(fig)\nfig\n\nBCs_prob = BoundaryConditions(mesh, (x, y, t, u, p) -> -4, Neumann)\nfvm_prob = FVMProblem(mesh, BCs_prob;\n    diffusion_function=let D = diffusion_function\n        (x, y, t, u, p) -> D(x, y, p)\n    end,\n    initial_condition,\n    final_time)\nfvm_sol = solve(fvm_prob, TRBDF2(linsolve=KLUFactorization()); saveat=100.0)\n\nfor j in eachindex(fvm_sol)\n    ax = Axis(fig[2, j], width=600, height=600,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(fvm_sol.t[j])\",\n        titlealign=:left)\n    u = j == 1 ? initial_condition : fvm_sol.u[j]\n    tricontourf!(ax, tri, u, levels=0:0.1:1, colormap=:turbo, extendlow=:auto, extendhigh=:auto)\n    tightlimits!(ax)\nend\nresize_to_layout!(fig)\nfig\n\nq = (30.0, 45.0)\nT = jump_and_march(tri, q)\nval = pl_interpolate(prob, T, sol.u[3], q[1], q[2])","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"","category":"page"},{"location":"wyos/diffusion_equations/","page":"Diffusion Equations","title":"Diffusion Equations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"EditURL = \"https://github.com/SciML/FiniteVolumeMethod.jl/tree/main/docs/src/literate_wyos/laplaces_equation.jl\"","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"using DisplayAs #hide\ntc = DisplayAs.withcontext(:displaysize => (15, 80), :limit => true); #hide\nnothing #hide","category":"page"},{"location":"wyos/laplaces_equation/#Laplace's-Equation","page":"Laplace's Equation","title":"Laplace's Equation","text":"","category":"section"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"Pages = [\"laplaces_equation.md\"]","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"Now we consider Laplace's equation. What we produce in this section can also be accessed in FiniteVolumeMethod.LaplacesEquation.","category":"page"},{"location":"wyos/laplaces_equation/#Mathematical-Details","page":"Laplace's Equation","title":"Mathematical Details","text":"","category":"section"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"The mathematical details for this solver are the same as for our Poisson equation example, except with f = 0. The problems being solved are of the form","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"divleftD(vb x)grad uright = 0","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"known as the generalised Laplace equation.[1]","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"[1]: See, for example, this paper by Rangogni and Occhi (1987).","category":"page"},{"location":"wyos/laplaces_equation/#Implementation","page":"Laplace's Equation","title":"Implementation","text":"","category":"section"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"For the implementation, we can reuse a lot of what we had for Poisson's equation, except that we don't need create_rhs_b.","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"using FiniteVolumeMethod, SparseArrays, DelaunayTriangulation, LinearSolve\nconst FVM = FiniteVolumeMethod\nfunction laplaces_equation(mesh::FVMGeometry,\n    BCs::BoundaryConditions,\n    ICs::InternalConditions=InternalConditions();\n    diffusion_function=(x, y, p) -> 1.0,\n    diffusion_parameters=nothing)\n    conditions = Conditions(mesh, BCs, ICs)\n    n = DelaunayTriangulation.num_points(mesh.triangulation)\n    A = zeros(n, n)\n    b = zeros(DelaunayTriangulation.num_points(mesh.triangulation))\n    FVM.triangle_contributions!(A, mesh, conditions, diffusion_function, diffusion_parameters)\n    FVM.boundary_edge_contributions!(A, b, mesh, conditions, diffusion_function, diffusion_parameters)\n    FVM.apply_steady_dirichlet_conditions!(A, b, mesh, conditions)\n    FVM.fix_missing_vertices!(A, b, mesh)\n    Asp = sparse(A)\n    prob = LinearProblem(Asp, b)\n    return prob\nend","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"Now let's test this problem. We consider Laplace's equation on a sector of an annulus, so that[2]","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"beginequation*\nbeginaligned\ngrad^2 u = 1  r   20  theta  pi2 \nu(x 0) = 0  1  x  2 \nu(0 y) = 0  1  y  2 \nu(x y) = 2xy  r = 1 \nu(x y) = left(fracpi2 - arctanfracyxright)arctanfracyx  r = 2\nendaligned\nendequation*","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"[2]: This problem comes from here.","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"To start, we define our mesh. We need to define each part of the annulus separately, which takes some care.","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"using CairoMakie\nlower_x = [1.0, 2.0]\nlower_y = [0.0, 0.0]\nθ = LinRange(0, π / 2, 100)\nouter_arc_x = 2cos.(θ)\nouter_arc_x[end] = 0.0 # must match with left_x\nouter_arc_y = 2sin.(θ)\nleft_x = [0.0, 0.0]\nleft_y = [2.0, 1.0]\ninner_arc_x = cos.(θ) |> reverse!\ninner_arc_x[begin] = 0.0 # must match with left_x\ninner_arc_y = sin.(θ) |> reverse!\nboundary_x = [lower_x, outer_arc_x, left_x, inner_arc_x]\nboundary_y = [lower_y, outer_arc_y, left_y, inner_arc_y]\nboundary_nodes, points = convert_boundary_points_to_indices(boundary_x, boundary_y)\ntri = triangulate(points; boundary_nodes)\nrefine!(tri; max_area=1e-3get_area(tri))\ntriplot(tri)","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"mesh = FVMGeometry(tri)","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"The boundary conditions are defined as follows.","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"lower_f = (x, y, t, u, p) -> 0.0\nouter_arc_f = (x, y, t, u, p) -> (π / 2 - atan(y, x)) * atan(y, x)\nleft_f = (x, y, t, u, p) -> 2x * y\ninner_arc_f = (x, y, t, u, p) -> 2x * y\nbc_f = (lower_f, outer_arc_f, left_f, inner_arc_f)\nbc_types = (Dirichlet, Dirichlet, Dirichlet, Dirichlet)\nBCs = BoundaryConditions(mesh, bc_f, bc_types)","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"Now we can define and solve the problem.","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"prob = laplaces_equation(mesh, BCs, diffusion_function=(x, y, p) -> 1.0)\nprob |> tc #hide","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"sol = solve(prob, KLUFactorization())\nsol |> tc #hide","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"fig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=\"x\", ylabel=\"y\", width=600, height=600)\ntricontourf!(ax, tri, sol.u, levels=0:0.1:1, colormap=:jet)\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"We can turn this type of problem into its corresponding SteadyFVMProblem as follows:","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"initial_condition = zeros(DelaunayTriangulation.num_points(tri))\nFVM.apply_dirichlet_conditions!(initial_condition, mesh, Conditions(mesh, BCs, InternalConditions())) # a good initial guess\nfvm_prob = SteadyFVMProblem(FVMProblem(mesh, BCs;\n    diffusion_function=(x, y, t, u, p) -> 1.0,\n    initial_condition,\n    final_time=Inf))","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"using SteadyStateDiffEq, OrdinaryDiffEq\nfvm_sol = solve(fvm_prob, DynamicSS(TRBDF2()))\nfvm_sol |> tc #hide","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"ax = Axis(fig[1, 2], xlabel=\"x\", ylabel=\"y\", width=600, height=600)\ntricontourf!(ax, tri, fvm_sol.u, levels=0:0.1:1, colormap=:jet)\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"wyos/laplaces_equation/#Using-the-Provided-Template","page":"Laplace's Equation","title":"Using the Provided Template","text":"","category":"section"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"Let's now use the built-in LaplacesEquation which implements the above inside FiniteVolumeMethod.jl. We consider the problem[3]","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"[3]: This is the first example from this paper by Rangogni and Occhi (1987).","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"beginequation*\nbeginaligned\ndivleftD(vb x)grad uright = 00  x  5 0  y  5 \nu(0 y) = 0  0  y  5 \nu(5 y) = 5  0  y  5 \ngrad u vdot vu n = 0  0  x  5 y in 0 5\nendaligned\nendequation*","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"where D(vb x) = (x+1)(y+2). The exact solution is u(x y) = 5log_6(1+x). We define this problem as follows.","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"tri = triangulate_rectangle(0, 5, 0, 5, 100, 100, single_boundary=false)\nmesh = FVMGeometry(tri)\nzero_f = (x, y, t, u, p) -> 0.0\nfive_f = (x, y, t, u, p) -> 5.0\nbc_f = (zero_f, five_f, zero_f, zero_f)\nbc_types = (Neumann, Dirichlet, Neumann, Dirichlet) # bottom, right, top, left\nBCs = BoundaryConditions(mesh, bc_f, bc_types)\ndiffusion_function = (x, y, p) -> (x + 1) * (y + 2)\nprob = LaplacesEquation(mesh, BCs; diffusion_function)","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"sol = solve(prob, KLUFactorization())\nsol |> tc #hide","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"fig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=\"x\", ylabel=\"y\",\n    width=600, height=600,\n    title=\"Numerical\", titlealign=:left)\ntricontourf!(ax, tri, sol.u, levels=0:0.25:5, colormap=:jet)\nax = Axis(fig[1, 2], xlabel=\"x\", ylabel=\"y\",\n    width=600, height=600,\n    title=\"Exact\", titlealign=:left)\nu_exact = [5log(1 + x) / log(6) for (x, y) in DelaunayTriangulation.each_point(tri)]\ntricontourf!(ax, tri, u_exact, levels=0:0.25:5, colormap=:jet)\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"To finish, here is a benchmark comparing this problem to the corresponding SteadyFVMProblem.","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"initial_condition = zeros(DelaunayTriangulation.num_points(tri))\nFVM.apply_dirichlet_conditions!(initial_condition, mesh, Conditions(mesh, BCs, InternalConditions())) # a good initial guess\nfvm_prob = SteadyFVMProblem(FVMProblem(mesh, BCs;\n    diffusion_function=(x, y, t, u, p) -> (x + 1) * (y + 2),\n    final_time=Inf,\n    initial_condition))","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"using BenchmarkTools\n@btime solve($prob, $KLUFactorization());","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"  15.368 ms (56 allocations: 17.12 MiB)","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"@btime solve($fvm_prob, $DynamicSS(TRBDF2(linsolve=KLUFactorization())));","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"  495.417 ms (223001 allocations: 114.30 MiB)","category":"page"},{"location":"wyos/laplaces_equation/#Just-the-code","page":"Laplace's Equation","title":"Just the code","text":"","category":"section"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"using FiniteVolumeMethod, SparseArrays, DelaunayTriangulation, LinearSolve\nconst FVM = FiniteVolumeMethod\nfunction laplaces_equation(mesh::FVMGeometry,\n    BCs::BoundaryConditions,\n    ICs::InternalConditions=InternalConditions();\n    diffusion_function=(x, y, p) -> 1.0,\n    diffusion_parameters=nothing)\n    conditions = Conditions(mesh, BCs, ICs)\n    n = DelaunayTriangulation.num_points(mesh.triangulation)\n    A = zeros(n, n)\n    b = zeros(DelaunayTriangulation.num_points(mesh.triangulation))\n    FVM.triangle_contributions!(A, mesh, conditions, diffusion_function, diffusion_parameters)\n    FVM.boundary_edge_contributions!(A, b, mesh, conditions, diffusion_function, diffusion_parameters)\n    FVM.apply_steady_dirichlet_conditions!(A, b, mesh, conditions)\n    FVM.fix_missing_vertices!(A, b, mesh)\n    Asp = sparse(A)\n    prob = LinearProblem(Asp, b)\n    return prob\nend\n\nusing CairoMakie\nlower_x = [1.0, 2.0]\nlower_y = [0.0, 0.0]\nθ = LinRange(0, π / 2, 100)\nouter_arc_x = 2cos.(θ)\nouter_arc_x[end] = 0.0 # must match with left_x\nouter_arc_y = 2sin.(θ)\nleft_x = [0.0, 0.0]\nleft_y = [2.0, 1.0]\ninner_arc_x = cos.(θ) |> reverse!\ninner_arc_x[begin] = 0.0 # must match with left_x\ninner_arc_y = sin.(θ) |> reverse!\nboundary_x = [lower_x, outer_arc_x, left_x, inner_arc_x]\nboundary_y = [lower_y, outer_arc_y, left_y, inner_arc_y]\nboundary_nodes, points = convert_boundary_points_to_indices(boundary_x, boundary_y)\ntri = triangulate(points; boundary_nodes)\nrefine!(tri; max_area=1e-3get_area(tri))\ntriplot(tri)\n\nmesh = FVMGeometry(tri)\n\nlower_f = (x, y, t, u, p) -> 0.0\nouter_arc_f = (x, y, t, u, p) -> (π / 2 - atan(y, x)) * atan(y, x)\nleft_f = (x, y, t, u, p) -> 2x * y\ninner_arc_f = (x, y, t, u, p) -> 2x * y\nbc_f = (lower_f, outer_arc_f, left_f, inner_arc_f)\nbc_types = (Dirichlet, Dirichlet, Dirichlet, Dirichlet)\nBCs = BoundaryConditions(mesh, bc_f, bc_types)\n\nprob = laplaces_equation(mesh, BCs, diffusion_function=(x, y, p) -> 1.0)\n\nsol = solve(prob, KLUFactorization())\n\nfig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=\"x\", ylabel=\"y\", width=600, height=600)\ntricontourf!(ax, tri, sol.u, levels=0:0.1:1, colormap=:jet)\nresize_to_layout!(fig)\nfig\n\ninitial_condition = zeros(DelaunayTriangulation.num_points(tri))\nFVM.apply_dirichlet_conditions!(initial_condition, mesh, Conditions(mesh, BCs, InternalConditions())) # a good initial guess\nfvm_prob = SteadyFVMProblem(FVMProblem(mesh, BCs;\n    diffusion_function=(x, y, t, u, p) -> 1.0,\n    initial_condition,\n    final_time=Inf))\n\nusing SteadyStateDiffEq, OrdinaryDiffEq\nfvm_sol = solve(fvm_prob, DynamicSS(TRBDF2()))\n\nax = Axis(fig[1, 2], xlabel=\"x\", ylabel=\"y\", width=600, height=600)\ntricontourf!(ax, tri, fvm_sol.u, levels=0:0.1:1, colormap=:jet)\nresize_to_layout!(fig)\nfig\n\ntri = triangulate_rectangle(0, 5, 0, 5, 100, 100, single_boundary=false)\nmesh = FVMGeometry(tri)\nzero_f = (x, y, t, u, p) -> 0.0\nfive_f = (x, y, t, u, p) -> 5.0\nbc_f = (zero_f, five_f, zero_f, zero_f)\nbc_types = (Neumann, Dirichlet, Neumann, Dirichlet) # bottom, right, top, left\nBCs = BoundaryConditions(mesh, bc_f, bc_types)\ndiffusion_function = (x, y, p) -> (x + 1) * (y + 2)\nprob = LaplacesEquation(mesh, BCs; diffusion_function)\n\nsol = solve(prob, KLUFactorization())\n\nfig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=\"x\", ylabel=\"y\",\n    width=600, height=600,\n    title=\"Numerical\", titlealign=:left)\ntricontourf!(ax, tri, sol.u, levels=0:0.25:5, colormap=:jet)\nax = Axis(fig[1, 2], xlabel=\"x\", ylabel=\"y\",\n    width=600, height=600,\n    title=\"Exact\", titlealign=:left)\nu_exact = [5log(1 + x) / log(6) for (x, y) in DelaunayTriangulation.each_point(tri)]\ntricontourf!(ax, tri, u_exact, levels=0:0.25:5, colormap=:jet)\nresize_to_layout!(fig)\nfig\n\ninitial_condition = zeros(DelaunayTriangulation.num_points(tri))\nFVM.apply_dirichlet_conditions!(initial_condition, mesh, Conditions(mesh, BCs, InternalConditions())) # a good initial guess\nfvm_prob = SteadyFVMProblem(FVMProblem(mesh, BCs;\n    diffusion_function=(x, y, t, u, p) -> (x + 1) * (y + 2),\n    final_time=Inf,\n    initial_condition))","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"","category":"page"},{"location":"wyos/laplaces_equation/","page":"Laplace's Equation","title":"Laplace's Equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"wyos/linear_reaction_diffusion_equations/","page":"Linear Reaction-Diffusion Equations","title":"Linear Reaction-Diffusion Equations","text":"EditURL = \"https://github.com/SciML/FiniteVolumeMethod.jl/tree/main/docs/src/literate_wyos/linear_reaction_diffusion_equations.jl\"","category":"page"},{"location":"wyos/linear_reaction_diffusion_equations/","page":"Linear Reaction-Diffusion Equations","title":"Linear Reaction-Diffusion Equations","text":"using DisplayAs #hide\ntc = DisplayAs.withcontext(:displaysize => (15, 80), :limit => true); #hide\nnothing #hide","category":"page"},{"location":"wyos/linear_reaction_diffusion_equations/#Linear-Reaction-Diffusion-Equations","page":"Linear Reaction-Diffusion Equations","title":"Linear Reaction-Diffusion Equations","text":"","category":"section"},{"location":"wyos/linear_reaction_diffusion_equations/","page":"Linear Reaction-Diffusion Equations","title":"Linear Reaction-Diffusion Equations","text":"Pages = [\"linear_reaction_diffusion_equations.md\"]","category":"page"},{"location":"wyos/linear_reaction_diffusion_equations/","page":"Linear Reaction-Diffusion Equations","title":"Linear Reaction-Diffusion Equations","text":"Next, we write a specialised solver for solving linear reaction-diffusion equations. What we produce in this section can also be accessed in FiniteVolumeMethod.LinearReactionDiffusionEquation.","category":"page"},{"location":"wyos/linear_reaction_diffusion_equations/#Mathematical-Details","page":"Linear Reaction-Diffusion Equations","title":"Mathematical Details","text":"","category":"section"},{"location":"wyos/linear_reaction_diffusion_equations/","page":"Linear Reaction-Diffusion Equations","title":"Linear Reaction-Diffusion Equations","text":"To start, let's give the mathematical details. The problems we will be solving take the form","category":"page"},{"location":"wyos/linear_reaction_diffusion_equations/","page":"Linear Reaction-Diffusion Equations","title":"Linear Reaction-Diffusion Equations","text":"pdvut = divleftD(vb x)grad uright + f(vb x)u","category":"page"},{"location":"wyos/linear_reaction_diffusion_equations/","page":"Linear Reaction-Diffusion Equations","title":"Linear Reaction-Diffusion Equations","text":"We want to turn this into an equation of the form mathrm dvb umathrm dt = vb Avb u + vb b as usual. This takes the same form as our diffusion equation example, except with the extra f(vb x)u term, which just adds an exta f(vb x) term to the diagonal of vb A. See the previois sections for further mathematical details.","category":"page"},{"location":"wyos/linear_reaction_diffusion_equations/#Implementation","page":"Linear Reaction-Diffusion Equations","title":"Implementation","text":"","category":"section"},{"location":"wyos/linear_reaction_diffusion_equations/","page":"Linear Reaction-Diffusion Equations","title":"Linear Reaction-Diffusion Equations","text":"Let us now implement the solver. For constructing vb A, we can use FiniteVolumeMethod.triangle_contributions! as in the previous sections, but we will need an extra function to add f(vb x) to the appropriate diagonals. We can also reuse apply_dirichlet_conditions!, apply_dudt_conditions, and boundary_edge_contributions! from the diffusion equation example. Here is our implementation.","category":"page"},{"location":"wyos/linear_reaction_diffusion_equations/","page":"Linear Reaction-Diffusion Equations","title":"Linear Reaction-Diffusion Equations","text":"using FiniteVolumeMethod, SparseArrays, OrdinaryDiffEq, LinearAlgebra\nconst FVM = FiniteVolumeMethod\nfunction linear_source_contributions!(A, mesh, conditions, source_function, source_parameters)\n    for i in each_solid_vertex(mesh.triangulation)\n        if !FVM.has_condition(conditions, i)\n            x, y = get_point(mesh, i)\n            A[i, i] += source_function(x, y, source_parameters)\n        end\n    end\nend\nfunction linear_reaction_diffusion_equation(mesh::FVMGeometry,\n    BCs::BoundaryConditions,\n    ICs::InternalConditions=InternalConditions();\n    diffusion_function,\n    diffusion_parameters=nothing,\n    source_function,\n    source_parameters=nothing,\n    initial_condition,\n    initial_time=0.0,\n    final_time)\n    conditions = Conditions(mesh, BCs, ICs)\n    n = DelaunayTriangulation.num_solid_vertices(mesh.triangulation)\n    Afull = zeros(n + 1, n + 1)\n    A = @views Afull[begin:end-1, begin:end-1]\n    b = @views Afull[begin:end-1, end]\n    _ic = vcat(initial_condition, 1)\n    FVM.triangle_contributions!(A, mesh, conditions, diffusion_function, diffusion_parameters)\n    FVM.boundary_edge_contributions!(A, b, mesh, conditions, diffusion_function, diffusion_parameters)\n    linear_source_contributions!(A, mesh, conditions, source_function, source_parameters)\n    FVM.apply_dudt_conditions!(b, mesh, conditions)\n    FVM.apply_dirichlet_conditions!(_ic, mesh, conditions)\n    FVM.fix_missing_vertices!(A, b, mesh)\n    Af = sparse(Afull)\n    prob = ODEProblem(MatrixOperator(Af), _ic, (initial_time, final_time))\n    return prob\nend","category":"page"},{"location":"wyos/linear_reaction_diffusion_equations/","page":"Linear Reaction-Diffusion Equations","title":"Linear Reaction-Diffusion Equations","text":"If you go and look back at the diffusion_equation function from the diffusion equation example, you will see that this is essentially the same function except we now have linear_source_contributions! and source_function and source_parameters arguments.","category":"page"},{"location":"wyos/linear_reaction_diffusion_equations/","page":"Linear Reaction-Diffusion Equations","title":"Linear Reaction-Diffusion Equations","text":"Let's now test this function. We consider the problem","category":"page"},{"location":"wyos/linear_reaction_diffusion_equations/","page":"Linear Reaction-Diffusion Equations","title":"Linear Reaction-Diffusion Equations","text":"pdvTt = divleft10^-3x^2ygrad Tright + (x-1)(y-1)T quad vb x in 01^2","category":"page"},{"location":"wyos/linear_reaction_diffusion_equations/","page":"Linear Reaction-Diffusion Equations","title":"Linear Reaction-Diffusion Equations","text":"with grad T vdotvu n = 1 on the boundary.","category":"page"},{"location":"wyos/linear_reaction_diffusion_equations/","page":"Linear Reaction-Diffusion Equations","title":"Linear Reaction-Diffusion Equations","text":"using DelaunayTriangulation\ntri = triangulate_rectangle(0, 1, 0, 1, 150, 150, single_boundary=true)\nmesh = FVMGeometry(tri)\nBCs = BoundaryConditions(mesh, (x, y, t, u, p) -> one(x), Neumann)\ndiffusion_function = (x, y, p) -> p.D * x^2 * y\ndiffusion_parameters = (D=1e-3,)\nsource_function = (x, y, p) -> (x - 1) * (y - 1)\ninitial_condition = [x^2 + y^2 for (x, y) in DelaunayTriangulation.each_point(tri)]\nfinal_time = 8.0\nprob = linear_reaction_diffusion_equation(mesh, BCs;\n    diffusion_function, diffusion_parameters,\n    source_function, initial_condition, final_time)\nprob |> tc #hide","category":"page"},{"location":"wyos/linear_reaction_diffusion_equations/","page":"Linear Reaction-Diffusion Equations","title":"Linear Reaction-Diffusion Equations","text":"sol = solve(prob, Tsit5(); saveat=2)\nsol |> tc #hide","category":"page"},{"location":"wyos/linear_reaction_diffusion_equations/","page":"Linear Reaction-Diffusion Equations","title":"Linear Reaction-Diffusion Equations","text":"using CairoMakie\nfig = Figure(fontsize=38)\nfor j in eachindex(sol)\n    ax = Axis(fig[1, j], width=600, height=600,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[j])\")\n    tricontourf!(ax, tri, sol.u[j], levels=0:0.1:1, extendlow=:auto, extendhigh=:auto, colormap=:turbo)\n    tightlimits!(ax)\nend\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"wyos/linear_reaction_diffusion_equations/","page":"Linear Reaction-Diffusion Equations","title":"Linear Reaction-Diffusion Equations","text":"Here is how we could convert this into an FVMProblem. Note that the Neumann boundary conditions are expressed as grad Tvdotvu n = 1 above, but for FVMProblem we need them in the form vb qvdotvu n = ldots. For this problem, vb q=-Dgrad T, which gives vb qvdotvu n = -D.","category":"page"},{"location":"wyos/linear_reaction_diffusion_equations/","page":"Linear Reaction-Diffusion Equations","title":"Linear Reaction-Diffusion Equations","text":"_BCs = BoundaryConditions(mesh, (x, y, t, u, p) -> -p.D(x, y, p.Dp), Neumann;\n    parameters=(D=diffusion_function, Dp=diffusion_parameters))\nfvm_prob = FVMProblem(\n    mesh,\n    _BCs;\n    diffusion_function=let D=diffusion_function\n        (x, y, t, u, p) -> D(x, y, p)\n    end,\n    diffusion_parameters=diffusion_parameters,\n    source_function=let S=source_function\n        (x, y, t, u, p) -> S(x, y, p) * u\n    end,\n    final_time=final_time,\n    initial_condition=initial_condition\n)\nfvm_sol = solve(fvm_prob, Tsit5(), saveat=2.0)\nfvm_sol |> tc #hide","category":"page"},{"location":"wyos/linear_reaction_diffusion_equations/#Using-the-Provided-Template","page":"Linear Reaction-Diffusion Equations","title":"Using the Provided Template","text":"","category":"section"},{"location":"wyos/linear_reaction_diffusion_equations/","page":"Linear Reaction-Diffusion Equations","title":"Linear Reaction-Diffusion Equations","text":"The above code is implemented in LinearReactionDiffusionEquation in FiniteVolumeMethod.jl.","category":"page"},{"location":"wyos/linear_reaction_diffusion_equations/","page":"Linear Reaction-Diffusion Equations","title":"Linear Reaction-Diffusion Equations","text":"prob = LinearReactionDiffusionEquation(mesh, BCs;\n    diffusion_function, diffusion_parameters,\n    source_function,  initial_condition, final_time)\nsol = solve(prob, Tsit5(); saveat=2)\nsol |> tc #hide","category":"page"},{"location":"wyos/linear_reaction_diffusion_equations/","page":"Linear Reaction-Diffusion Equations","title":"Linear Reaction-Diffusion Equations","text":"Here is a benchmark comparison of LinearReactionDiffusionEquation versus FVMProblem.","category":"page"},{"location":"wyos/linear_reaction_diffusion_equations/","page":"Linear Reaction-Diffusion Equations","title":"Linear Reaction-Diffusion Equations","text":"using BenchmarkTools\nusing Sundials\n@btime solve($prob, $CVODE_BDF(linear_solver=:GMRES); saveat=$2);","category":"page"},{"location":"wyos/linear_reaction_diffusion_equations/","page":"Linear Reaction-Diffusion Equations","title":"Linear Reaction-Diffusion Equations","text":"  48.360 ms (1087 allocations: 1.58 MiB)","category":"page"},{"location":"wyos/linear_reaction_diffusion_equations/","page":"Linear Reaction-Diffusion Equations","title":"Linear Reaction-Diffusion Equations","text":"@btime solve($fvm_prob, $CVODE_BDF(linear_solver=:GMRES); saveat=$2);","category":"page"},{"location":"wyos/linear_reaction_diffusion_equations/","page":"Linear Reaction-Diffusion Equations","title":"Linear Reaction-Diffusion Equations","text":"  163.686 ms (83267 allocations: 90.84 MiB)","category":"page"},{"location":"wyos/linear_reaction_diffusion_equations/#Just-the-code","page":"Linear Reaction-Diffusion Equations","title":"Just the code","text":"","category":"section"},{"location":"wyos/linear_reaction_diffusion_equations/","page":"Linear Reaction-Diffusion Equations","title":"Linear Reaction-Diffusion Equations","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"wyos/linear_reaction_diffusion_equations/","page":"Linear Reaction-Diffusion Equations","title":"Linear Reaction-Diffusion Equations","text":"using FiniteVolumeMethod, SparseArrays, OrdinaryDiffEq, LinearAlgebra\nconst FVM = FiniteVolumeMethod\nfunction linear_source_contributions!(A, mesh, conditions, source_function, source_parameters)\n    for i in each_solid_vertex(mesh.triangulation)\n        if !FVM.has_condition(conditions, i)\n            x, y = get_point(mesh, i)\n            A[i, i] += source_function(x, y, source_parameters)\n        end\n    end\nend\nfunction linear_reaction_diffusion_equation(mesh::FVMGeometry,\n    BCs::BoundaryConditions,\n    ICs::InternalConditions=InternalConditions();\n    diffusion_function,\n    diffusion_parameters=nothing,\n    source_function,\n    source_parameters=nothing,\n    initial_condition,\n    initial_time=0.0,\n    final_time)\n    conditions = Conditions(mesh, BCs, ICs)\n    n = DelaunayTriangulation.num_solid_vertices(mesh.triangulation)\n    Afull = zeros(n + 1, n + 1)\n    A = @views Afull[begin:end-1, begin:end-1]\n    b = @views Afull[begin:end-1, end]\n    _ic = vcat(initial_condition, 1)\n    FVM.triangle_contributions!(A, mesh, conditions, diffusion_function, diffusion_parameters)\n    FVM.boundary_edge_contributions!(A, b, mesh, conditions, diffusion_function, diffusion_parameters)\n    linear_source_contributions!(A, mesh, conditions, source_function, source_parameters)\n    FVM.apply_dudt_conditions!(b, mesh, conditions)\n    FVM.apply_dirichlet_conditions!(_ic, mesh, conditions)\n    FVM.fix_missing_vertices!(A, b, mesh)\n    Af = sparse(Afull)\n    prob = ODEProblem(MatrixOperator(Af), _ic, (initial_time, final_time))\n    return prob\nend\n\nusing DelaunayTriangulation\ntri = triangulate_rectangle(0, 1, 0, 1, 150, 150, single_boundary=true)\nmesh = FVMGeometry(tri)\nBCs = BoundaryConditions(mesh, (x, y, t, u, p) -> one(x), Neumann)\ndiffusion_function = (x, y, p) -> p.D * x^2 * y\ndiffusion_parameters = (D=1e-3,)\nsource_function = (x, y, p) -> (x - 1) * (y - 1)\ninitial_condition = [x^2 + y^2 for (x, y) in DelaunayTriangulation.each_point(tri)]\nfinal_time = 8.0\nprob = linear_reaction_diffusion_equation(mesh, BCs;\n    diffusion_function, diffusion_parameters,\n    source_function, initial_condition, final_time)\n\nsol = solve(prob, Tsit5(); saveat=2)\n\nusing CairoMakie\nfig = Figure(fontsize=38)\nfor j in eachindex(sol)\n    ax = Axis(fig[1, j], width=600, height=600,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[j])\")\n    tricontourf!(ax, tri, sol.u[j], levels=0:0.1:1, extendlow=:auto, extendhigh=:auto, colormap=:turbo)\n    tightlimits!(ax)\nend\nresize_to_layout!(fig)\nfig\n\n_BCs = BoundaryConditions(mesh, (x, y, t, u, p) -> -p.D(x, y, p.Dp), Neumann;\n    parameters=(D=diffusion_function, Dp=diffusion_parameters))\nfvm_prob = FVMProblem(\n    mesh,\n    _BCs;\n    diffusion_function=let D=diffusion_function\n        (x, y, t, u, p) -> D(x, y, p)\n    end,\n    diffusion_parameters=diffusion_parameters,\n    source_function=let S=source_function\n        (x, y, t, u, p) -> S(x, y, p) * u\n    end,\n    final_time=final_time,\n    initial_condition=initial_condition\n)\nfvm_sol = solve(fvm_prob, Tsit5(), saveat=2.0)\n\nprob = LinearReactionDiffusionEquation(mesh, BCs;\n    diffusion_function, diffusion_parameters,\n    source_function,  initial_condition, final_time)\nsol = solve(prob, Tsit5(); saveat=2)","category":"page"},{"location":"wyos/linear_reaction_diffusion_equations/","page":"Linear Reaction-Diffusion Equations","title":"Linear Reaction-Diffusion Equations","text":"","category":"page"},{"location":"wyos/linear_reaction_diffusion_equations/","page":"Linear Reaction-Diffusion Equations","title":"Linear Reaction-Diffusion Equations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"EditURL = \"https://github.com/SciML/FiniteVolumeMethod.jl/tree/main/docs/src/literate_tutorials/diffusion_equation_on_a_square_plate.jl\"","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"using DisplayAs #hide\ntc = DisplayAs.withcontext(:displaysize => (15, 80), :limit => true); #hide\nnothing #hide","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/#Diffusion-Equation-on-a-Square-Plate","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"","category":"section"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"This tutorial considers a diffusion equation on a square plate:","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"beginequation*\nbeginaligned\npdvu(vb x t)t = frac19grad^2 u(vb x t)   vb x in Omegat0 6pt\nu(vb x t)  =  0  vb x in partialOmegat06pt\nu(vb x 0) = f(vb x)  vb x in Omega\nendaligned\nendequation*","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"where Omega = 0 2^2 and","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"f(x y) = begincases 50  y leq 1  0  y  1 endcases","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"To solve this problem, the first step is to define the mesh.","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"using FiniteVolumeMethod, DelaunayTriangulation\na, b, c, d = 0.0, 2.0, 0.0, 2.0\nnx, ny = 50, 50\ntri = triangulate_rectangle(a, b, c, d, nx, ny, single_boundary=true)\nmesh = FVMGeometry(tri)","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"This mesh is shown below.","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"using CairoMakie\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"We now need to define the boundary conditions. We have a homogeneous Dirichlet condition:","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"bc = (x, y, t, u, p) -> zero(u)\nBCs = BoundaryConditions(mesh, bc, Dirichlet)","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"We can now define the actual PDE. We start by defining the initial condition and the diffusion function.","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"f = (x, y) -> y ≤ 1.0 ? 50.0 : 0.0\ninitial_condition = [f(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)]\nD = (x, y, t, u, p) -> 1 / 9","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"We can now define the problem:","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"final_time = 0.5\nprob = FVMProblem(mesh, BCs; diffusion_function=D, initial_condition, final_time)","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"Note that in prob, it is not a diffusion function that is used but instead it is a flux function:","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"prob.flux_function","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"When providing diffusion_function, the flux is given by vb q(vb x t alphabetagamma) = (-alpha9 -beta9)^mkern-15mumathsfT, where (alpha beta gamma) defines the approximation to u via u(x y) = alpha x + beta y + gamma so that grad u(vb x t) = (alphabeta)^mkern-15mumathsfT.","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"To now solve the problem, we simply use solve. Note that, in the solve call below, multithreading is enabled by default. (If you don't know what algorithm to consider, do using DifferentialEquations instead and simply call solve(prob, saveat=0.05) so that the algorithm is chosen automatically instead of using Tsit5().)","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"using OrdinaryDiffEq\nsol = solve(prob, Tsit5(), saveat=0.05)\nsol |> tc #hide","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"To visualise the solution, we can use tricontourf! from Makie.jl.","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"fig = Figure(fontsize=38)\nfor (i, j) in zip(1:3, (1, 6, 11))\n    local ax\n    ax = Axis(fig[1, i], width=600, height=600,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[j])\",\n        titlealign=:left)\n    tricontourf!(ax, tri, sol.u[j], levels=0:5:50, colormap=:matter)\n    tightlimits!(ax)\nend\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/#Just-the-code","page":"Diffusion Equation on a Square Plate","title":"Just the code","text":"","category":"section"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"using FiniteVolumeMethod, DelaunayTriangulation\na, b, c, d = 0.0, 2.0, 0.0, 2.0\nnx, ny = 50, 50\ntri = triangulate_rectangle(a, b, c, d, nx, ny, single_boundary=true)\nmesh = FVMGeometry(tri)\n\nusing CairoMakie\nfig, ax, sc = triplot(tri)\nfig\n\nbc = (x, y, t, u, p) -> zero(u)\nBCs = BoundaryConditions(mesh, bc, Dirichlet)\n\nf = (x, y) -> y ≤ 1.0 ? 50.0 : 0.0\ninitial_condition = [f(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)]\nD = (x, y, t, u, p) -> 1 / 9\n\nfinal_time = 0.5\nprob = FVMProblem(mesh, BCs; diffusion_function=D, initial_condition, final_time)\n\nprob.flux_function\n\nusing OrdinaryDiffEq\nsol = solve(prob, Tsit5(), saveat=0.05)\n\nfig = Figure(fontsize=38)\nfor (i, j) in zip(1:3, (1, 6, 11))\n    local ax\n    ax = Axis(fig[1, i], width=600, height=600,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[j])\",\n        titlealign=:left)\n    tricontourf!(ax, tri, sol.u[j], levels=0:5:50, colormap=:matter)\n    tightlimits!(ax)\nend\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"EditURL = \"https://github.com/SciML/FiniteVolumeMethod.jl/tree/main/docs/src/literate_tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system.jl\"","category":"page"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"using DisplayAs #hide\ntc = DisplayAs.withcontext(:displaysize => (15, 80), :limit => true); #hide\nnothing #hide","category":"page"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/#Gray-Scott-Model:-Turing-Patterns-from-a-Coupled-Reaction-Diffusion-System","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"","category":"section"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"In this tutorial, we explore some pattern formation from the Gray-Scott model:","category":"page"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"beginequation\nbeginaligned\npdvut = varepsilon_1grad^2u+b(1-u)-uv^2 \npdvvt = varepsilon_2grad^2 v - dv+uv^2\nendaligned\nendequation","category":"page"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"where u and v are the concentrations of two chemical species. The initial conditions we use are:","category":"page"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"beginalign*\nu(x y 0) = 1 -expleft-80left(x^2 + y^2right)right \nv(x y 0) = expleft-80left(x^2+y^2right)right\nendalign*","category":"page"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"The domain we use is -1 1^2, and we use zero flux boundary conditions.","category":"page"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"using FiniteVolumeMethod, DelaunayTriangulation\ntri = triangulate_rectangle(-1, 1, -1, 1, 200, 200, single_boundary=true)\nmesh = FVMGeometry(tri)","category":"page"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"bc = (x, y, t, (u, v), p) -> zero(u) * zero(v)\nu_BCs = BoundaryConditions(mesh, bc, Neumann)\nv_BCs = BoundaryConditions(mesh, bc, Neumann)","category":"page"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"ε₁ = 0.00002\nε₂ = 0.00001\nb = 0.04\nd = 0.1\nu_q = (x, y, t, α, β, γ, _ε₁) -> (-α[1] * _ε₁, -β[1] * _ε₁)\nv_q = (x, y, t, α, β, γ, _ε₂) -> (-α[2] * _ε₂, -β[2] * _ε₂)\nu_S = (x, y, t, (u, v), _b) -> _b * (1 - u) - u * v^2\nv_S = (x, y, t, (u, v), _d) -> -_d * v + u * v^2\nu_qp = ε₁\nv_qp = ε₂\nu_Sp = b\nv_Sp = d\nu_icf = (x, y) -> 1 - exp(-80 * (x^2 + y^2))\nv_icf = (x, y) -> exp(-80 * (x^ 2 + y^2))\nu_ic = [u_icf(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)]\nv_ic = [v_icf(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)]\nu_prob = FVMProblem(mesh, u_BCs;\n    flux_function=u_q, flux_parameters=u_qp,\n    source_function=u_S, source_parameters=u_Sp,\n    initial_condition=u_ic, final_time=6000.0)\nv_prob = FVMProblem(mesh, v_BCs;\n    flux_function=v_q, flux_parameters=v_qp,\n    source_function=v_S, source_parameters=v_Sp,\n    initial_condition=v_ic, final_time=6000.0)\nprob = FVMSystem(u_prob, v_prob)","category":"page"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"Now that we have our system, we can solve.","category":"page"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"using OrdinaryDiffEq, LinearSolve\nsol = solve(prob, TRBDF2(linsolve=KLUFactorization()), saveat=10.0, parallel=Val(false))\nsol |> tc #hide","category":"page"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"Here is an animation of the solution, looking only at the v variable.","category":"page"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"using CairoMakie\nfig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=L\"x\", ylabel=L\"y\")\ntightlimits!(ax)\ni = Observable(1)\nu = map(i -> reshape(sol.u[i][2, :], 200, 200), i)\nx = LinRange(-1, 1, 200)\ny = LinRange(-1, 1, 200)\nheatmap!(ax, x, y, u, colorrange=(0.0, 0.4))\nhidedecorations!(ax)\nrecord(fig, joinpath(@__DIR__, \"../figures\", \"gray_scott_patterns.mp4\"), eachindex(sol);\n    framerate=60) do _i\n    i[] = _i\nend","category":"page"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"(Image: Animation of the Gray-Scott model)","category":"page"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/#Just-the-code","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Just the code","text":"","category":"section"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"using FiniteVolumeMethod, DelaunayTriangulation\ntri = triangulate_rectangle(-1, 1, -1, 1, 200, 200, single_boundary=true)\nmesh = FVMGeometry(tri)\n\nbc = (x, y, t, (u, v), p) -> zero(u) * zero(v)\nu_BCs = BoundaryConditions(mesh, bc, Neumann)\nv_BCs = BoundaryConditions(mesh, bc, Neumann)\n\nε₁ = 0.00002\nε₂ = 0.00001\nb = 0.04\nd = 0.1\nu_q = (x, y, t, α, β, γ, _ε₁) -> (-α[1] * _ε₁, -β[1] * _ε₁)\nv_q = (x, y, t, α, β, γ, _ε₂) -> (-α[2] * _ε₂, -β[2] * _ε₂)\nu_S = (x, y, t, (u, v), _b) -> _b * (1 - u) - u * v^2\nv_S = (x, y, t, (u, v), _d) -> -_d * v + u * v^2\nu_qp = ε₁\nv_qp = ε₂\nu_Sp = b\nv_Sp = d\nu_icf = (x, y) -> 1 - exp(-80 * (x^2 + y^2))\nv_icf = (x, y) -> exp(-80 * (x^ 2 + y^2))\nu_ic = [u_icf(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)]\nv_ic = [v_icf(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)]\nu_prob = FVMProblem(mesh, u_BCs;\n    flux_function=u_q, flux_parameters=u_qp,\n    source_function=u_S, source_parameters=u_Sp,\n    initial_condition=u_ic, final_time=6000.0)\nv_prob = FVMProblem(mesh, v_BCs;\n    flux_function=v_q, flux_parameters=v_qp,\n    source_function=v_S, source_parameters=v_Sp,\n    initial_condition=v_ic, final_time=6000.0)\nprob = FVMSystem(u_prob, v_prob)\n\nusing OrdinaryDiffEq, LinearSolve\nsol = solve(prob, TRBDF2(linsolve=KLUFactorization()), saveat=10.0, parallel=Val(false))\n\nusing CairoMakie\nfig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=L\"x\", ylabel=L\"y\")\ntightlimits!(ax)\ni = Observable(1)\nu = map(i -> reshape(sol.u[i][2, :], 200, 200), i)\nx = LinRange(-1, 1, 200)\ny = LinRange(-1, 1, 200)\nheatmap!(ax, x, y, u, colorrange=(0.0, 0.4))\nhidedecorations!(ax)\nrecord(fig, joinpath(@__DIR__, \"../figures\", \"gray_scott_patterns.mp4\"), eachindex(sol);\n    framerate=60) do _i\n    i[] = _i\nend","category":"page"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"","category":"page"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/overview/#Section-Overview","page":"Section Overview","title":"Section Overview","text":"","category":"section"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"Pages = [\"overview.md\"]","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"We provide many tutorials in this section. Each tutorial is self-contained, although  more detail will be offered in the earlier examples. At the end of each tutorial we show the uncommented code, but if you want to see the actual script itself that generates these tutorials, then click on the Edit on GitHub section on the top right of the respective tutorial.","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"We list all the examples below, but the tutorials can be accessed in their respective sections of the sidebar.","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"Note that this tutorial covers problems of the form partial upartial_t + divvb q = S, and converting problems into this form. For an explanation of how to use the templates we provide for specific problems, e.g. the diffusion equation, see the Solvers for Specific Problems, and Writing Your Own section.","category":"page"},{"location":"tutorials/overview/#Diffusion-Equation-on-a-Square-Plate","page":"Section Overview","title":"Diffusion Equation on a Square Plate","text":"","category":"section"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"This tutorial considers a diffusion equation problem on a square plate:","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"beginequation*\nbeginaligned\npdvu(vb x t)t = frac19grad^2 u(vb x t)   vb x in Omegat0 6pt\nu(vb x t)  =  0  vb x in partialOmegat06pt\nu(vb x 0) = f(vb x)  vb x in Omega\nendaligned\nendequation*","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"where Omega = 0 2^2 and","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"f(x y) = begincases 50  y leq 1  0  y  1 endcases","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"This problem actually has an exact solution, given by[1]","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"u(vb x t) = frac200pi^2sum_m=1^inftysum_n=1^infty fracleft1 + (-1)^m+1rightleft1-cosleft(fracnpi2right)rightmnsinleft(fracmpi x2right)sinleft(fracnpi y2right)mathrme^-frac136pi^2(m^2+n^2)t","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"although we do not refer to this in the tutorial (only in the tests).","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"[1]: See here for a derivation.","category":"page"},{"location":"tutorials/overview/#Diffusion-Equation-in-a-Wedge-with-Mixed-Boundary-Conditions","page":"Section Overview","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"","category":"section"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"This tutorial considers a similar example as in the first example, except now the diffusion is in a wedge, has mixed boundary conditions, and is also now in polar coordinates:","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"beginequation*\nbeginaligned\npdvu(r theta t)t = grad^2u(rthetat)  0r10thetaalphat06pt\npdvu(r 0 t)theta  = 0  0r1t06pt\nu(1 theta t) = 0  0thetaalphat06pt\npdvu(ralphat)theta  = 0  0thetaalphat06pt\nu(r theta 0) = f(rtheta)  0r10thetaalpha\nendaligned\nendequation*","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"where we take f(rtheta) = 1-r and alpha=pi4. This problem also has an exact solution:[2]","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"u(r theta t) = frac12sum_m=1^infty A_0 mmathrme^-zeta_0 m^2tJ_0(zeta_0 mr) + sum_n=1^inftysum_m=1^infty A_n mmathrme^-zeta_nm^2tJ_npialphaleft(zeta_npialphamrright)cosleft(fracnpithetaalpharight)","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"where","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"A_n m = frac4alpha J_npialpha+1^2left(zeta_npialphamright)int_0^1int_0^alpha f(r theta)J_npialphaleft(zeta_npialphamrright)cosleft(fracnpithetaalpharight) rddrddtheta","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"for n=012ldots and m=123ldots, and where we write the roots of J_mu, the muth order Bessel function of the first kind, as 0  zeta_mu 1  zeta_mu 2  cdots with zeta_mu m to infty as m to infty. We don't discuss this in the tutorial, but it is used in the tests.","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"[2]: To derive this, use u(r theta t) = mathrme^-lambda tv(r theta) and use separation of variables.","category":"page"},{"location":"tutorials/overview/#Reaction-Diffusion-Equation-with-a-Time-dependent-Dirichlet-Boundary-Condition-on-a-Disk","page":"Section Overview","title":"Reaction Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"","category":"section"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"This tutorial considers a reaction-diffusion problem with a mathrm dumathrm dt condition on a disk in polar coordinates:","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"beginequation*\nbeginaligned\npdvu(r theta t)t = divugrad u + u(1-u)  0r1theta2pi6pt\ndvu(1 theta t)t = u(1thetat)  0theta2pit06pt\nu(rtheta0) = sqrtI_0(sqrt2r)  0r10theta2pi\nendaligned\nendequation*","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"where I_0 is the modified Bessel function of the first kind of order zero. This problem also has an exact solution,[3]","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"u(r theta t) = mathrme^tsqrtI_0(sqrt2r)","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"that we use in the tests.","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"[3]: See Bokhari et al. (2008) for a derivation.","category":"page"},{"location":"tutorials/overview/#Porous-Medium-Equation","page":"Section Overview","title":"Porous-Medium Equation","text":"","category":"section"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"This tutorial considers the porous-medium equation, given by ","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"beginequationlabeleqporousmedium\npdvut = Ddiv u^m-1grad u\nendequation","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"with initial condition u(vb x 0) = Mdelta(vb x) where delta(vb x) is the Dirac delta function and M = iint_mathbb R^2 u(vb x t)ddA. This problem also has an exact solution that we use for defining an approximation to mathbb R^2 when solving this numerically:[4]","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"beginequationlabeleqporousmediumexact\nu(vb x t) = begincases (Dt)^-1mleftleft(fracM4piright)^(m-1)m-fracm-14mleft(x^2+y^2right)(Dt)^-1mright^1(m-1)  x^2+y^2  R_m M(Dt) \n0  x^2+y^2 geq R_m M(Dt) endcases\nendequation","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"where R_m M = 4m(m-1)M(4pi)^(m-1)m.","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"[4]: This exact solution is derived in Section 17.5 of the book The porous medium equation: Mathematical theory by J. L. Vázquez (2007).","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"We also consider a similar problem to \\eqref{eq:porousmedium}, where now the problem has a linear source:","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"pdvut = Ddiv u^m-1grad u + lambda u quad lambda  0","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"which has an exact solution given by","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"u(vb x t) = mathrme^lambda tvleft(vb x fracDlambda(m-1)leftmathrme^lambda(m-1)t-1rightright)","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"where v is the exact solution from \\eqref{eq:porousmediumexact} except with D=1.","category":"page"},{"location":"tutorials/overview/#Porous-Fisher-Equation-and-Travelling-Waves","page":"Section Overview","title":"Porous-Fisher Equation and Travelling Waves","text":"","category":"section"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"This tutorial looks at the Porous-Fisher equation,","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"beginequation*\nbeginaligned\npdvu(vb x t)t = D divugrad u + lambda u(1-u)  0xa0ybt06pt\nu(x 0 t)  =  1  0xat06pt\nu(x b t)  =  0  0xat06pt\npdvu(0 y t)x = 0  0ybt06pt\npdvu(a y t)x = 0  0  y  bt06pt\nu(vb x 0)  = f(y)  0 leq x leq a 0 leq  yleq b\nendaligned\nendequation*","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"We solve this problem and also compare it to known travelling wave solutions.","category":"page"},{"location":"tutorials/overview/#Piecewise-Linear-and-Natural-Neighbour-Interpolation-for-an-Advection-Diffusion-Equation","page":"Section Overview","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"","category":"section"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"This tutorial looks at how we can apply interpolation to solutions from the PDEs discussed, making use of NaturalNeighbours.jl for this purpose. To demonstrate this, we use a two-dimensional advection equation of the form","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"pdvut = Dpdv2ux + Dpdv2uy - nupdvux","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"defined for vb x in mathbb R^2 and u(vb x 0) = delta(vb x), where delta is the Dirac delta function, and with homogeneous  Dirichlet conditions. This problem has an exact solution, given by[5]","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"u(vb x t) = frac14Dpi texpleft(frac-(x-nu t)^2-y^24Dtright)","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"[5]: A derivation is given here.","category":"page"},{"location":"tutorials/overview/#Helmholtz-Equation-with-Inhomogeneous-Boundary-Conditions","page":"Section Overview","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"","category":"section"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"This tutorial considers the Helmholtz equation with inhomogeneous boundary conditions:","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"beginequation\nbeginaligned\ngrad^2 u(vb x) + u(vb x) = 0  vb x in -1 1^2 \npdvuvb n = 1  vb x inpartial-11^2\nendaligned\nendequation","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"This is different to the other problems considered thus far as the problem is now a steady state problem. The exact solution is","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"u(x y) = -fraccos(x+1)+cos(1-x)+cos(y+1)+cos(1-y)sin(2)","category":"page"},{"location":"tutorials/overview/#Laplace's-Equation-with-Internal-Dirichlet-Conditions","page":"Section Overview","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"","category":"section"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"This tutorial considers Laplace's equation with internal Dirichlet conditions:","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"beginequation\nbeginaligned\ngrad^2 u = 0  vb x in 0 1^2  \nu(0 y) = 100y  0 leq y leq 1 \nu(1 y) = 100y  0 leq y leq 1 \nu(x 0) = 0  0 leq x leq 1 \nu(x 1) = 100  0 leq x leq 1 \nu(12 y) = 0  0 leq y leq 25\nendaligned\nendequation","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"This last condition u(12 y) = 0 is the internal condition that needs to be dealt with.","category":"page"},{"location":"tutorials/overview/#Equilibrium-Temperature-Distribution-with-Mixed-Boundary-Conditions-and-using-EnsembleProblems","page":"Section Overview","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"","category":"section"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"This tutorial considers the equilibrium temperature distribution in a square plate with mixed boundary conditions:","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"beginequation\nbeginaligned\ngrad^2 T = 0  vb x in Omega \ngrad T vdot vu n = 0  vb x in Gamma_1 \nT = 40  vb x in Gamma_2 \nkgrad T vdot vu n = h(T_infty - T)  vb x in Gamma_3 \nT = 70  vb x in Gamma_4 \nendaligned\nendequation","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"This domain Omega with boundary partialOmega=Gamma_1cupGamma_2cupGamma_3cupGamma_4 is shown below. For this tutorial, we also consider how varying T_infty affects the results, using interpolation and EnsembleProblems to study this efficiently.","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"using CairoMakie\nA = (0.0, 0.06)\nB = (0.03, 0.06)\nF = (0.03, 0.05)\nG = (0.05, 0.03)\nC = (0.06, 0.03)\nD = (0.06, 0.0)\nE = (0.0, 0.0)\nfig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=\"x\", ylabel=\"y\")\nlines!(ax, [A, E, D], color=:red, linewidth=5)\nlines!(ax, [B, F, G, C], color=:blue, linewidth=5)\nlines!(ax, [C, D], color=:black, linewidth=5)\nlines!(ax, [A, B], color=:magenta, linewidth=5)\ntext!(ax, [(0.03, 0.001)], text=L\"\\Gamma_1\", fontsize=44)\ntext!(ax, [(0.055, 0.01)], text=L\"\\Gamma_2\", fontsize=44)\ntext!(ax, [(0.04, 0.04)], text=L\"\\Gamma_3\", fontsize=44)\ntext!(ax, [(0.015, 0.053)], text=L\"\\Gamma_4\", fontsize=44)\ntext!(ax, [(0.001, 0.03)], text=L\"\\Gamma_1\", fontsize=44)","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"fig #hide","category":"page"},{"location":"tutorials/overview/#A-Reaction-Diffusion-Brusselator-System-of-PDEs","page":"Section Overview","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"","category":"section"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"In this tutorial we consider the following system:","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"beginequation\nbeginaligned\npdvPhit = frac14grad^2 Phi + Phi^2Psi - 2Phi \npdvPsit = frac14grad^2 Psi - Phi^2Psi + Phi\nendaligned quad vb x in 0 1^2\nendequation","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"which has a solution[6]","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"beginequationlabeleqbrusleexct\nbeginaligned\nPhi(x y t) =exp(-x-y-t2) \nPsi(x y t) = exp(x+y+t2)\nendaligned\nendequation","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"We use this exact solution to define the initial condition and Neumann boundary conditions.","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"[6]: See Islam, Ali, and Haq (2010).","category":"page"},{"location":"tutorials/overview/#Gray-Scott-Model:-Turing-Patterns-from-a-Coupled-Reaction-Diffusion-System","page":"Section Overview","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"","category":"section"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"In this tutorial we consider the Gray-Scott model, given by","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"beginequation\nbeginaligned\npdvut = varepsilon_1grad^2u+b(1-u)-uv^2 \npdvvt = varepsilon_2grad^2 v - dv+uv^2\nendaligned\nendequation","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"with zero flux boundary conditions. We use this example to explore how changing parameters slightly leads to some amazing patterns, known as Turing patterns.[7]","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"[7]: There are many papers discussing this. See, e.g., Gandy and Nelson (2022) for a recent paper. The parameter values we use come from this Chebfun example.","category":"page"},{"location":"tutorials/overview/#Diffusion-Equation-on-an-Annulus","page":"Section Overview","title":"Diffusion Equation on an Annulus","text":"","category":"section"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"In this tutorial we consider the diffusion equation on an annulus:[8]","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"beginequation\nbeginaligned\npdvu(vb x t)t = grad^2 u(vb x t)  vb x in Omega \ngrad u(vb x t) vdot vu n(vb x) = 0  vb x in mathcal D(0 1) \nu(vb x t) = c(t)  vb x in mathcal D(002) \nu(vb x t) = u_0(vb x)\nendaligned\nendequation","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"demonstrating how we can solve PDEs over multiply-connected domains. Here, mathcal D(0 r) is a circle of radius r centered at the origin,  Omega is the annulus between mathcal D(002) and mathcal D(0 1), c(t) = 501-mathrme^-t2, and ","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"u_0(x) = 10mathrme^-25leftleft(x+frac12right)^2+left(y+frac12right)^2right - 10mathrme^-45leftleft(x-frac12right)^2+left(y-frac12right)^2right - 5mathrme^-50leftleft(x+frac310right)^2+left(y+frac12right)^2right","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"We also use this tutorial as an opportunity to give an example of  performing natural neighbour interpolation on a multiply-connected domain.","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"[8]: This example comes from here.","category":"page"},{"location":"tutorials/overview/#Mean-Exit-Time","page":"Section Overview","title":"Mean Exit Time","text":"","category":"section"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"In this tutorial, we consider mean time problems. The main problem we consider is that of mean exit time on a compound disk:[9]","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"beginequation\nbeginaligned\nD_1grad^2 T^(1)(vb x) = -1  0  r  mathcal R_1(theta) \nD_2grad^2 T^(2)(vb x) = -1  mathcal R_1(theta)  r  R_2(theta) \nT^(1)(mathcal R_1(theta)theta) = T^(2)(mathcal R_1(theta)theta) \nD_1grad T^(1)(mathcal R_1(theta) theta) vdot vu n(theta) = D_2grad T^(2)(mathcal R_1(theta) theta) vdot vu n(theta) \nT^(2)(R_2 theta) = 0 \nendaligned\nendequation","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"with a perturbed interface mathcal R_1(theta) = R_1(1+varepsilon g(theta)), g(theta)=sin(3theta)+cos(5theta). The conditions at the interface are needed to enforce continuity. The variable T^(1) is the mean exit time in 0  r  mathcal R_1(theta), and T^(2) is the mean exit time in mathcal R_1(theta)  r  R_2(theta). The end of this tutorial also considers mean exit time with obstacles and internal conditions.","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"[9]: This problem comes from Carr et al. (2022).","category":"page"},{"location":"tutorials/overview/#Solving-Mazes-with-Laplace's-Equation","page":"Section Overview","title":"Solving Mazes with Laplace's Equation","text":"","category":"section"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"In this tutorial, we consider solving mazes using Laplace's equation, applying the result of Conolly, Burns, and Weis (1990). In particular, given a maze mathcal M, represented as a collection of edges together with some starting point mathcal S_1 and an endpoint mathcal S_2, Laplace's equation can be used to find the solution:","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"beginequation\nbeginaligned\ngrad^2 phi = 0  vb x in mathcal M \nphi = 0  vb x in mathcal S_1 \nphi = 1  vb x in mathcal S_2 \ngradphivdotvu n = 0  vb x in partial M setminus (mathcal S_1 cup mathcal S_2)\nendaligned\nendequation","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"The solution can then be found by looking at the potential gradphi.","category":"page"},{"location":"tutorials/overview/#Keller-Segel-Model-of-Chemotaxis","page":"Section Overview","title":"Keller-Segel Model of Chemotaxis","text":"","category":"section"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"In this tutorial, we consider the following Keller-Segel model of chemotaxis:[10]","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"beginequation*\nbeginaligned\npdvut = grad^2u - div left(fraccu1+u^2grad vright) + u(1-u) \npdvvt = Dgrad^2 v + u - av\nendaligned\nendequation*","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"inside the square 0 100^2 with homogeneous Neumann boundary conditions.","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"[10]: This example comes from VisualPDE.","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"EditURL = \"https://github.com/SciML/FiniteVolumeMethod.jl/tree/main/docs/src/literate_tutorials/porous_medium_equation.jl\"","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"using DisplayAs #hide\ntc = DisplayAs.withcontext(:displaysize => (15, 80), :limit => true); #hide\nnothing #hide","category":"page"},{"location":"tutorials/porous_medium_equation/#Porous-Medium-Equation","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"","category":"section"},{"location":"tutorials/porous_medium_equation/#No-source","page":"Porous-Medium Equation","title":"No source","text":"","category":"section"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"In this tutorial, we consider the porous-medium equation, given by","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"pdvut = Ddivu^m-1grad u","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"with initial condition u(vb x 0) = Mdelta(vb x) where delta(vb x) is the Dirac delta function and M = iint_mathbb R^2 u(vb x t) ddA. The diffusion function for this problem is D(vb x t u) = Du^m-1. To approximate delta(vb x), we use","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"delta(vb x) approx g(vb x) = frac1varepsilon^2piexpleft-frac1varepsilon^2left(x^2 + y^2right)right","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"taking varepsilon = 01. It can be shown[1] that u(vb x t) is zero for x^2 + y^2 geq R_m M(Dt)^1m, where","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"R_m M = left(frac4mm-1right)leftfracM4piright^(m-1)m","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"so we can replace the domain mathbb R^2 with the domain Omega = -L L^2 where L = R_m M^12(DT)^12m and T is the time that we solve up. We use a Dirichlet boundary condition on partialOmega.","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"[1]: This comes from the exact solution that we define in the overview.","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"Let us now solve this problem, taking m = 2, M = 037, D = 253, and T = 12.","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"using DelaunayTriangulation, FiniteVolumeMethod\n\n# Step 0: Define all the parameters\nm = 2\nM = 0.37\nD = 2.53\nfinal_time = 12.0\nε = 0.1\n# Step 1: Define the mesh\nRmM = 4m / (m - 1) * (M / (4π))^((m - 1) / m)\nL = sqrt(RmM) * (D * final_time)^(1 / (2m))\ntri = triangulate_rectangle(-L, L, -L, L, 125, 125, single_boundary=true)\nmesh = FVMGeometry(tri)","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"# Step 2: Define the boundary conditions\nBCs = BoundaryConditions(mesh, (x, y, t, u, p) -> zero(u), Dirichlet)","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"# Step 3: Define the actual PDE\nf = (x, y) -> M * 1 / (ε^2 * π) * exp(-1 / (ε^2) * (x^2 + y^2))\ndiffusion_function = (x, y, t, u, p) -> p[1] * u^(p[2] - 1)\ndiffusion_parameters = (D, m)\ninitial_condition = [f(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)]\nprob = FVMProblem(mesh, BCs;\n    diffusion_function,\n    diffusion_parameters,\n    initial_condition,\n    final_time)","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"# Step 4: Solve\nusing LinearSolve, OrdinaryDiffEq\nsol = solve(prob, TRBDF2(linsolve=KLUFactorization()); saveat=3.0)\nsol |> tc #hide","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"# Step 5: Visualise\nusing CairoMakie\nfig = Figure(fontsize=38)\nfor (i, j) in zip(1:3, (1, 3, 5))\n    ax = Axis(fig[1, i], width=600, height=600,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[j])\",\n        titlealign=:left)\n    tricontourf!(ax, tri, sol.u[j], levels=0:0.005:0.05, colormap=:matter, extendhigh=:auto)\n    tightlimits!(ax)\nend\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/porous_medium_equation/#Linear-source","page":"Porous-Medium Equation","title":"Linear source","text":"","category":"section"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"Let us now extend the problem above so that a linear source is now included:","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"pdvut = Ddiv u^m-1grad u + lambda u quad lambda  0","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"We again let the initial condition be u(vb x 0) = Mdelta(vb x). For the domain, we use","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"Omega = left-R_m M^12tau(T)^12m R_mM^12tau(T)^12mright^2","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"where","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"tau(T) = fracDlambda(m-1)leftmathrme^lambda(m-1)T-1right","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"The code below solves this problem.","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"# Step 0: Define all the parameters\nm = 3.4\nM = 2.3\nD = 0.581\nλ = 0.2\nfinal_time = 10.0\nε = 0.1\n# Step 1: Define the mesh\nRmM = 4m / (m - 1) * (M / (4π))^((m - 1) / m)\nL = sqrt(RmM) * (D / (λ * (m - 1)) * (exp(λ * (m - 1) * final_time) - 1))^(1 / (2m))\ntri = triangulate_rectangle(-L, L, -L, L, 125, 125, single_boundary=true)\nmesh = FVMGeometry(tri)","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"# Step 2: Define the boundary conditions\nbc = (x, y, t, u, p) -> zero(u)\ntype = Dirichlet\nBCs = BoundaryConditions(mesh, bc, type)","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"# Step 3: Define the actual PDE\nf = (x, y) -> M * 1 / (ε^2 * π) * exp(-1 / (ε^2) * (x^2 + y^2))\ndiffusion_function = (x, y, t, u, p) -> p.D * abs(u)^(p.m - 1)\nsource_function = (x, y, t, u, λ) -> λ * u\ndiffusion_parameters = (D=D, m=m)\nsource_parameters = λ\ninitial_condition = [f(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)]\nprob = FVMProblem(mesh, BCs;\n    diffusion_function,\n    diffusion_parameters,\n    source_function,\n    source_parameters,\n    initial_condition,\n    final_time)","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"# Step 4: Solve\nsol = solve(prob, TRBDF2(linsolve=KLUFactorization()); saveat=2.5)\nsol |> tc #hide","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"# Step 5: Visualise\nfig = Figure(fontsize=38)\nfor (i, j) in zip(1:3, (1, 3, 5))\n    ax = Axis(fig[1, i], width=600, height=600,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[j])\",\n        titlealign=:left)\n    tricontourf!(ax, tri, sol.u[j], levels=0:0.05:1, extendlow=:auto, colormap=:matter, extendhigh=:auto)\n    tightlimits!(ax)\nend\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/porous_medium_equation/#Just-the-code","page":"Porous-Medium Equation","title":"Just the code","text":"","category":"section"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"using DelaunayTriangulation, FiniteVolumeMethod\n\n# Step 0: Define all the parameters\nm = 2\nM = 0.37\nD = 2.53\nfinal_time = 12.0\nε = 0.1\n# Step 1: Define the mesh\nRmM = 4m / (m - 1) * (M / (4π))^((m - 1) / m)\nL = sqrt(RmM) * (D * final_time)^(1 / (2m))\ntri = triangulate_rectangle(-L, L, -L, L, 125, 125, single_boundary=true)\nmesh = FVMGeometry(tri)\n\n# Step 2: Define the boundary conditions\nBCs = BoundaryConditions(mesh, (x, y, t, u, p) -> zero(u), Dirichlet)\n\n# Step 3: Define the actual PDE\nf = (x, y) -> M * 1 / (ε^2 * π) * exp(-1 / (ε^2) * (x^2 + y^2))\ndiffusion_function = (x, y, t, u, p) -> p[1] * u^(p[2] - 1)\ndiffusion_parameters = (D, m)\ninitial_condition = [f(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)]\nprob = FVMProblem(mesh, BCs;\n    diffusion_function,\n    diffusion_parameters,\n    initial_condition,\n    final_time)\n\n# Step 4: Solve\nusing LinearSolve, OrdinaryDiffEq\nsol = solve(prob, TRBDF2(linsolve=KLUFactorization()); saveat=3.0)\n\n# Step 5: Visualise\nusing CairoMakie\nfig = Figure(fontsize=38)\nfor (i, j) in zip(1:3, (1, 3, 5))\n    ax = Axis(fig[1, i], width=600, height=600,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[j])\",\n        titlealign=:left)\n    tricontourf!(ax, tri, sol.u[j], levels=0:0.005:0.05, colormap=:matter, extendhigh=:auto)\n    tightlimits!(ax)\nend\nresize_to_layout!(fig)\nfig\n\n# Step 0: Define all the parameters\nm = 3.4\nM = 2.3\nD = 0.581\nλ = 0.2\nfinal_time = 10.0\nε = 0.1\n# Step 1: Define the mesh\nRmM = 4m / (m - 1) * (M / (4π))^((m - 1) / m)\nL = sqrt(RmM) * (D / (λ * (m - 1)) * (exp(λ * (m - 1) * final_time) - 1))^(1 / (2m))\ntri = triangulate_rectangle(-L, L, -L, L, 125, 125, single_boundary=true)\nmesh = FVMGeometry(tri)\n\n# Step 2: Define the boundary conditions\nbc = (x, y, t, u, p) -> zero(u)\ntype = Dirichlet\nBCs = BoundaryConditions(mesh, bc, type)\n\n# Step 3: Define the actual PDE\nf = (x, y) -> M * 1 / (ε^2 * π) * exp(-1 / (ε^2) * (x^2 + y^2))\ndiffusion_function = (x, y, t, u, p) -> p.D * abs(u)^(p.m - 1)\nsource_function = (x, y, t, u, λ) -> λ * u\ndiffusion_parameters = (D=D, m=m)\nsource_parameters = λ\ninitial_condition = [f(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)]\nprob = FVMProblem(mesh, BCs;\n    diffusion_function,\n    diffusion_parameters,\n    source_function,\n    source_parameters,\n    initial_condition,\n    final_time)\n\n# Step 4: Solve\nsol = solve(prob, TRBDF2(linsolve=KLUFactorization()); saveat=2.5)\n\n# Step 5: Visualise\nfig = Figure(fontsize=38)\nfor (i, j) in zip(1:3, (1, 3, 5))\n    ax = Axis(fig[1, i], width=600, height=600,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[j])\",\n        titlealign=:left)\n    tricontourf!(ax, tri, sol.u[j], levels=0:0.05:1, extendlow=:auto, colormap=:matter, extendhigh=:auto)\n    tightlimits!(ax)\nend\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"EditURL = \"https://github.com/SciML/FiniteVolumeMethod.jl/tree/main/docs/src/literate_tutorials/porous_fisher_equation_and_travelling_waves.jl\"","category":"page"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"using DisplayAs #hide\ntc = DisplayAs.withcontext(:displaysize => (15, 80), :limit => true); #hide\nnothing #hide","category":"page"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/#Porous-Fisher-Equation-and-Travelling-Waves","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"","category":"section"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"This tutorial considers a more involved example, where we discuss travelling wave solutions of a Porous-Fisher equation:","category":"page"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"beginequation*\nbeginaligned\npdvu(vb x t)t = D divugrad u + lambda u(1-u)  0xa0ybt06pt\nu(x 0 t)  =  1  0xat06pt\nu(x b t)  =  0  0xat06pt\npdvu(0 y t)x = 0  0ybt06pt\npdvu(a y t)x = 0  0  y  bt06pt\nu(vb x 0)  = f(y)  0 leq x leq a 0 leq  yleq b\nendaligned\nendequation*","category":"page"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"This problem is defined on the rectangle 0 a times 0 b and we assume that b gg a so that the rectangle is much taller than it is wide. This problem has u ranging from u=1 at the bottom of the rectangle down to u=0 at the top on the rectangle, and with zero flux conditions on the two vertical walls. We take the initial condition f to be independent of x. This setup implies that the solution along each constant line x=x_0 should be about the same, i.e. the problem is invariant in x. If indeed we have u(vb x t) = u(y t) then the PDE becomes","category":"page"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"beginequationlabeleqonedproblem\npdvu(y t)t = Dpdvyleft(updvuyright) + lambda u(1-u)\nendequation","category":"page"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"which has travelling wave solutions. Following the analysis given in Section 13.4 of the book Mathematical biology I: An introduction by J. D. Murray (2002), we can show that a travelling wave solution to the one-dimensional problem \\eqref{eq:onedproblem} is given by","category":"page"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"beginequationlabeleqonedproblemexact\nu(y t) = begincases 1-mathrme^c_minz  z leq 0  0  z  0 endcases\nendequation","category":"page"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"where c_min = sqrtlambda(2D), c = sqrtDlambda2, and z = x-ct is the travelling wave coordinates. This travelling wave would mathc our problem exactly if the rectangle were instead 0 a times mathbb R, but by choosing b large enough we can at least emulate the travelling wave behaviour closely; the homogeneous Neumann conditions are to ensure no energy is lost, thus allowing the travelling waves to exist. Moreover, note that the approximations of the solution with u(y t) in \\eqref{eq:onedproblemexact} will only be accurate for large time as it takes the solution some time to evolve towards the travelling wave solution.","category":"page"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"Now with this preamble out of the way, let us solve this problem.","category":"page"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"using DelaunayTriangulation, FiniteVolumeMethod, OrdinaryDiffEq, LinearSolve\na, b, c, d, nx, ny = 0.0, 3.0, 0.0, 40.0, 60, 80\ntri = triangulate_rectangle(a, b, c, d, nx, ny; single_boundary=false)\nmesh = FVMGeometry(tri)\none_bc = (x, y, t, u, p) -> one(u)\nzero_bc = (x, y, t, u, p) -> zero(u)\nbc_fncs = (one_bc, zero_bc, zero_bc, zero_bc) # bottom, right, top, left\ntypes = (Dirichlet, Neumann, Dirichlet, Neumann)\nBCs = BoundaryConditions(mesh, bc_fncs, types)\nf = (x, y) -> zero(y)\ndiffusion_function = (x, y, t, u, D) -> D * u\nsource_function = (x, y, t, u, λ) -> λ * u * (1 - u)\nD, λ = 0.9, 0.99\ndiffusion_parameters = D\nsource_parameters = λ\nfinal_time = 50.0\ninitial_condition = [f(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)]\nprob = FVMProblem(mesh, BCs;\n    diffusion_function, diffusion_parameters,\n    source_function, source_parameters,\n    initial_condition, final_time)\nsol = solve(prob, TRBDF2(linsolve=KLUFactorization()); saveat=0.5)\nsol |> tc #hide","category":"page"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"Let us now look at the travelling wave behaviour. We will plot the evolution over time, and also the travelling wave view of the solution. First, let us get these travelling wave values.","category":"page"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"large_time_idx = findfirst(≥(10.0), sol.t)\nc = sqrt(λ / (2D))\ncₘᵢₙ = sqrt(λ * D / 2)\nzᶜ = 0.0\nexact_solution(z) = ifelse(z ≤ zᶜ, 1 - exp(cₘᵢₙ * z), zero(z))\ntravelling_wave_values = zeros(ny, length(sol) - large_time_idx + 1)\nz_vals = zero(travelling_wave_values)\nu_mat = [reshape(u, (nx, ny)) for u in sol.u]\nfor (i, t_idx) in pairs(large_time_idx:lastindex(sol))\n    u = u_mat[t_idx]\n    τ = sol.t[t_idx]\n    for k in 1:ny\n        y = c + (k - 1) * (d - c) / (ny - 1)\n        z = y - c * τ\n        z_vals[k, i] = z\n        travelling_wave_values[k, i] = u[nx÷2, k]\n    end\nend","category":"page"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"Now we are in a position to plot.","category":"page"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"using CairoMakie\nfig = Figure(resolution=(3200.72f0, 800.64f0), fontsize=38)\nfor (i, j) in zip(1:3, (1, 51, 101))\n    ax = Axis(fig[1, i], width=600, height=600,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[j])\",\n        titlealign=:left)\n    tricontourf!(ax, tri, sol.u[j], levels=0:0.05:1, colormap=:matter)\n    tightlimits!(ax)\nend\nax = Axis(fig[1, 4], width=900, height=600)\ncolors = cgrad(:matter, length(sol) - large_time_idx + 1; categorical=false)\n[lines!(ax, z_vals[:, i], travelling_wave_values[:, i], color=colors[i], linewidth=2) for i in 1:(length(sol)-large_time_idx+1)]\nexact_z_vals = collect(LinRange(extrema(z_vals)..., 500))\nexact_travelling_wave_values = exact_solution.(exact_z_vals)\nlines!(ax, exact_z_vals, exact_travelling_wave_values, color=:red, linewidth=4, linestyle=:dash)\nfig","category":"page"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/#Just-the-code","page":"Porous-Fisher Equation and Travelling Waves","title":"Just the code","text":"","category":"section"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"using DelaunayTriangulation, FiniteVolumeMethod, OrdinaryDiffEq, LinearSolve\na, b, c, d, nx, ny = 0.0, 3.0, 0.0, 40.0, 60, 80\ntri = triangulate_rectangle(a, b, c, d, nx, ny; single_boundary=false)\nmesh = FVMGeometry(tri)\none_bc = (x, y, t, u, p) -> one(u)\nzero_bc = (x, y, t, u, p) -> zero(u)\nbc_fncs = (one_bc, zero_bc, zero_bc, zero_bc) # bottom, right, top, left\ntypes = (Dirichlet, Neumann, Dirichlet, Neumann)\nBCs = BoundaryConditions(mesh, bc_fncs, types)\nf = (x, y) -> zero(y)\ndiffusion_function = (x, y, t, u, D) -> D * u\nsource_function = (x, y, t, u, λ) -> λ * u * (1 - u)\nD, λ = 0.9, 0.99\ndiffusion_parameters = D\nsource_parameters = λ\nfinal_time = 50.0\ninitial_condition = [f(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)]\nprob = FVMProblem(mesh, BCs;\n    diffusion_function, diffusion_parameters,\n    source_function, source_parameters,\n    initial_condition, final_time)\nsol = solve(prob, TRBDF2(linsolve=KLUFactorization()); saveat=0.5)\n\nlarge_time_idx = findfirst(≥(10.0), sol.t)\nc = sqrt(λ / (2D))\ncₘᵢₙ = sqrt(λ * D / 2)\nzᶜ = 0.0\nexact_solution(z) = ifelse(z ≤ zᶜ, 1 - exp(cₘᵢₙ * z), zero(z))\ntravelling_wave_values = zeros(ny, length(sol) - large_time_idx + 1)\nz_vals = zero(travelling_wave_values)\nu_mat = [reshape(u, (nx, ny)) for u in sol.u]\nfor (i, t_idx) in pairs(large_time_idx:lastindex(sol))\n    u = u_mat[t_idx]\n    τ = sol.t[t_idx]\n    for k in 1:ny\n        y = c + (k - 1) * (d - c) / (ny - 1)\n        z = y - c * τ\n        z_vals[k, i] = z\n        travelling_wave_values[k, i] = u[nx÷2, k]\n    end\nend\n\nusing CairoMakie\nfig = Figure(resolution=(3200.72f0, 800.64f0), fontsize=38)\nfor (i, j) in zip(1:3, (1, 51, 101))\n    ax = Axis(fig[1, i], width=600, height=600,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[j])\",\n        titlealign=:left)\n    tricontourf!(ax, tri, sol.u[j], levels=0:0.05:1, colormap=:matter)\n    tightlimits!(ax)\nend\nax = Axis(fig[1, 4], width=900, height=600)\ncolors = cgrad(:matter, length(sol) - large_time_idx + 1; categorical=false)\n[lines!(ax, z_vals[:, i], travelling_wave_values[:, i], color=colors[i], linewidth=2) for i in 1:(length(sol)-large_time_idx+1)]\nexact_z_vals = collect(LinRange(extrema(z_vals)..., 500))\nexact_travelling_wave_values = exact_solution.(exact_z_vals)\nlines!(ax, exact_z_vals, exact_travelling_wave_values, color=:red, linewidth=4, linestyle=:dash)\nfig","category":"page"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"","category":"page"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"This page was generated using Literate.jl.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"CurrentModule = FiniteVolumeMethod","category":"page"},{"location":"interface/#Interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Pages = [\"interface.md\"]","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"In this section, we describe the basic interface for defining and solving PDEs using this package. This interface will also be made clearer in the tutorials. The basic summary of the discussion below is as follows:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Use FVMGeometry to define the problem's mesh.\nProvide boundary conditions using BoundaryConditions.\n(Optional) Provide internal conditions using InternalConditions.\nConvert the problem into an FVMProblem.\nIf you want to make the problem steady, use SteadyFVMProblem on the FVMProblem.\nIf you want a system of equations, construct an FVMSystem from multiple FVMProblems; if you want this problem to be steady, skip step 5 and only now apply SteadyFVMProblem.\nSolve the problem using solve.\nFor a discussion of custom constraints, see the tutorials.\nFor interpolation, we provide pl_interpolate (but you might prefer NaturalNeighbours.jl - see this tutorial for an example).","category":"page"},{"location":"interface/#FVMGeometry:-Defining-the-mesh","page":"Interface","title":"FVMGeometry: Defining the mesh","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"The finite volume method (FVM) requires an underlying triangular mesh, as outlined in the mathematical details section. This triangular mesh is to be defined from DelaunayTriangulation.jl. The FVMGeometry type wraps the resulting Triangulation and computes information about the geometry required for solving the PDEs. The docstring for FVMGeometry is below; the fields of FVMGeometry are public API. ","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"FVMGeometry","category":"page"},{"location":"interface/#FiniteVolumeMethod.FVMGeometry","page":"Interface","title":"FiniteVolumeMethod.FVMGeometry","text":"FVMGeometry(tri::Triangulation)\n\nThis is a constructor for the FVMGeometry struct, which holds the mesh and associated data for the PDE.\n\nnote: Note\nIt is assumed that all vertices in tri are in the triangulation, meaning v is in tri for each v in DelaunayTriangulation.each_point_index(tri).\n\nFields\n\ntriangulation: The underlying Triangulation from DelaunayTriangulation.jl.\ntriangulation_statistics: The statistics of the triangulation. \ncv_volumes::Vector{Float64}: A Vector of the volumes of each control volume.\ntriangle_props::Dict{NTuple{3,Int},TriangleProperties}: A Dict mapping the indices of each triangle to its [TriangleProperties].\n\n\n\n\n\n","category":"type"},{"location":"interface/","page":"Interface","title":"Interface","text":"The FVMGeometry struct uses TriangleProperties for storing properties of a control volume that intersects a given triangle, defined below. This struct is  public API, although it is unlikely you would ever need it. ","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"TriangleProperties","category":"page"},{"location":"interface/#FiniteVolumeMethod.TriangleProperties","page":"Interface","title":"FiniteVolumeMethod.TriangleProperties","text":"TriangleProperties(shape_function_coefficients, cv_edge_midpoints, cv_edge_normals, cv_edge_lengths)\n\nThis is a struct for holding the properties of a control volume's intersection with a triangle.\n\nFields\n\nshape_function_coefficients::NTuple{9,Float64}: The shape function coefficients for the triangle.\ncv_edge_midpoints::NTuple{3,NTuple{2,Float64}}: The midpoints of the control volume edges. If the triangle is (i, j, k), then the edges are given in the order (i, j), (j, k), and (k, i), where 'edge' refers to the edge joining e.g. the midpoint of the edge (i, j) to the centroid of the triangle. \ncv_edge_normals::NTuple{3,NTuple{2,Float64}}: The normal vectors to the control volume edges, in the same order as in cv_edge_midpoints.\ncv_edge_lengths::NTuple{3,Float64}: The lengths of the control volume edges, in the same order as in cv_edge_midpoints.\n\nnotes: Notes\nThe shape function coefficients are defined so that, if s are the coefficients and the triangle is T = (i, j, k), with function values u[i], u[j], and u[k] at the vertices i, j, and k, respectively,  then αxₙ + βyₙ + γₙ = u[n] for n = i, j, k, where xₙ and yₙ are the x- and y-coordinates of the nth vertex, respectively,  α = s₁u₁ + s₂u₂ + s₃u₃, β = s₄u₁ + s₅u₂ + s₆u₃, and γ = s₇u₁ + s₈u₂ + s₉u₃.\n\n\n\n\n\n","category":"type"},{"location":"interface/#BoundaryConditions:-Defining-boundary-conditions","page":"Interface","title":"BoundaryConditions: Defining boundary conditions","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Once a mesh is defined, you need to associate each part of the boundary with a set of boundary nodes. Since you have a Triangulation, the boundary of the mesh already meets the necessary assumptions made by this package about the boundary; these assumptions are simply that they match the specification of a boundary here in DelaunayTriangulation.jl's docs (for example, the boundary points connect, the boundary is positively oriented, etc.).","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"You can specify boundary conditions using BoundaryConditions, whose docstring is below; the fields of BoundaryConditions are not public API, only this wrapper is.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"BoundaryConditions","category":"page"},{"location":"interface/#FiniteVolumeMethod.BoundaryConditions","page":"Interface","title":"FiniteVolumeMethod.BoundaryConditions","text":"BoundaryConditions(mesh::FVMGeometry, functions, conditions; parameters=nothing)\n\nThis is a constructor for the BoundaryConditions struct, which holds the boundary conditions for the PDE.  See also Conditions (which FVMProblem wraps this into), ConditionType, and InternalConditions.\n\nArguments\n\nmesh::FVMGeometry\n\nThe mesh on which the PDE is defined.\n\nfunctions::Union{<:Tuple,<:Function}\n\nThe functions that define the boundary conditions. The ith function should correspond to the part of the boundary of  the mesh corresponding to the ith boundary index, as defined in DelaunayTriangulation.jl. \n\nconditions::Union{<:Tuple,<:ConditionType}\n\nThe classification for the boundary condition type corresponding to each boundary index as above. See  ConditionType for possible conditions - should be one of Neumann, Dudt, Dirichlet, or Constrained.\n\nKeyword Arguments\n\nparameters=ntuple(_ -> nothing, length(functions))\n\nThe parameters for the functions, with parameters[i] giving the argument p in functions[i].\n\nOutputs\n\nThe returned value is the corresponding BoundaryConditions struct.\n\n\n\n\n\n","category":"type"},{"location":"interface/","page":"Interface","title":"Interface","text":"There are four types of boundary conditions: Neumann, Dudt, Dirichlet, and Constrained. These types are defined below.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"ConditionType \nNeumann \nDudt\nDirichlet \nConstrained","category":"page"},{"location":"interface/#FiniteVolumeMethod.ConditionType","page":"Interface","title":"FiniteVolumeMethod.ConditionType","text":"ConditionType\n\nThis is an Enum-type, with four instances:\n\nNeumann\nDudt\nDirichlet\nConstrained\n\nThis is used for declaring conditions in the PDEs. See  the associated docstrings, and also BoundaryConditions and InternalConditions.\n\n\n\n\n\n","category":"type"},{"location":"interface/#FiniteVolumeMethod.Neumann","page":"Interface","title":"FiniteVolumeMethod.Neumann","text":"Neumann\n\nInstance of a ConditionType used for declaring that an edge  has a Neumann condition. Neumann conditions  take the form \n\nvb q(x y t) vdot vu n_sigma = a(x y t u)\n\nwhere vb q is the flux function and vu n_sigma is the  outward unit normal vector field on the associated edge (meaning, for example,  the normal vector to an edge pq would point to the right of pq).\n\nWhen providing a Neumann condition, the function you provide  takes the form\n\na(x, y, t, u, p)\n\nwhere (x, y) is the point, t is the current time, and u is the  solution at the point (x, y) at time t, as above, with an extra  argument p for additional parameters. \n\n\n\n\n\n","category":"constant"},{"location":"interface/#FiniteVolumeMethod.Dudt","page":"Interface","title":"FiniteVolumeMethod.Dudt","text":"Dudt\n\nInstance of a ConditionType used for declaring that an edge,  or a point, has a Dudt-type boundary condition. Dudt-type  conditions take the form\n\ndvu(x y t)t = a(x y t u)\n\nWhen providing a Dudt condition, the function you provide takes the form\n\na(x, y, t, u, p)\n\nwhere (x, y) is the point, t is the current time, and u is the solution at the point (x, y) at time t, as above, with an extra  argument p for additional parameters.\n\n\n\n\n\n","category":"constant"},{"location":"interface/#FiniteVolumeMethod.Dirichlet","page":"Interface","title":"FiniteVolumeMethod.Dirichlet","text":"Dirichlet\n\nInstance of a ConditionType used for declaring that an edge, or a point, has a Dirichlet boundary condition. Dirichlet conditions take the form\n\nu(x y t) = a(x y t u)\n\nWhen providing a Dirichlet condition, the function you provide takes the form\n\na(x, y, t, u, p)\n\nwhere (x, y) is the point, t is the current time, and u is the solution at the point (x, y) at time t, as above, with an extra  argument p for additional parameters.\n\n\n\n\n\n","category":"constant"},{"location":"interface/#FiniteVolumeMethod.Constrained","page":"Interface","title":"FiniteVolumeMethod.Constrained","text":"Constrained\n\nInstance of a ConditionType used for declaring that an edge has a Constrained condition. When an edge has this condition associated with it,  it will be treated as any normal edge and no boundary condition will be applied. With this condition, it is assumed that you will later setup your problem as a  differential-algebraic equation (DAE) and provide the appropriate constraints. See the docs for some examples.\n\nWhen you provide a Constrained condition, for certain technical reasons  you do still need to provide a function that corresponds to it in the function list  provided to BoundaryConditions. For this function, any function will work,  e.g. sin - it will not be called. The proper constraint function is to be provided after-the-fact,  as explained in the docs.\n\n\n\n\n\n","category":"constant"},{"location":"interface/#InternalConditions:-Defining-internal-conditions","page":"Interface","title":"InternalConditions: Defining internal conditions","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"If you like, you can also put some constraints for nodes away from the boundary. In this case, only Dudt and Dirichlet conditions can be imposed; for Neumann or Constrained conditions, you need to consider differential-algebraic problems as considered in the tutorials. The docstring for InternalConditions is below; the fields of InternalConditions are not public API, only this wrapper is.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"InternalConditions","category":"page"},{"location":"interface/#FiniteVolumeMethod.InternalConditions","page":"Interface","title":"FiniteVolumeMethod.InternalConditions","text":"InternalConditions(functions=();\n    dirichlet_nodes::Dict{Int,Int}=Dict{Int,Int}(),\n    dudt_nodes::Dict{Int,Int}=Dict{Int,Int}(),\n    parameters::Tuple=ntuple(_ -> nothing, length(functions)))\n\nThis is a constructor for the InternalConditions struct, which holds the internal conditions for the PDE. See also Conditions (which FVMProblem wraps this into), ConditionType, and BoundaryConditions.\n\nArguments\n\nfunctions::Union{<:Tuple,<:Function}=()\n\nThe functions that define the internal conditions. These are the functions referred to in edge_conditions and point_conditions.\n\nKeyword Arguments\n\ndirichlet_nodes::Dict{Int,Int}=Dict{Int,Int}()\n\nA Dict that stores all Dirichlet points u as keys, with keys mapping to indices idx that refer to the corresponding condition function and parameters in functions and parameters.\n\ndudt_nodes::Dict{Int,Int}=Dict{Int,Int}()\n\nA Dict that stores all Dudt points u as keys, with keys mapping to indices idx that refer to the corresponding condition function and parameters in functions and parameters.\n\nparameters::Tuple=ntuple(_ -> nothing, length(functions))\n\nThe parameters for the functions, with parameters[i] giving the argument p in functions[i].\n\nOutputs\n\nThe returned value is the corresponding InternalConditions struct.\n\nnote: Note\nWhen the internal conditions get merged with the boundary conditions,  any internal conditions that are placed onto the boundary will  be replaced with the boundary condition at that point on the boundary.\n\n\n\n\n\n","category":"type"},{"location":"interface/#FVMProblem:-Defining-the-PDE","page":"Interface","title":"FVMProblem: Defining the PDE","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Once you have defined the mesh, the boundary conditions, and possibly the internal conditions, you can now construct the PDE itself. This is done using FVMProblem, whose docstring is below; the fields of FVMProblem are public API.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"FVMProblem ","category":"page"},{"location":"interface/#FiniteVolumeMethod.FVMProblem","page":"Interface","title":"FiniteVolumeMethod.FVMProblem","text":"FVMProblem(mesh, boundary_conditions[, internal_conditions];\n    diffusion_function=nothing,\n    diffusion_parameters=nothing,\n    source_function=nothing,\n    source_parameters=nothing,\n    flux_function=nothing,\n    flux_parameters=nothing,\n    initial_condition,\n    initial_time=0.0,\n    final_time)\n\nConstructs an FVMProblem. See also FVMSystem and SteadyFVMProblem.\n\nArguments\n\nmesh::FVMGeometry\n\nThe mesh on which the PDE is defined, given as a FVMGeometry.\n\nboundary_conditions::BoundaryConditions\n\nThe boundary conditions for the PDE, given as a BoundaryConditions.\n\ninternal_conditions::InternalConditions=InternalConditions()\n\nThe internal conditions for the PDE, given as an InternalConditions. This argument  is optional.\n\nKeyword Arguments\n\ndiffusion_function=nothing\n\nIf isnothing(flux_function), then this can be provided to give the diffusion-source formulation. See also construct_flux_function. Should be of the form D(x, y, t, u, p).\n\ndiffusion_parameters=nothing\n\nThe argument p for diffusion_function.\n\nsource_function=(x, y, t, u, p) -> zero(u)\n\nThe source term, given in the form S(x, y, t, u, p).\n\nsource_parameters=nothing\n\nThe argument p for source_function.\n\nflux_function=nothing\n\nThe flux function, given in the form q(x, y, t, α, β, γ, p) ↦ (qx, qy), where (qx, qy) is the flux vector, (α, β, γ) are the shape function coefficients for estimating u ≈ αx+βy+γ. If isnothing(flux_function), then diffusion_function is used instead to construct the function.\n\nflux_parameters=nothing\n\nThe argument p for flux_function.\n\ninitial_condition\n\nThe initial condition, with initial_condition[i] the initial value at the ith node of the mesh.\n\ninitial_time=0.0\n\nThe initial time.\n\nfinal_time\n\nThe final time.\n\nOutputs\n\nThe returned value is the corresponding FVMProblem struct. You can then solve the problem using solve(::Union{FVMProblem,FVMSystem}, ::Any; kwargs...) from DifferentialEquations.jl.\n\n\n\n\n\n","category":"type"},{"location":"interface/","page":"Interface","title":"Interface","text":"For this problem, you can provide either a diffusion_function or a flux_function. In the former case, the flux_function is constructed from diffusion_function using construct_flux_function, whose docstring is shown below; construct_flux_function is not public API.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"construct_flux_function","category":"page"},{"location":"interface/#FiniteVolumeMethod.construct_flux_function","page":"Interface","title":"FiniteVolumeMethod.construct_flux_function","text":"construct_flux_function(q, D, Dp)\n\nIf isnothing(q), then this returns the flux function based on the diffusion function D and  diffusion parameters Dp, so that the new function is \n\n(x, y, t, α, β, γ, _) -> -D(x, y, t, α*x + β*y + γ, Dp)[α, β]\n\nOtherwise, just returns q again.\n\n\n\n\n\n","category":"function"},{"location":"interface/","page":"Interface","title":"Interface","text":"Additionally, FVMProblem merges the provided boundary conditions and internal conditions into a Conditions type, defined below; the documented fields of Conditions are public API.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Conditions","category":"page"},{"location":"interface/#FiniteVolumeMethod.Conditions","page":"Interface","title":"FiniteVolumeMethod.Conditions","text":"Conditions{F} <: AbstractConditions\n\nThis is a struct that holds the boundary and internal conditions for the PDE. The constructor is \n\nConditions(mesh::FVMGeometry, bc::BoundaryConditions, ic::InternalConditions=InternalConditions())\n\nThe fields are:\n\nFields\n\nneumann_conditions::Dict{NTuple{2,Int},Int}\n\nA Dict that stores all Neumann edges (u, v) as keys, with keys mapping to indices  idx that refer to the corresponding condition function and parameters in functions.\n\nconstrained_conditions::Dict{NTuple{2,Int},Int}\n\nA Dict that stores all Constrained edges (u, v) as keys, with keys mapping to indices idx that refer to the corresponding condition function and parameters in functions.\n\ndirichlet_conditions::Dict{Int,Int}\n\nA Dict that stores all Dirichlet points u as keys, with keys mapping to indices idx that refer to the corresponding condition function and parameters in functions.\n\ndudt_conditions::Dict{Int,Int}\n\nA Dict that stores all Dudt points u as keys, with keys mapping to indices idx that refer to the corresponding condition function and parameters in functions.\n\nfunctions::F<:Tuple\n\nThe functions that define the boundary and internal conditions. The ith function should correspond to the part of the boundary of the mesh corresponding to the ith boundary index, as defined in DelaunayTriangulation.jl. The ith function is stored  as a ParametrisedFunction.\n\n\n\n\n\n","category":"type"},{"location":"interface/","page":"Interface","title":"Interface","text":"Note that the functions in Conditions get wrapped into a ParametrisedFunction type, which is public API.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"ParametrisedFunction","category":"page"},{"location":"interface/#FiniteVolumeMethod.ParametrisedFunction","page":"Interface","title":"FiniteVolumeMethod.ParametrisedFunction","text":"ParametrisedFunction{F<:Function,P} <: Function\n\nThis is a struct that wraps a function f and some parameters p into a single object.\n\nFields\n\nfnc::F\n\nThe function that is wrapped.\n\nparameters::P\n\nThe parameters that are wrapped.\n\n\n\n\n\n","category":"type"},{"location":"interface/#SteadyFVMProblem:-Making-the-problem-a-steady-state-problem","page":"Interface","title":"SteadyFVMProblem: Making the problem a steady-state problem","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"To make an FVMProblem a steady-state problem, meaning that you are solving","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"div vb q(vb x t u) = S(vb x t u)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"rather than","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"pdvu(vb x t)t + div vb q(vb x t u) = S(vb x t u)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"than you need to wrap the FVMProblem inside a SteadyFVMProblem, defined below; the fields of SteadyFVMProblem are public API.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"SteadyFVMProblem","category":"page"},{"location":"interface/#FiniteVolumeMethod.SteadyFVMProblem","page":"Interface","title":"FiniteVolumeMethod.SteadyFVMProblem","text":"SteadyFVMProblem(prob::AbstractFVMProblem)\n\nThis is a wrapper for an AbstractFVMProblem that indicates that the problem is to be solved as a steady-state problem.  You can then solve the problem using solve(::SteadyFVMProblem, ::Any; kwargs...) from NonlinearSolve.jl. Note that you  need to have set the final time to Inf if you want a steady state out at infinity rather than some finite actual time.\n\nSee also FVMProblem and FVMSystem.\n\n\n\n\n\n","category":"type"},{"location":"interface/#FVMSystem:-Defining-a-system-of-PDEs","page":"Interface","title":"FVMSystem: Defining a system of PDEs","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"We also allow for systems of PDEs to be defined, where this system should take the form","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"beginequation*\nbeginaligned\npdvu_1(vb x t)t + div vb q_1(vb x t u_1 ldots u_n) = S_1(vb x t u_1 ldots u_n) \npdvu_2(vb x t)t + div vb q_2(vb x t u_1 ldots u_n) = S_2(vb x t u_1 ldots u_n) \nvdots \npdvu_n(vb x t)t + div vb q_n(vb x t u_1 ldots u_n) = S_n(vb x t u_1 ldots u_n)\nendaligned\nendequation*","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"To define this system, you need to provide an FVMProblem for each equation, and then construct an FVMSystem from these problems. The docstring for FVMSystem is below; the fields of FVMSystem are public API.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"FVMSystem","category":"page"},{"location":"interface/#FiniteVolumeMethod.FVMSystem","page":"Interface","title":"FiniteVolumeMethod.FVMSystem","text":"FVMSystem(prob1, prob2, ..., probN)\n\nConstructs a representation for a system of PDEs, where each probi is  a FVMProblem for the ith component of the system.\n\nFor these FVMProblems, the functions involved, such as the condition functions, should  all be defined so that the u argument assumes the form u = (u₁, u₂, ..., uN) (both Tuples and Vectors will be passed),  where uᵢ is the solution for the ith component of the system. For the flux functions,  which for a FVMProblem takes the form\n\nq(x, y, t, α, β, γ, p) ↦ (qx, qy),\n\nthe same form is used, except α, β, γ are all Tuples so that α[i]*x + β[i]*y + γ[i] is the  approximation to uᵢ. \n\nwarning: Providing default flux functions\nDue to this difference in flux functions, and the need to provide  α, β, and γ to the flux function, for FVMSystems you need to  provide a flux function rather than a diffusion function. If you do provide a diffusion function, it will error when you try to solve  the problem.\n\nThis problem is solved in the same way as a FVMProblem, except the problem is defined such that  the solution returns a matrix at each time, where the (j, i)th component corresponds to the solution at the ith  node for the jth component.\n\nSee also FVMProblem and SteadyFVMProblem.\n\nnote: Note\nTo construct a steady-state problem for an FVMSystem, you need to apply  SteadyFVMProblem to the system rather than first applying it to each individual FVMProblem in the system.\n\n\n\n\n\n","category":"type"},{"location":"interface/","page":"Interface","title":"Interface","text":"If you want to make a steady-state problem for an FVMSystem, you should apply SteadyFVMProblem to FVMSystem rather than to each FVMProblem individually.","category":"page"},{"location":"interface/#solve:-Solving-the-PDE","page":"Interface","title":"solve: Solving the PDE","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"You can use solve from the SciMLBase ecosystem to solve these PDEs. This allows you to use any of the available algorithms from DifferentialEquations.jl for solving these problems. For non-steady problems, the relevant function is (which is public API)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"solve(::Union{FVMProblem,FVMSystem}, ::Any; kwargs...)","category":"page"},{"location":"interface/#CommonSolve.solve-Tuple{Union{FVMProblem, FVMSystem}, Any}","page":"Interface","title":"CommonSolve.solve","text":"solve(prob::Union{FVMProblem,FVMSystem}, alg; \n    specialization=SciMLBase.AutoSpecialize, \n    jac_prototype=jacobian_sparsity(prob), \n    parallel::Val{<:Bool}=Val(true),\n    kwargs...)\n\nSolves the given FVMProblem or FVMSystem prob with the algorithm alg.\n\nwarning: Missing vertices\nWhen the underlying triangulation, tri, has points in get_points(tri) that are not  vertices of the triangulation itself, the associated values of the solution at these points will not be updated by the solver, and will remain at their initial values.\n\nArguments\n\nprob: The problem to be solved.\nalg: The algorithm to be used to solve the problem. This can be any of the algorithms in DifferentialEquations.jl.\n\nKeyword Arguments\n\nspecialization=SciMLBase.AutoSpecialize: The type of specialization to be used. See https://docs.sciml.ai/DiffEqDocs/stable/features/low_dep/#Controlling-Function-Specialization-and-Precompilation.\njac_prototype=jacobian_sparsity(prob): The prototype for the Jacobian matrix, constructed by default from jacobian_sparsity.\nparallel::Val{<:Bool}=Val(true): Whether to use multithreading. Use Val(false) to disable multithreading. \nkwargs...: Any other keyword arguments to be passed to the solver.\n\nOutputs\n\nThe returned value sol depends on the type of the problem.\n\nFVMProblem\n\nIn this case, sol::ODESolution is such that the ith component of sol refers to the ith node of the underlying mesh.\n\nFVMSystem\n\nIn this case, the (j, i)th component of sol::ODESolution refers to the ith node of the underlying mesh for the jth component of the system.\n\n\n\n\n\n","category":"method"},{"location":"interface/","page":"Interface","title":"Interface","text":"For steady-state problems, the algorithms to use are those from NonlinearSolve.jl. The relevant function is still solve and is public API:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"solve(::SteadyFVMProblem, ::Any; kwargs...)","category":"page"},{"location":"interface/#CommonSolve.solve-Tuple{SteadyFVMProblem, Any}","page":"Interface","title":"CommonSolve.solve","text":"solve(prob::SteadyFVMProblem, alg; \n    specialization=SciMLBase.AutoSpecialize, \n    jac_prototype=jacobian_sparsity(prob),\n    parallel::Val{<:Bool}=Val(true),\n    kwargs...)\n\nSolves the given FVMProblem or FVMSystem prob with the algorithm alg.\n\nArguments\n\nprob: The problem to be solved.\nalg: The algorithm to be used to solve the problem. This can be any of the algorithms in NonlinearSolve.jl.\n\nKeyword Arguments\n\nspecialization=SciMLBase.AutoSpecialize: The type of specialization to be used. See https://docs.sciml.ai/DiffEqDocs/stable/features/low_dep/#Controlling-Function-Specialization-and-Precompilation.\njac_prototype=jacobian_sparsity(prob): The prototype for the Jacobian matrix, constructed by default from jacobian_sparsity.\nparallel::Val{<:Bool}=Val(true): Whether to use multithreading. Use Val(false) to disable multithreading.\nkwargs...: Any other keyword arguments to be passed to the solver.\n\nOutputs\n\nThe returned value sol depends on whether the underlying problem is a FVMProblem or an FVMSystem, but in  each case it is an ODESolution type that can be accessed like the solutions in DifferentialEquations.jl:\n\nFVMProblem\n\nIn this case, sol is such that the ith component of sol refers to the ith node of the underlying mesh.\n\nFVMSystem\n\nIn this case, the (j, i)th component of sol refers to the ith node of the underlying mesh for the jth component of the system.\n\n\n\n\n\n","category":"method"},{"location":"interface/","page":"Interface","title":"Interface","text":"These solve functions rely on fvm_eqs! for evaluating the equations. You should never need to use fvm_eqs! directly, unless you are using a differential-algebraic equation. The docstring for fvm_eqs! is below; this function is public API.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"fvm_eqs!","category":"page"},{"location":"interface/#FiniteVolumeMethod.fvm_eqs!","page":"Interface","title":"FiniteVolumeMethod.fvm_eqs!","text":"fvm_eqs!(du, u, p, t)\n\nComputes the finite volume method equations for the current time t  and solution u. This function is public API.\n\nThe argument p depends on whether the problem is being solved  in parallel or not. If it is solved serially, than the fields are:\n\np.prob: The prob <: AbstractFVMProblem.\np.parallel: Val(false).\n\nIf the problem is solved in parallel, then the fields are:\n\np.prob: The prob <: AbstractFVMProblem.\np.parallel: Val(true).   \np.duplicated_du: A Matrix of the same size as du that is used to store the contributions to du from each thread. \np.solid_triangles: A Vector of the solid triangles in the triangulation.\np.solid_vertices: A Vector of the solid vertices in the triangulation.\np.chunked_solid_triangles: A Vector of tuples of the form (range, chunk_idx) where range is a range of indices into p.solid_triangles and chunk_idx is the index of the chunk.\np.boundary_edges: A Vector of the boundary edges in the triangulation.\np.chunked_boundary_edges: A Vector of tuples of the form (range, chunk_idx) where range is a range of indices into p.boundary_edges and chunk_idx is the index of the chunk.\n\nThese fields are public API, although note that they are not intended to be modified by the user, and we may freely  add in new fields over new versions.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Custom-constraints","page":"Interface","title":"Custom constraints","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"You can also provide custom constraints. Rather than outlining this precisely here, it is best explained in the tutorials, namely this tutorial. We note that one useful function for this is compute_flux, which allows you to compute the flux across a given edge. The docstring for compute_flux is below, and this function is public API.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"compute_flux","category":"page"},{"location":"interface/#FiniteVolumeMethod.compute_flux","page":"Interface","title":"FiniteVolumeMethod.compute_flux","text":"compute_flux(prob::AbstractFVMProblem, i, j, u, t)\n\nGiven an edge with indices (i, j), a solution vector u, a current time t,  and a problem prob, computes the flux ∇⋅q(x, y, t, α, β, γ, p) ⋅ n,  where n is the normal vector to the edge, q is the flux function from prob, (x, y) is the midpoint of the edge, (α, β, γ) are the shape function coefficients,  and p are the flux parameters from prob. If prob is an FVMSystem, the returned  value is a Tuple for each individual flux. The normal vector n is a clockwise rotation of  the edge, meaning pointing right of the edge (i, j).\n\n\n\n\n\n","category":"function"},{"location":"interface/#Piecewise-linear-interpolation","page":"Interface","title":"Piecewise linear interpolation","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"You can evaluate the piecewise linear interpolation corresponding to a solution using pl_interpolate, defined below; this function is public API.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"pl_interpolate","category":"page"},{"location":"interface/#FiniteVolumeMethod.pl_interpolate","page":"Interface","title":"FiniteVolumeMethod.pl_interpolate","text":"pl_interpolate(prob, T, u, x, y)\n\nGiven a prob <: AbstractFVMProblem, a triangle T containing a point (x, y),  and a set of function values u at the corresponding nodes of prob, interpolates  the solution at the point (x, y) using piecewise linear interpolation.\n\n\n\n\n\n","category":"function"},{"location":"interface/","page":"Interface","title":"Interface","text":"Better interpolants are available from NaturalNeighbours.jl - see the this tutorial for some examples.","category":"page"},{"location":"wyos/overview/#Solvers-for-Specific-Problems,-and-Writing-Your-Own","page":"Section Overview","title":"Solvers for Specific Problems, and Writing Your Own","text":"","category":"section"},{"location":"wyos/overview/","page":"Section Overview","title":"Section Overview","text":"The problems solved by this package are quite general, taking the form","category":"page"},{"location":"wyos/overview/","page":"Section Overview","title":"Section Overview","text":"pdvut + divvb q = S","category":"page"},{"location":"wyos/overview/","page":"Section Overview","title":"Section Overview","text":"For some problems, though, this is not the most efficient form to implement. For example, the diffusion equation","category":"page"},{"location":"wyos/overview/","page":"Section Overview","title":"Section Overview","text":"pdvut = Dgrad^2 u","category":"page"},{"location":"wyos/overview/","page":"Section Overview","title":"Section Overview","text":"might be better treated by converting the problem into","category":"page"},{"location":"wyos/overview/","page":"Section Overview","title":"Section Overview","text":"dvvb ut = vb Avb u + vb b","category":"page"},{"location":"wyos/overview/","page":"Section Overview","title":"Section Overview","text":"which is faster to solve than if we were to treat it as a nonlinear problem (which is done by default). For this reason, we define some templates  for specific types of problems, namely:","category":"page"},{"location":"wyos/overview/","page":"Section Overview","title":"Section Overview","text":"DiffusionEquations: partial_tu = divD(vb x)grad u.\nMeanExitTimeProblems: divD(vb x)grad T(vb x) = -1.\nLinearReactionDiffusionEquations: partial_tu = divD(vb x)grad u + f(vb x)u.\nPoissonsEquation: divD(vb x)grad u = f(vb x).\nLaplacesEquation: divD(vb x)grad u = 0.","category":"page"},{"location":"wyos/overview/","page":"Section Overview","title":"Section Overview","text":"The docstrings below define the templates for these problems.","category":"page"},{"location":"wyos/overview/","page":"Section Overview","title":"Section Overview","text":"FiniteVolumeMethod.AbstractFVMTemplate\nsolve(::FiniteVolumeMethod.AbstractFVMTemplate, args...; kwargs...)\nDiffusionEquation\nMeanExitTimeProblem\nLinearReactionDiffusionEquation\nPoissonsEquation\nLaplacesEquation","category":"page"},{"location":"wyos/overview/#FiniteVolumeMethod.AbstractFVMTemplate","page":"Section Overview","title":"FiniteVolumeMethod.AbstractFVMTemplate","text":"abstract type AbstractFVMTemplate <: AbstractFVMProblem\n\nAn abstract type that defines some specific problems. These problems are those that could  be defined directly using FVMProblems, but are common enough that (1) it is useful to have them defined here, and (2) it is useful to have them defined in a way that is more efficient than with a default implementation (e.g. exploiting linearity). The  problems are all defined as subtypes of a common abstract type,  namely, AbstractFVMTemplate (the home of this docstring), which itself is a subtype of AbstractFVMProblem. \n\nTo understand how to make use of these specific problems, either  see the docstring for each problem, or see the  \"Solvers for Specific Problems, and Writing Your Own\" section of the docs.\n\nTo see the full list of problems, do \n\njulia> using FiniteVolumeMethod\n\njulia> subtypes(FiniteVolumeMethod.AbstractFVMTemplate)\n5-element Vector{Any}:\n DiffusionEquation\n LaplacesEquation\n LinearReactionDiffusionEquation\n MeanExitTimeProblem\n PoissonsEquation\n\nThe constructor for each problem is defined in its docstring. Note that all the problems above are exported.\n\nThese problems can all be solved using the standard solve interface from  DifferentialEquations.jl, just like for FVMProblems. The only exception  is for steady state problems, in which case the solve interface is still used, except  the interface is from LinearSolve.jl.\n\n\n\n\n\n","category":"type"},{"location":"wyos/overview/#CommonSolve.solve-Tuple{FiniteVolumeMethod.AbstractFVMTemplate, Vararg{Any}}","page":"Section Overview","title":"CommonSolve.solve","text":"solve(prob::AbstractFVMTemplate, args...; kwargs...)\n\nSolve the problem prob using the standard solve interface from DifferentialEquations.jl. For  steady state problems, the interface is from LinearSolve.jl.\n\n\n\n\n\n","category":"method"},{"location":"wyos/overview/#FiniteVolumeMethod.DiffusionEquation","page":"Section Overview","title":"FiniteVolumeMethod.DiffusionEquation","text":"DiffusionEquation <: AbstractFVMTemplate\n\nA struct for defining a problem representing a diffusion equation:\n\npdvut = divleftD(vb x)grad uright\n\ninside a domain Omega. \n\nYou can solve this problem using solve.\n\nwarning: Warning\nThe solution to this problem will have an extra component added to it. The original solution will be inside  sol[begin:end-1, :], where sol is the solution returned by solve.\n\nConstructor\n\nDiffusionEquation(mesh::FVMGeometry,\n    BCs::BoundaryConditions,\n    ICs::InternalConditions=InternalConditions();\n    diffusion_function,\n    diffusion_parameters=nothing,\n    initial_condition,\n    initial_time=0.0,\n    final_time,\n    kwargs...)\n\nArguments\n\nmesh::FVMGeometry: The FVMGeometry.\nBCs::BoundaryConditions: The BoundaryConditions. For these boundary conditions, all functions should still be of the form (x, y, t, u, p) -> Number, but the t and u arguments should be unused as they will be replaced with nothing.\nICs::InternalConditions=InternalConditions(): The InternalConditions. For these internal conditions, all functions should still be of the form (x, y, t, u, p) -> Number, but the t and u arguments should be unused as they will be replaced with nothing.\n\nKeyword Arguments\n\ndiffusion_function: The diffusion function. Should be of the form (x, y, p) -> Number, where p = diffusion_parameters below.\ndiffusion_parameters=nothing: The argument p in diffusion_function.\ninitial_condition: The initial condition. \ninitial_time=0.0: The initial time.\nfinal_time: The final time.\nkwargs...: Any other keyword arguments are passed to the ODEProblem (from DifferentialEquations.jl) that represents the problem. \n\nFields\n\nThe struct has extra fields in addition to the arguments above:\n\nA: This is a sparse matrix A so that du/dt = Au + b.\nb: The b above.\nAop: The MatrixOperator that represents the system so that du/dt = Aop*u (with u padded with an extra component since A is now inside Aop).\nproblem: The ODEProblem that represents the problem. This is the problem that is solved when you call solve on the struct.\n\n\n\n\n\n","category":"type"},{"location":"wyos/overview/#FiniteVolumeMethod.MeanExitTimeProblem","page":"Section Overview","title":"FiniteVolumeMethod.MeanExitTimeProblem","text":"MeanExitTimeProblem\n\nA struct for defining a problem representing a mean exit time problem:\n\ndivleftD(vb x)grad Tright =-1\n\ninside a domain Omega. This problem is a special case of PoissonsEquation, but is defined separately since it is common enough to warrant its own definition; MeanExitTimeProblem is constructed using PoissonsEquation.\n\nYou can solve this problem using solve.\n\nConstructor\n\nMeanExitTimeProblem(mesh::FVMGeometry,\n    BCs::BoundaryConditions,\n    ICs::InternalConditions=InternalConditions();\n    diffusion_function,\n    diffusion_parameters=nothing,\n    kwargs...)\n\nArguments\n\nmesh::FVMGeometry: The FVMGeometry.\nBCs::BoundaryConditions: The BoundaryConditions.\nICs::InternalConditions=InternalConditions(): The InternalConditions.\n\nThe functions for BCs and ICs are not used. Whenever a Neumann condition is encountered,  or a Dirichlet condition, it is assumed that the conditon is homogeneous. If any of the  conditions are Dudt or Constrained types, then an error is thrown.\n\nKeyword Arguments\n\ndiffusion_function: The diffusion function. Should be of the form (x, y, p) -> Number, where p = diffusion_parameters below.\ndiffusion_parameters=nothing: The argument p in diffusion_function.\nkwargs...: Any other keyword arguments are passed to the LinearProblem (from LinearSolve.jl) that represents the problem.\n\nFields\n\nThe struct has extra fields in addition to the arguments above:\n\nA: This is a sparse matrix A so that AT = b.\nb: The b above.\nproblem: The LinearProblem that represents the problem. This is the problem that is solved when you call solve on the struct.\n\n\n\n\n\n","category":"type"},{"location":"wyos/overview/#FiniteVolumeMethod.LinearReactionDiffusionEquation","page":"Section Overview","title":"FiniteVolumeMethod.LinearReactionDiffusionEquation","text":"LinearReactionDiffusionEquation\n\nA struct for defining a problem representing a linear reaction-diffusion equation:\n\npdvut = divleftD(vb x)grad uright + f(vb x)u\n\ninside a domain Omega. \n\nYou can solve this problem using solve.\n\nwarning: Warning\nThe solution to this problem will have an extra component added to it. The original solution will be inside  sol[begin:end-1, :], where sol is the solution returned by solve.\n\nConstructor\n\nLinearReactionDiffusionEquation(mesh::FVMGeometry,\n    BCs::BoundaryConditions,\n    ICs::InternalConditions=InternalConditions();\n    diffusion_function,\n    diffusion_parameters=nothing,\n    source_function,\n    source_parameters=nothing,\n    initial_condition,\n    initial_time=0.0,\n    final_time,\n    kwargs...)\n\nArguments\n\nmesh::FVMGeometry: The FVMGeometry.\nBCs::BoundaryConditions: The BoundaryConditions. For these boundary conditions, all functions should still be of the form (x, y, t, u, p) -> Number, but the t and u arguments should be unused as they will be replaced with nothing.\nICs::InternalConditions=InternalConditions(): The InternalConditions. For these internal conditions, all functions should still be of the form (x, y, t, u, p) -> Number, but the t and u arguments should be unused as they will be replaced with nothing.\n\nKeyword Arguments\n\ndiffusion_function: The diffusion function. Should be of the form (x, y, p) -> Number, where p = diffusion_parameters below.\ndiffusion_parameters=nothing: The argument p in diffusion_function.\nsource_function: The source function. Should be of the form (x, y, p) -> Number, where p = source_parameters below.\nsource_parameters=nothing: The argument p in source_function.\ninitial_condition: The initial condition.\ninitial_time=0.0: The initial time.\nfinal_time: The final time.\nkwargs...: Any other keyword arguments are passed to the ODEProblem (from DifferentialEquations.jl) that represents the problem.\n\nFields\n\nThe struct has extra fields in addition to the arguments above:\n\nA: This is a sparse matrix A so that du/dt = Au + b.\nb: The b above.\nAop: The MatrixOperator that represents the system so that du/dt = Aop*u (with u padded with an extra component since A is now inside Aop).\nproblem: The ODEProblem that represents the problem. This is the problem that is solved when you call solve on the struct.\n\n\n\n\n\n","category":"type"},{"location":"wyos/overview/#FiniteVolumeMethod.PoissonsEquation","page":"Section Overview","title":"FiniteVolumeMethod.PoissonsEquation","text":"PoissonsEquation\n\nA struct for defining a problem representing a (generalised) Poisson's equation:\n\ndivD(vb x)grad u = f(vb x)\n\ninside a domain Omega. See also LaplacesEquation, a special case of this  problem with f(vb x) = 0.\n\nYou can solve this problem using solve.\n\nConstructor\n\nPoissonsEquation(mesh::FVMGeometry,\n    BCs::BoundaryConditions,\n    ICs::InternalConditions=InternalConditions();\n    diffusion_function=(x,y,p)->1.0,\n    diffusion_parameters=nothing,\n    source_function, \n    source_parameters=nothing,\n    kwargs...)\n\nArguments\n\nmesh::FVMGeometry: The FVMGeometry.\nBCs::BoundaryConditions: The BoundaryConditions. For these boundary conditions, all functions should still be of the form (x, y, t, u, p) -> Number, but the t and u arguments should be unused as they will be replaced with nothing.\nICs::InternalConditions=InternalConditions(): The InternalConditions. For these internal conditions, all functions should still be of the form (x, y, t, u, p) -> Number, but the t and u arguments should be unused as they will be replaced with nothing.\n\nKeyword Arguments\n\ndiffusion_function=(x,y,p)->1.0: The diffusion function. Should be of the form (x, y, p) -> Number, where p = diffusion_parameters below.\ndiffusion_parameters=nothing: The argument p in diffusion_function.\nsource_function: The source function. Should be of the form (x, y, p) -> Number, where p = source_parameters below.\nsource_parameters=nothing: The argument p in source_function.\nkwargs...: Any other keyword arguments are passed to the LinearProblem (from LinearSolve.jl) that represents the problem.\n\nFields\n\nThe struct has extra fields in addition to the arguments above:\n\nA: This is a sparse matrix A so that Au = b.    \nb: The b above.\nproblem: The LinearProblem that represents the problem. This is the problem that is solved when you call solve on the struct.\n\n\n\n\n\n","category":"type"},{"location":"wyos/overview/#FiniteVolumeMethod.LaplacesEquation","page":"Section Overview","title":"FiniteVolumeMethod.LaplacesEquation","text":"LaplacesEquation\n\nA struct for defining a problem representing a (generalised) Laplace's equation:\n\ndivD(vb x)grad u = 0\n\ninside a domain Omega. See also PoissonsEquation.\n\nYou can solve this problem using solve.\n\nConstructor\n\nLaplacesEquation(mesh::FVMGeometry,\n    BCs::BoundaryConditions,\n    ICs::InternalConditions=InternalConditions();\n    diffusion_function=(x,y,p)->1.0,\n    diffusion_parameters=nothing,\n    kwargs...)\n\nArguments\n\nmesh::FVMGeometry: The FVMGeometry.\nBCs::BoundaryConditions: The BoundaryConditions. For these boundary conditions, all functions should still be of the form (x, y, t, u, p) -> Number, but the t and u arguments should be unused as they will be replaced with nothing.\nICs::InternalConditions=InternalConditions(): The InternalConditions. For these internal conditions, all functions should still be of the form (x, y, t, u, p) -> Number, but the t and u arguments should be unused as they will be replaced with nothing.\n\nKeyword Arguments\n\ndiffusion_function=(x,y,p)->1.0: The diffusion function. Should be of the form (x, y, p) -> Number, where p = diffusion_parameters below.\ndiffusion_parameters=nothing: The argument p in diffusion_function.\nkwargs...: Any other keyword arguments are passed to the LinearProblem (from LinearSolve.jl) that represents the problem.\n\nFields\n\nThe struct has extra fields in addition to the arguments above:\n\nA: This is a sparse matrix A so that Au = b.    \nb: The b above.\nproblem: The LinearProblem that represents the problem. This is the problem that is solved when you call solve on the struct.\n\n\n\n\n\n","category":"type"},{"location":"wyos/overview/","page":"Section Overview","title":"Section Overview","text":"Now, again, we note that all these problems can already be implemented using the main interface FVMProblem. However, the templates we provide are more efficient, and also provide a good starting point for writing your own solver, meaning your own function  that evaluates the system of ODEs. In the sections that follow, we will demonstrate two things for each of the problems above:","category":"page"},{"location":"wyos/overview/","page":"Section Overview","title":"Section Overview","text":"The mathematical details involved in implementing each template.\nExamples of using the templates from FiniteVolumeMethod.jl.","category":"page"},{"location":"wyos/overview/","page":"Section Overview","title":"Section Overview","text":"With these two steps, you should be able to also know how to write your own solver for any problem you like. ","category":"page"},{"location":"wyos/overview/#Relevant-Docstrings-for-Writing-Your-Own-Solver","page":"Section Overview","title":"Relevant Docstrings for Writing Your Own Solver","text":"","category":"section"},{"location":"wyos/overview/","page":"Section Overview","title":"Section Overview","text":"For writing these solvers, there are some specific functions that might be of use to you.  Here, we provide the docstrings for these functions. These functions are public API.","category":"page"},{"location":"wyos/overview/","page":"Section Overview","title":"Section Overview","text":"FiniteVolumeMethod.get_dirichlet_fidx\nFiniteVolumeMethod.is_dirichlet_node\nFiniteVolumeMethod.get_dirichlet_nodes \nFiniteVolumeMethod.has_dirichlet_nodes \nFiniteVolumeMethod.get_dudt_fidx \nFiniteVolumeMethod.is_dudt_node \nFiniteVolumeMethod.get_dudt_nodes \nFiniteVolumeMethod.has_dudt_nodes\nFiniteVolumeMethod.get_neumann_fidx \nFiniteVolumeMethod.is_neumann_edge \nFiniteVolumeMethod.has_neumann_edges\nFiniteVolumeMethod.get_neumann_edges\nFiniteVolumeMethod.get_constrained_fidx \nFiniteVolumeMethod.is_constrained_edge\nFiniteVolumeMethod.has_constrained_edges\nFiniteVolumeMethod.get_constrained_edges\nFiniteVolumeMethod.eval_condition_fnc\nFiniteVolumeMethod.has_condition \nFiniteVolumeMethod.get_cv_components \nFiniteVolumeMethod.get_boundary_cv_components\nFiniteVolumeMethod.get_triangle_props \nFiniteVolumeMethod.get_volume \nFiniteVolumeMethod.DelaunayTriangulation.get_point(::FVMGeometry, ::Any)\nFiniteVolumeMethod.triangle_contributions!\nFiniteVolumeMethod.apply_dirichlet_conditions!\nFiniteVolumeMethod.apply_dudt_conditions! \nFiniteVolumeMethod.boundary_edge_contributions!\nFiniteVolumeMethod.non_neumann_boundary_edge_contributions!\nFiniteVolumeMethod.neumann_boundary_edge_contributions!\nFiniteVolumeMethod.create_rhs_b\nFiniteVolumeMethod.apply_steady_dirichlet_conditions!\nFiniteVolumeMethod.two_point_interpolant\nFiniteVolumeMethod.get_dirichlet_callback\nFiniteVolumeMethod.jacobian_sparsity\nFiniteVolumeMethod.fix_missing_vertices!","category":"page"},{"location":"wyos/overview/#FiniteVolumeMethod.get_dirichlet_fidx","page":"Section Overview","title":"FiniteVolumeMethod.get_dirichlet_fidx","text":"get_dirichlet_fidx(conds, node)\n\nGet the index of the function that corresponds to the Dirichlet condition at node.\n\n\n\n\n\n","category":"function"},{"location":"wyos/overview/#FiniteVolumeMethod.is_dirichlet_node","page":"Section Overview","title":"FiniteVolumeMethod.is_dirichlet_node","text":"is_dirichlet_node(conds, node)\n\nCheck if node has a Dirichlet condition.\n\n\n\n\n\n","category":"function"},{"location":"wyos/overview/#FiniteVolumeMethod.get_dirichlet_nodes","page":"Section Overview","title":"FiniteVolumeMethod.get_dirichlet_nodes","text":"get_dirichlet_nodes(conds)\n\nGet all nodes that have a Dirichlet condition.\n\n\n\n\n\n","category":"function"},{"location":"wyos/overview/#FiniteVolumeMethod.has_dirichlet_nodes","page":"Section Overview","title":"FiniteVolumeMethod.has_dirichlet_nodes","text":"has_dirichlet_nodes(conds)\n\nCheck if any node has a Dirichlet condition.\n\n\n\n\n\n","category":"function"},{"location":"wyos/overview/#FiniteVolumeMethod.get_dudt_fidx","page":"Section Overview","title":"FiniteVolumeMethod.get_dudt_fidx","text":"get_dudt_fidx(conds, node)\n\nGet the index of the function that corresponds to the Dudt condition at node.\n\n\n\n\n\n","category":"function"},{"location":"wyos/overview/#FiniteVolumeMethod.is_dudt_node","page":"Section Overview","title":"FiniteVolumeMethod.is_dudt_node","text":"is_dudt_node(conds, node)\n\nCheck if node has a Dudt condition.\n\n\n\n\n\n","category":"function"},{"location":"wyos/overview/#FiniteVolumeMethod.get_dudt_nodes","page":"Section Overview","title":"FiniteVolumeMethod.get_dudt_nodes","text":"get_dudt_nodes(conds)\n\nGet all nodes that have a Dudt condition.\n\n\n\n\n\n","category":"function"},{"location":"wyos/overview/#FiniteVolumeMethod.has_dudt_nodes","page":"Section Overview","title":"FiniteVolumeMethod.has_dudt_nodes","text":"has_dudt_nodes(conds)\n\nCheck if any node has a Dudt condition.\n\n\n\n\n\n","category":"function"},{"location":"wyos/overview/#FiniteVolumeMethod.get_neumann_fidx","page":"Section Overview","title":"FiniteVolumeMethod.get_neumann_fidx","text":"get_neumann_fidx(conds, i, j)\n\nGet the index of the function that corresponds to the Neumann condition at the edge (i, j).\n\n\n\n\n\n","category":"function"},{"location":"wyos/overview/#FiniteVolumeMethod.is_neumann_edge","page":"Section Overview","title":"FiniteVolumeMethod.is_neumann_edge","text":"is_neumann_edge(conds, i, j)\n\nCheck if the edge (i, j) has a Neumann condition.\n\n\n\n\n\n","category":"function"},{"location":"wyos/overview/#FiniteVolumeMethod.has_neumann_edges","page":"Section Overview","title":"FiniteVolumeMethod.has_neumann_edges","text":"has_neumann_edges(conds)\n\nCheck if any edge has a Neumann condition.\n\n\n\n\n\n","category":"function"},{"location":"wyos/overview/#FiniteVolumeMethod.get_neumann_edges","page":"Section Overview","title":"FiniteVolumeMethod.get_neumann_edges","text":"get_neumann_edges(conds)\n\nGet all edges that have a Neumann condition.\n\n\n\n\n\n","category":"function"},{"location":"wyos/overview/#FiniteVolumeMethod.get_constrained_fidx","page":"Section Overview","title":"FiniteVolumeMethod.get_constrained_fidx","text":"get_constrained_fidx(conds, i, j)\n\nGet the index of the function that corresponds to the Constrained condition at the edge (i, j).\n\n\n\n\n\n","category":"function"},{"location":"wyos/overview/#FiniteVolumeMethod.is_constrained_edge","page":"Section Overview","title":"FiniteVolumeMethod.is_constrained_edge","text":"is_constrained_edge(conds, i, j)\n\nCheck if the edge (i, j) has a Constrained condition.\n\n\n\n\n\n","category":"function"},{"location":"wyos/overview/#FiniteVolumeMethod.has_constrained_edges","page":"Section Overview","title":"FiniteVolumeMethod.has_constrained_edges","text":"has_constrained_edges(conds)\n\nCheck if any edge has a Constrained condition.\n\n\n\n\n\n","category":"function"},{"location":"wyos/overview/#FiniteVolumeMethod.get_constrained_edges","page":"Section Overview","title":"FiniteVolumeMethod.get_constrained_edges","text":"get_constrained_edges(conds)\n\nGet all edges that have a Constrained condition.\n\n\n\n\n\n","category":"function"},{"location":"wyos/overview/#FiniteVolumeMethod.eval_condition_fnc","page":"Section Overview","title":"FiniteVolumeMethod.eval_condition_fnc","text":"eval_condition_fnc(conds, fidx, x, y, t, u)\n\nEvaluate the function that corresponds to the condition at fidx at the point (x, y) at time t with solution u.\n\n\n\n\n\n","category":"function"},{"location":"wyos/overview/#FiniteVolumeMethod.has_condition","page":"Section Overview","title":"FiniteVolumeMethod.has_condition","text":"has_condition(conds, node)\n\nCheck if node has any condition.\n\n\n\n\n\n","category":"function"},{"location":"wyos/overview/#FiniteVolumeMethod.get_cv_components","page":"Section Overview","title":"FiniteVolumeMethod.get_cv_components","text":"get_cv_components(props, edge_index)\n\nGet the quantities for a control volume edge interior to the associated triangulation, relative to the edge_indexth edge of the triangle corresponding to props.\n\nOutputs\n\nx: The x-coordinate of the edge's midpoint. \ny: The y-coordinate of the edge's midpoint.\nnx: The x-component of the edge's normal vector.\nny: The y-component of the edge's normal vector.\nℓ: The length of the edge.\n\n\n\n\n\n","category":"function"},{"location":"wyos/overview/#FiniteVolumeMethod.get_boundary_cv_components","page":"Section Overview","title":"FiniteVolumeMethod.get_boundary_cv_components","text":"get_boundary_cv_components(tri::Triangulation, i, j)\n\nGet the quantities for both control volume edges lying a boundary edge (i, j).\n\nOutputs\n\nnx: The x-component of the edge's normal vector.\nny: The y-component of the edge's normal vector.\nmᵢx: The x-coordinate of the midpoint of the ith vertex and the edge's midpoint.\nmᵢy: The y-coordinate of the midpoint of the ith vertex and the edge's midpoint.\nmⱼx: The x-coordinate of the midpoint of the jth vertex and the edge's midpoint.\nmⱼy: The y-coordinate of the midpoint of the jth vertex and the edge's midpoint.\nℓᵢ: Half the length of the boundary edge, which is the length of the control volume edge.\nT: The triangle containing the boundary edge.\nprops: The TriangleProperties for T.\n\n\n\n\n\n","category":"function"},{"location":"wyos/overview/#FiniteVolumeMethod.get_triangle_props","page":"Section Overview","title":"FiniteVolumeMethod.get_triangle_props","text":"get_triangle_props(mesh, i, j, k)\n\nGet the TriangleProperties for the triangle (i, j, k) in mesh.\n\n\n\n\n\n","category":"function"},{"location":"wyos/overview/#FiniteVolumeMethod.get_volume","page":"Section Overview","title":"FiniteVolumeMethod.get_volume","text":"get_volume(mesh, i)\n\nGet the volume of the ith control volume in mesh.\n\n\n\n\n\n","category":"function"},{"location":"wyos/overview/#DelaunayTriangulation.get_point-Tuple{FVMGeometry, Any}","page":"Section Overview","title":"DelaunayTriangulation.get_point","text":"get_point(mesh, i)\n\nGet the ith point in mesh.\n\n\n\n\n\n","category":"method"},{"location":"wyos/overview/#FiniteVolumeMethod.triangle_contributions!","page":"Section Overview","title":"FiniteVolumeMethod.triangle_contributions!","text":"triangle_contributions!(A, mesh, conditions, diffusion_function, diffusion_parameters)\n\nAdd the contributions from each triangle to the matrix A, based on the equation \n\ndvu_it = frac1V_isum_sigma in mathcal E_i D(vb x_sigma)leftleft(s_k 11n_sigma^x + s_k 21n_sigma^yright)u_k1 + left(s_k 12n_sigma^x + s_k 22n_sigma^yright)u_k2 + left(s_k 13n_sigma^x + s_k 23n_sigma^yright)u_k3rightL_sigma + S_i \n\nas explained in the docs. Will not update any rows corresponding to  Dirichlet or Dudt nodes.\n\n\n\n\n\n","category":"function"},{"location":"wyos/overview/#FiniteVolumeMethod.apply_dirichlet_conditions!","page":"Section Overview","title":"FiniteVolumeMethod.apply_dirichlet_conditions!","text":"apply_dirichlet_conditions!(initial_condition, mesh, conditions)\n\nApplies the Dirichlet conditions specified in conditions to the initial_condition. The boundary  conditions are assumed to take the form a(x, y, t, u, p) -> Number, but t and u are passed  as nothing. Note that this assumes that the associated system (A, b) is such that A[i, :] is all  zero, and b[i] is zero, where i is a node with a Dirichlet condition.\n\n\n\n\n\n","category":"function"},{"location":"wyos/overview/#FiniteVolumeMethod.apply_dudt_conditions!","page":"Section Overview","title":"FiniteVolumeMethod.apply_dudt_conditions!","text":"apply_dudt_conditions!(b, mesh, conditions)\n\nApplies the Dudt conditions specified in conditions to the b vector. The boundary    conditions are assumed to take the form a(x, y, t, u, p) -> Number, but t and u are passed as nothing. Note that this assumes that the associated system (A, b) is such that A[i, :] is all zero, so that replacing b[i] with the boundary condition will set duᵢ/dt = b[i].\n\n\n\n\n\n","category":"function"},{"location":"wyos/overview/#FiniteVolumeMethod.boundary_edge_contributions!","page":"Section Overview","title":"FiniteVolumeMethod.boundary_edge_contributions!","text":"boundary_edge_contributions!(A, b, mesh, conditions, diffusion_function, diffusion_parameters)\n\nAdd the contributions from each boundary edge to the matrix A, based on the equation \n\ndvu_it = frac1V_isum_sigma in mathcal E_i D(vb x_sigma)leftleft(s_k 11n_sigma^x + s_k 21n_sigma^yright)u_k1 + left(s_k 12n_sigma^x + s_k 22n_sigma^yright)u_k2 + left(s_k 13n_sigma^x + s_k 23n_sigma^yright)u_k3rightL_sigma + S_i \n\nas explained in the docs. Will not update any rows corresponding to  Dirichlet or Dudt nodes.\n\n\n\n\n\n","category":"function"},{"location":"wyos/overview/#FiniteVolumeMethod.non_neumann_boundary_edge_contributions!","page":"Section Overview","title":"FiniteVolumeMethod.non_neumann_boundary_edge_contributions!","text":"non_neumann_boundary_edge_contributions!(A, mesh, conditions, diffusion_function, diffusion_parameters)\n\nAdd the contributions from each non-Neumann boundary edge to the matrix A, based on the equation\n\ndvu_it = frac1V_isum_sigma in mathcal E_i D(vb x_sigma)leftleft(s_k 11n_sigma^x + s_k 21n_sigma^yright)u_k1 + left(s_k 12n_sigma^x + s_k 22n_sigma^yright)u_k2 + left(s_k 13n_sigma^x + s_k 23n_sigma^yright)u_k3rightL_sigma + S_i \n\nas explained in the docs. Will not update any rows corresponding to  Dirichlet or Dudt nodes.\n\n\n\n\n\n","category":"function"},{"location":"wyos/overview/#FiniteVolumeMethod.neumann_boundary_edge_contributions!","page":"Section Overview","title":"FiniteVolumeMethod.neumann_boundary_edge_contributions!","text":"neumann_boundary_edge_contributions!(b, mesh, conditions, diffusion_function, diffusion_parameters)\n\nAdd the contributions from each Neumann boundary edge to the vector b, based on the equation\n\ndvu_it = frac1V_isum_sigma in mathcal E_i D(vb x_sigma)leftgrad u(vb x_sigma) vdot vu nrightL_sigma + S_i\n\nas explained in the docs. Will not update any rows corresponding to  Dirichlet or Dudt nodes. This function will pass nothing in place  of the arguments u and t in the boundary condition functions.\n\n\n\n\n\nneumann_boundary_edge_contributions!(F, mesh, conditions, diffusion_function, diffusion_parameters, u, t)\n\nAdd the contributions from each Neumann boundary edge to the vector F, based on the equation\n\ndvu_it = frac1V_isum_sigma in mathcal E_i D(vb x_sigma)leftgrad u(vb x_sigma) vdot vu nrightL_sigma + S_i\n\nas explained in the docs. Will not update any rows corresponding to  Dirichlet or Dudt nodes. \n\n\n\n\n\n","category":"function"},{"location":"wyos/overview/#FiniteVolumeMethod.create_rhs_b","page":"Section Overview","title":"FiniteVolumeMethod.create_rhs_b","text":"create_rhs_b(mesh, conditions, source_function, source_parameters)\n\nCreate the vector b defined by \n\nb = [source_function(x, y, source_parameters) for (x, y) in DelaunayTriangulation.each_point(mesh.triangulation)],\n\nand b[i] = 0 whenever i is a Dirichlet node.\n\n\n\n\n\n","category":"function"},{"location":"wyos/overview/#FiniteVolumeMethod.apply_steady_dirichlet_conditions!","page":"Section Overview","title":"FiniteVolumeMethod.apply_steady_dirichlet_conditions!","text":"apply_steady_dirichlet_conditions!(A, b, mesh, conditions)\n\nApplies the Dirichlet conditions specified in conditions to the initial_condition. The boundary  conditions are assumed to take the form a(x, y, t, u, p) -> Number, but t and u are passed  as nothing. Note that this assumes that the associated system (A, b) is such that A[i, :] is all  zero, and b[i] is zero, where i is a node with a Dirichlet condition.\n\nFor a steady problem Au = b, applies the Dirichlet boundary conditions specified by conditions  so that A[i, i] = 1 and b[i] is the condition, where i is a boundary node. Note that this  assumes that all of A[i, :] is zero before setting A[i, i] = 1.\n\n\n\n\n\n","category":"function"},{"location":"wyos/overview/#FiniteVolumeMethod.two_point_interpolant","page":"Section Overview","title":"FiniteVolumeMethod.two_point_interpolant","text":"two_point_interpolant(mesh, u, i, j, mx, my)\n\nGiven a mesh <: FVMGeometry, a set of function values u at the nodes of mesh,  and a point (mx, my) on the line segment between the nodes i and j, interpolates the solution at the point (mx, my) using two-point interpolation.\n\n\n\n\n\n","category":"function"},{"location":"wyos/overview/#FiniteVolumeMethod.get_dirichlet_callback","page":"Section Overview","title":"FiniteVolumeMethod.get_dirichlet_callback","text":"get_dirichlet_callback(prob[, f=update_dirichlet_nodes!]; kwargs...)\n\nGet the callback for updating Dirichlet nodes. The kwargs... argument is ignored,  except to detect if a user has already provided a callback, in which case the  callback gets merged into a CallbackSet with the Dirichlet callback. If the problem  prob has no Dirichlet nodes, the returned callback does nothing and is never  called.\n\nYou can provide f to change the function that updates the Dirichlet nodes.\n\n\n\n\n\n","category":"function"},{"location":"wyos/overview/#FiniteVolumeMethod.jacobian_sparsity","page":"Section Overview","title":"FiniteVolumeMethod.jacobian_sparsity","text":"jacobian_sparsity(prob)\n\nReturns a prototype for the Jacobian of the given prob.\n\n\n\n\n\n","category":"function"},{"location":"wyos/overview/#FiniteVolumeMethod.fix_missing_vertices!","page":"Section Overview","title":"FiniteVolumeMethod.fix_missing_vertices!","text":"fix_missing_vertices!(A, b, mesh)\n\nGiven a system (A, b) and a mesh, sets A[i, i] = 1 and b[i] = 0 for any vertices i  that are a point in mesh, but not an actual vertex in the mesh.\n\n\n\n\n\n","category":"function"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"EditURL = \"https://github.com/SciML/FiniteVolumeMethod.jl/tree/main/docs/src/literate_wyos/mean_exit_time.jl\"","category":"page"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"using DisplayAs #hide\ntc = DisplayAs.withcontext(:displaysize => (15, 80), :limit => true); #hide\nnothing #hide","category":"page"},{"location":"wyos/mean_exit_time/#Mean-Exit-Time-Problems","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"","category":"section"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"Pages = [\"mean_exit_time.md\"]","category":"page"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"We now write a specialised solver for solving mean exit time problems. What we produce in this section can also be accessed in FiniteVolumeMethod.MeanExitTimeProblem.","category":"page"},{"location":"wyos/mean_exit_time/#Mathematical-Details","page":"Mean Exit Time Problems","title":"Mathematical Details","text":"","category":"section"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"To start, we give the mathematical details. We will be solving mean exit time problems of the form","category":"page"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"beginequation\ndiv leftD(vb x)grad Tright = -1\nendequation","category":"page"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"with homogeneous Neumann or Dirichlet conditions on parts of the boundary; homogeneous Neumann conditions represent reflecting parts of the boundary, while homogeneous Dirichlet conditions represent absorbing parts of the boundary.","category":"page"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"The mathematical details for this section are similar to those from the diffusion equation discussion here, except that the source term is 1 instead of 0, and mathrm dT_imathrm dt = 0 everywhere. In particular, we can reuse some details from the diffusion equation discussion to immediately write","category":"page"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"frac1V_isum_sigmainmathcal E_i D(vb x_sigma)leftleft(s_k 11n_sigma^x+s_k21n_sigma^yright)T_k1 + left(s_k12n_sigma^x+s_k22n_sigma^yright)T_k2+left(s_k13n_sigma^x+s_k23n_sigma^yright)T_k3rightL_sigma = -1","category":"page"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"Equivalently, defining vb a_i appropriately and b_i=-1 (we don't normalise by V_i in b_i and instead keep it in vb a_i, since we want to reuse some existing functions later), we can write","category":"page"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"vb a_i^mkern-15mumathsf Tvb T = b_i","category":"page"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"Since we have homogeneous Neumann boundary conditions (wherever a Neumann boundary condition is given, at least), we don't have to worry about looping over the boundary edges - they just get skipped. For the Dirichlet nodes i, we let vb a_i = vb e_i and b_i = 0 (since the Dirichlet conditions should be homogeneous).","category":"page"},{"location":"wyos/mean_exit_time/#Implementation","page":"Mean Exit Time Problems","title":"Implementation","text":"","category":"section"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"Let us now implement this. There is a lot that we can reuse from our diffusion equation template. The function that gets the contributions from each triangle can be reused exactly, which is available in FiniteVolumeMethod.triangle_contributions!. For applying the Dirichlet boundary conditions, we need to know that FiniteVolumeMethod.triangle_contributions! does not change vb A for nodes with conditions. For this problem, though, we need a_ii = 1 for Dirichlet nodes i. So, let's write a function that creates vb b but also enforces Dirichlet constraints.","category":"page"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"function create_met_b!(A, mesh, conditions)\n    b = zeros(DelaunayTriangulation.num_points(mesh.triangulation))\n    for i in each_solid_vertex(mesh.triangulation)\n        if !FVM.is_dirichlet_node(conditions, i)\n            b[i] = -1\n        else\n            A[i, i] = 1.0 # b[i] = is already zero\n        end\n    end\n    return b\nend","category":"page"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"Let us now define the function which gives us our matrices vb A and vb b. We will return the problem as a LinearProblem from LinearSolve.jl.","category":"page"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"using FiniteVolumeMethod, SparseArrays, DelaunayTriangulation, LinearSolve\nconst FVM = FiniteVolumeMethod\nfunction met_problem(mesh::FVMGeometry,\n    BCs::BoundaryConditions, # the actual implementation also checks that the types are only Dirichlet/Neumann\n    ICs::InternalConditions=InternalConditions();\n    diffusion_function,\n    diffusion_parameters=nothing)\n    conditions = Conditions(mesh, BCs, ICs)\n    n = DelaunayTriangulation.num_points(mesh.triangulation)\n    A = zeros(n, n)\n    FVM.triangle_contributions!(A, mesh, conditions, diffusion_function, diffusion_parameters)\n    b = create_met_b!(A, mesh, conditions)\n    FVM.fix_missing_vertices!(A, b, mesh)\n    return LinearProblem(sparse(A), b)\nend","category":"page"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"Now let us test this problem. To test, we will consider the last problem here which includes mixed boundary conditions and also an internal condition.","category":"page"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"# Define the triangulation\nR₁, R₂ = 2.0, 3.0\nε = 0.05\ng = θ -> sin(3θ) + cos(5θ)\nR1_f = let R₁ = R₁, ε = ε, g = g # use let for type stability\n    θ -> R₁ * (1.0 + ε * g(θ))\nend\nϵr = 0.25\ndirichlet = CircularArc((R₂ * cos(ϵr), R₂ * sin(ϵr)), (R₂ * cos(2π - ϵr), R₂ * sin(2π - ϵr)), (0.0, 0.0))\nneumann = CircularArc((R₂ * cos(2π - ϵr), R₂ * sin(2π - ϵr)), (R₂ * cos(ϵr), R₂ * sin(ϵr)), (0.0, 0.0))\nhole = CircularArc((0.0, 1.0), (0.0, 1.0), (0.0, 0.0), positive=false)\nboundary_nodes = [[[dirichlet], [neumann]], [[hole]]]\npoints = [(-2.0, 0.0), (0.0, 2.95)]\ntri = triangulate(points; boundary_nodes)\nθ = LinRange(0, 2π, 250)\nxin = @views (@. R1_f(θ) * cos(θ))[begin:end-1]\nyin = @views (@. R1_f(θ) * sin(θ))[begin:end-1]\nadd_point!(tri, xin[1], yin[1])\nfor i in 2:length(xin)\n    add_point!(tri, xin[i], yin[i])\n    n = DelaunayTriangulation.num_points(tri)\n    add_segment!(tri, n - 1, n)\nend\nn = DelaunayTriangulation.num_points(tri)\nadd_segment!(tri, n - 1, n)\npointhole_idxs = [1, 2]\nrefine!(tri; max_area=1e-3get_area(tri));\n# Define the problem\nmesh = FVMGeometry(tri)\nzero_f = (x, y, t, u, p) -> zero(u) # the function doesn't actually matter, but it still needs to be provided\nBCs = BoundaryConditions(mesh, (zero_f, zero_f, zero_f), (Neumann, Dirichlet, Dirichlet))\nICs = InternalConditions((x, y, t, u, p) -> zero(u), dirichlet_nodes=Dict(pointhole_idxs .=> 1))\nD₁, D₂ = 6.25e-4, 6.25e-5\ndiffusion_function = (x, y, p) -> begin\n    r = sqrt(x^2 + y^2)\n    ϕ = atan(y, x)\n    interface_val = p.R1_f(ϕ)\n    return r < interface_val ? p.D₁ : p.D₂\nend\ndiffusion_parameters = (D₁=D₁, D₂=D₂, R1_f=R1_f)\nprob = met_problem(mesh, BCs, ICs; diffusion_function, diffusion_parameters)\nprob |> tc #hide","category":"page"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"This problem can now be solved using the solve interface from LinearSolve.jl. Note that the matrix vb A is very dense, but there is no structure to it:","category":"page"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"prob.A\nprob.A |> DisplayAs.withcontext(:compact => true) #hide","category":"page"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"We will use KLUFactorization.","category":"page"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"sol = solve(prob, KLUFactorization())\nsol |> tc #hide","category":"page"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"We can easily visualise our solution:","category":"page"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"using CairoMakie\nfig, ax, sc = tricontourf(tri, sol.u, levels=0:1000:15000, extendhigh=:auto,\n    axis=(width=600, height=600, title=\"Template\"))\nfig","category":"page"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"This result is a great match to what we found in the tutorial. If we wanted to convert this mean exit time problem into the corresponding SteadyFVMProblem, we can do:","category":"page"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"function T_exact(x, y)\n    r = sqrt(x^2 + y^2)\n    if r < R₁\n        return (R₁^2 - r^2) / (4D₁) + (R₂^2 - R₁^2) / (4D₂)\n    else\n        return (R₂^2 - r^2) / (4D₂)\n    end\nend\ninitial_condition = [T_exact(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)] # an initial guess\nfvm_prob = SteadyFVMProblem(FVMProblem(mesh, BCs, ICs;\n    diffusion_function=let D = diffusion_function\n        (x, y, t, u, p) -> D(x, y, p)\n    end,\n    diffusion_parameters,\n    source_function=(x, y, t, u, p) -> one(u),\n    final_time=Inf,\n    initial_condition))","category":"page"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"Let's compare the two solutions.","category":"page"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"using SteadyStateDiffEq, OrdinaryDiffEq\nfvm_sol = solve(fvm_prob, DynamicSS(TRBDF2()))\nfvm_sol |> tc #hide","category":"page"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"ax = Axis(fig[1, 2], width=600, height=600, title=\"Template\")\ntricontourf!(ax, tri, fvm_sol.u, levels=0:1000:15000, extendhigh=:auto)\nresize_to_layout!(fig)\nfig\nind = findall(i -> DelaunayTriangulation.has_vertex(tri, i), DelaunayTriangulation.each_point_index(tri))","category":"page"},{"location":"wyos/mean_exit_time/#Using-the-Provided-Template","page":"Mean Exit Time Problems","title":"Using the Provided Template","text":"","category":"section"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"Let's now use the built-in MeanExitTimeProblem which implements the above template inside FiniteVolumeMethod.jl.","category":"page"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"prob = MeanExitTimeProblem(mesh, BCs, ICs;\n    diffusion_function,\n    diffusion_parameters)\nsol = solve(prob, KLUFactorization())\nsol |> tc #hide","category":"page"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"fig, ax, sc = tricontourf(tri, sol.u, levels=0:1000:15000, extendhigh=:auto,\n    axis=(width=600, height=600))\nfig","category":"page"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"This matches what we have above. To finish, here is a benchmark comparing the approaches.","category":"page"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"using BenchmarkTools\n@btime solve($prob, $KLUFactorization());","category":"page"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"  2.559 ms (56 allocations: 3.72 MiB)","category":"page"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"@btime solve($fvm_prob, $DynamicSS($KenCarp47(linsolve=KLUFactorization())));","category":"page"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"  221.851 ms (314440 allocations: 90.23 MiB)","category":"page"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"Very fast!","category":"page"},{"location":"wyos/mean_exit_time/#Just-the-code","page":"Mean Exit Time Problems","title":"Just the code","text":"","category":"section"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"function create_met_b!(A, mesh, conditions)\n    b = zeros(DelaunayTriangulation.num_points(mesh.triangulation))\n    for i in each_solid_vertex(mesh.triangulation)\n        if !FVM.is_dirichlet_node(conditions, i)\n            b[i] = -1\n        else\n            A[i, i] = 1.0 # b[i] = is already zero\n        end\n    end\n    return b\nend\n\nusing FiniteVolumeMethod, SparseArrays, DelaunayTriangulation, LinearSolve\nconst FVM = FiniteVolumeMethod\nfunction met_problem(mesh::FVMGeometry,\n    BCs::BoundaryConditions, # the actual implementation also checks that the types are only Dirichlet/Neumann\n    ICs::InternalConditions=InternalConditions();\n    diffusion_function,\n    diffusion_parameters=nothing)\n    conditions = Conditions(mesh, BCs, ICs)\n    n = DelaunayTriangulation.num_points(mesh.triangulation)\n    A = zeros(n, n)\n    FVM.triangle_contributions!(A, mesh, conditions, diffusion_function, diffusion_parameters)\n    b = create_met_b!(A, mesh, conditions)\n    FVM.fix_missing_vertices!(A, b, mesh)\n    return LinearProblem(sparse(A), b)\nend\n\n# Define the triangulation\nR₁, R₂ = 2.0, 3.0\nε = 0.05\ng = θ -> sin(3θ) + cos(5θ)\nR1_f = let R₁ = R₁, ε = ε, g = g # use let for type stability\n    θ -> R₁ * (1.0 + ε * g(θ))\nend\nϵr = 0.25\ndirichlet = CircularArc((R₂ * cos(ϵr), R₂ * sin(ϵr)), (R₂ * cos(2π - ϵr), R₂ * sin(2π - ϵr)), (0.0, 0.0))\nneumann = CircularArc((R₂ * cos(2π - ϵr), R₂ * sin(2π - ϵr)), (R₂ * cos(ϵr), R₂ * sin(ϵr)), (0.0, 0.0))\nhole = CircularArc((0.0, 1.0), (0.0, 1.0), (0.0, 0.0), positive=false)\nboundary_nodes = [[[dirichlet], [neumann]], [[hole]]]\npoints = [(-2.0, 0.0), (0.0, 2.95)]\ntri = triangulate(points; boundary_nodes)\nθ = LinRange(0, 2π, 250)\nxin = @views (@. R1_f(θ) * cos(θ))[begin:end-1]\nyin = @views (@. R1_f(θ) * sin(θ))[begin:end-1]\nadd_point!(tri, xin[1], yin[1])\nfor i in 2:length(xin)\n    add_point!(tri, xin[i], yin[i])\n    n = DelaunayTriangulation.num_points(tri)\n    add_segment!(tri, n - 1, n)\nend\nn = DelaunayTriangulation.num_points(tri)\nadd_segment!(tri, n - 1, n)\npointhole_idxs = [1, 2]\nrefine!(tri; max_area=1e-3get_area(tri));\n# Define the problem\nmesh = FVMGeometry(tri)\nzero_f = (x, y, t, u, p) -> zero(u) # the function doesn't actually matter, but it still needs to be provided\nBCs = BoundaryConditions(mesh, (zero_f, zero_f, zero_f), (Neumann, Dirichlet, Dirichlet))\nICs = InternalConditions((x, y, t, u, p) -> zero(u), dirichlet_nodes=Dict(pointhole_idxs .=> 1))\nD₁, D₂ = 6.25e-4, 6.25e-5\ndiffusion_function = (x, y, p) -> begin\n    r = sqrt(x^2 + y^2)\n    ϕ = atan(y, x)\n    interface_val = p.R1_f(ϕ)\n    return r < interface_val ? p.D₁ : p.D₂\nend\ndiffusion_parameters = (D₁=D₁, D₂=D₂, R1_f=R1_f)\nprob = met_problem(mesh, BCs, ICs; diffusion_function, diffusion_parameters)\n\nprob.A\n\nsol = solve(prob, KLUFactorization())\n\nusing CairoMakie\nfig, ax, sc = tricontourf(tri, sol.u, levels=0:1000:15000, extendhigh=:auto,\n    axis=(width=600, height=600, title=\"Template\"))\nfig\n\nfunction T_exact(x, y)\n    r = sqrt(x^2 + y^2)\n    if r < R₁\n        return (R₁^2 - r^2) / (4D₁) + (R₂^2 - R₁^2) / (4D₂)\n    else\n        return (R₂^2 - r^2) / (4D₂)\n    end\nend\ninitial_condition = [T_exact(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)] # an initial guess\nfvm_prob = SteadyFVMProblem(FVMProblem(mesh, BCs, ICs;\n    diffusion_function=let D = diffusion_function\n        (x, y, t, u, p) -> D(x, y, p)\n    end,\n    diffusion_parameters,\n    source_function=(x, y, t, u, p) -> one(u),\n    final_time=Inf,\n    initial_condition))\n\nusing SteadyStateDiffEq, OrdinaryDiffEq\nfvm_sol = solve(fvm_prob, DynamicSS(TRBDF2()))\n\nax = Axis(fig[1, 2], width=600, height=600, title=\"Template\")\ntricontourf!(ax, tri, fvm_sol.u, levels=0:1000:15000, extendhigh=:auto)\nresize_to_layout!(fig)\nfig\nind = findall(i -> DelaunayTriangulation.has_vertex(tri, i), DelaunayTriangulation.each_point_index(tri))\n\nprob = MeanExitTimeProblem(mesh, BCs, ICs;\n    diffusion_function,\n    diffusion_parameters)\nsol = solve(prob, KLUFactorization())\n\nfig, ax, sc = tricontourf(tri, sol.u, levels=0:1000:15000, extendhigh=:auto,\n    axis=(width=600, height=600))\nfig","category":"page"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"","category":"page"},{"location":"wyos/mean_exit_time/","page":"Mean Exit Time Problems","title":"Mean Exit Time Problems","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"EditURL = \"https://github.com/SciML/FiniteVolumeMethod.jl/tree/main/docs/src/literate_tutorials/laplaces_equation_with_internal_dirichlet_conditions.jl\"","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"using DisplayAs #hide\ntc = DisplayAs.withcontext(:displaysize => (15, 80), :limit => true); #hide\nnothing #hide","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/#Laplace's-Equation-with-Internal-Dirichlet-Conditions","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"","category":"section"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"In this tutorial, we consider Laplace's equation with some additional complexity put into the problem via internal Dirichlet conditions:","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"beginequation\nbeginaligned\ngrad^2 u = 0  vb x in 0 1^2 \nu(0 y) = 100y  0 leq y leq 1 \nu(1 y) = 100y  0 leq y leq 1 \nu(x 0) = 0  0 leq x leq 1 \nu(x 1) = 100  0 leq x leq 1 \nu(12 y) = 0  0 leq y leq 25\nendaligned\nendequation","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"To start with solving this problem, let us define an initial mesh.","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"using DelaunayTriangulation, FiniteVolumeMethod\ntri = triangulate_rectangle(0, 1, 0, 1, 50, 50, single_boundary=false)","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"In this mesh, we don't have any points that lie exactly on the line x = 12 0 leq y leq 25, so we cannot enforce this constraint exactly.[1] Instead, we need to add these points into tri. We do not need to add any constrained edges in this case, since these internal conditions are enforced only at points.","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"[1]: Of course, by defining the grid spacing appropriately we could have such points, but we just want to show here how we can add these points in if needed.","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"Let us now add in the points.","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"using CairoMakie\nnew_points = LinRange(0, 2 / 5, 250)\nfor y in new_points\n    add_point!(tri, 1 / 2, y)\nend\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"It may also help to refine the mesh slightly.","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"refine!(tri, max_area=1e-4)\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"mesh = FVMGeometry(tri)","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"Now that we have the mesh, we can define the boundary conditions. Remember that the order of the boundary indices is the bottom wall, right wall, top wall, and then the left wall.","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"bc_bot = (x, y, t, u, p) -> zero(u)\nbc_right = (x, y, t, u, p) -> oftype(u, 100y) # helpful to have each bc return the same type\nbc_top = (x, y, t, u, p) -> oftype(u, 100)\nbc_left = (x, y, t, u, p) -> oftype(u, 100y)\nbcs = (bc_bot, bc_right, bc_top, bc_left)\ntypes = (Dirichlet, Dirichlet, Dirichlet, Dirichlet)\nBCs = BoundaryConditions(mesh, bcs, types)","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"We now need to define the internal conditions. This is done using InternalConditions. First, we need to find all the vertices that lie on the line x = 12 0 leq y leq 25. We could compute these manually, but let's find them programatically instead for the sake of demonstration.","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"function find_all_points_on_line(tri)\n    vertices = Int[]\n    for i in each_solid_vertex(tri)\n        x, y = get_point(tri, i)\n        if x == 1 / 2 && 0 ≤ y ≤ 2 / 5\n            push!(vertices, i)\n        end\n    end\n    return vertices\nend\nvertices = find_all_points_on_line(tri)\nfig, ax, sc = triplot(tri)\npoints = [get_point(tri, i) for i in vertices]\nscatter!(ax, points, color=:red, markersize=10)\nfig","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"Now that we have the vertices, we can define the internal conditions. We need to provide InternalConditions with a Dict that maps each vertex in vertices to a function index that corresponds to the condition for that vertex. In this case, that function index is 1 as we only have a single function.","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"ICs = InternalConditions((x, y, t, u, p) -> zero(u),\n    dirichlet_nodes=Dict(vertices .=> 1))","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"Now we can define the problem. As discussed in the Helmholtz tutorial, we are looking to define a steady state problem, and so the initial condition needs to be a suitable initial guess of what the solution could be. Looking to the boundary and internal conditions, one suitable guess is u(x y) = 100y with u(12 y) = 0 for 0 leq y leq 25; in fact, u(x y) = 100y is the solution of the problem without the internal condition. Let us now use this to define our initial condition.","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"initial_condition = zeros(DelaunayTriangulation.num_points(tri))\nfor i in each_solid_vertex(tri)\n    x, y = get_point(tri, i)\n    initial_condition[i] = ifelse(x == 1 / 2 && 0 ≤ y ≤ 2 / 5, 0, 100y)\nend","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"Now let's define the problem. The internal conditions are provided as the third argument of FVMProblem.","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"diffusion_function = (x, y, t, u, p) -> one(u) # ∇²u = ∇⋅[D∇u], D = 1\nfinal_time = Inf\nprob = FVMProblem(mesh, BCs, ICs;\n    diffusion_function,\n    initial_condition,\n    final_time)","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"steady_prob = SteadyFVMProblem(prob)","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"Now let's solve the problem.","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"using SteadyStateDiffEq, LinearSolve, OrdinaryDiffEq\nsol = solve(steady_prob, DynamicSS(TRBDF2(linsolve=KLUFactorization())))\nsol |> tc #hide","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"fig, ax, sc = tricontourf(tri, sol.u, levels=LinRange(0, 100, 28))\ntightlimits!(ax)\nfig","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/#Just-the-code","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Just the code","text":"","category":"section"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"using DelaunayTriangulation, FiniteVolumeMethod\ntri = triangulate_rectangle(0, 1, 0, 1, 50, 50, single_boundary=false)\n\nusing CairoMakie\nnew_points = LinRange(0, 2 / 5, 250)\nfor y in new_points\n    add_point!(tri, 1 / 2, y)\nend\nfig, ax, sc = triplot(tri)\nfig\n\nrefine!(tri, max_area=1e-4)\nfig, ax, sc = triplot(tri)\nfig\n\nmesh = FVMGeometry(tri)\n\nbc_bot = (x, y, t, u, p) -> zero(u)\nbc_right = (x, y, t, u, p) -> oftype(u, 100y) # helpful to have each bc return the same type\nbc_top = (x, y, t, u, p) -> oftype(u, 100)\nbc_left = (x, y, t, u, p) -> oftype(u, 100y)\nbcs = (bc_bot, bc_right, bc_top, bc_left)\ntypes = (Dirichlet, Dirichlet, Dirichlet, Dirichlet)\nBCs = BoundaryConditions(mesh, bcs, types)\n\nfunction find_all_points_on_line(tri)\n    vertices = Int[]\n    for i in each_solid_vertex(tri)\n        x, y = get_point(tri, i)\n        if x == 1 / 2 && 0 ≤ y ≤ 2 / 5\n            push!(vertices, i)\n        end\n    end\n    return vertices\nend\nvertices = find_all_points_on_line(tri)\nfig, ax, sc = triplot(tri)\npoints = [get_point(tri, i) for i in vertices]\nscatter!(ax, points, color=:red, markersize=10)\nfig\n\nICs = InternalConditions((x, y, t, u, p) -> zero(u),\n    dirichlet_nodes=Dict(vertices .=> 1))\n\ninitial_condition = zeros(DelaunayTriangulation.num_points(tri))\nfor i in each_solid_vertex(tri)\n    x, y = get_point(tri, i)\n    initial_condition[i] = ifelse(x == 1 / 2 && 0 ≤ y ≤ 2 / 5, 0, 100y)\nend\n\ndiffusion_function = (x, y, t, u, p) -> one(u) # ∇²u = ∇⋅[D∇u], D = 1\nfinal_time = Inf\nprob = FVMProblem(mesh, BCs, ICs;\n    diffusion_function,\n    initial_condition,\n    final_time)\n\nsteady_prob = SteadyFVMProblem(prob)\n\nusing SteadyStateDiffEq, LinearSolve, OrdinaryDiffEq\nsol = solve(steady_prob, DynamicSS(TRBDF2(linsolve=KLUFactorization())))\n\nfig, ax, sc = tricontourf(tri, sol.u, levels=LinRange(0, 100, 28))\ntightlimits!(ax)\nfig","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"math/#Mathematical-and-Implementation-Details","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"","category":"section"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Pages = [\"math.md\"]","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Here we outline the mathematical and implementation details involved in implementing the finite volume method (FVM). We assume that our partial differential equation (PDE) is given by ","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequation\nlabeleqpde\npdvu(vb x t)t + div vb q(vb x t u) = S(vb x t u) quad vb x in Omega\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"together with some boundary conditions or internal conditions that we discuss later. We also discuss steady-state problems and systems of PDEs of the form \\eqref{eq:pde}.","category":"page"},{"location":"math/#Interior-Discretisation","page":"Mathematical and Implementation Details","title":"Interior Discretisation","text":"","category":"section"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Let us start by discretising \\eqref{eq:pde} inside Omega. The first step in this discretisation is to compute a triangulation of Omega, decomposing Omega into a collection of disjoint triangles T_k so that ","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Omega = bigcup_k T_k","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"This triangulation is typically a constrained Delaunay triangulation, denoted mathcal T(Omega), with appropriate care taken if Omega is multiply-connected; these triangulations can be computed using DelaunayTriangulation.jl. An example of such a domain Omega and its triangulation mathcal T(Omega) is shown below, where we use a multiply-connected domain to emphasise that these details are not necessarily restricted to simple domains.","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"using DelaunayTriangulation, CairoMakie\nθ = LinRange(0, 2π, 50)\nθ = collect(θ)\nθ[end] = θ[begin]\ng = θ -> cos(θ) - sin(3θ) + sin(5θ)\nε = 1 / 10\nx = @. (1 + g(θ) * ε) * cos(θ)\ny = @. (1 + g(θ) * ε) * sin(θ)\nh = θ -> cos(3θ) - sin(θ)\nε = 1 / 5\nx2 = @. 0.5(1 + h(θ) * ε) * cos(θ)\ny2 = @. 0.5(1 + h(θ) * ε) * sin(θ)\nreverse!(x2)\nreverse!(y2)\nboundary_nodes, points = convert_boundary_points_to_indices([[x], [x2]], [[y], [y2]])\ntri = triangulate(points; boundary_nodes, delete_ghosts=false)\nrefine!(tri)\nfig, ax, sc = triplot(tri,\n    show_convex_hull=false,\n    show_constrained_edges=false)\nhidedecorations!(ax)","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"fig #hide","category":"page"},{"location":"math/#Control-volumes","page":"Mathematical and Implementation Details","title":"Control volumes","text":"","category":"section"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Key to the FVM are the control volumes, which are used to define volumes Omega_i around individual vertices vb x_i that we integrate the PDE over. To define these volumes, take vb x_i in Omega, which is a vertex of mathcal T(Omega), and take the set of triangles mathcal T_i = T_k that have vb x_i as a vertex. For each of these triangles T_k in mathcal T_i, connect its centroid to the midpoints of the triangle's edges. Once this procedure is complete, we obtain a closed polygon around vb x_i that we denote by partialOmega_i and whose interior defines the control volume Omega_i. We show the result of this procedure, applied to the above domain, below, where we show the centroids in red and the control volume boundaries in blue.","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"centroids = NTuple{2,Float64}[]\nlinesegments = NTuple{2,Float64}[]\nfor T in each_solid_triangle(tri)\n    i, j, k = triangle_vertices(T)\n    p, q, r = get_point(tri, i, j, k)\n    cent = DelaunayTriangulation.triangle_centroid(p, q, r)\n    push!(centroids, cent)\n    u, v, w = DelaunayTriangulation.triangle_edge_midpoints(p, q, r)\n    push!(linesegments, cent, u, cent, v, cent, w)\nend\nlinesegments!(ax, linesegments, color=:blue)\nscatter!(ax, centroids, color=:red, markersize=8)","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"fig #hide","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Let us now establish some notation for referring to these control volumes, using the figure below  as a reference.","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Symbol Description Example\nvb x_i A vertex of mathcal T(Omega) The blue point below\nOmega_i The control volume around vb x_i The green region below\npartialOmega_i The boundary of Omega_i The blue edges below\nV_i The volume of Omega_i The volume of the green region below\nmathcal E_i The set of edges of partialOmega_i The blue edges below\nsigma An edge sigma in mathcal E_i The magenta edge below. Note that bigcup_sigma in mathcal E_i sigma = partialOmega_i\nvb x_sigma The midpoint of sigma in mathcal E_i The blue point below on sigma\nhatvb n_sigma The outward unit normal vector to sigma in mathcal E_i The black arrow below\nmathcal T_i The set of triangles that have vb x_i as a vertex The black triangles surrounding vb x_i below\nL_sigma The length of sigma in mathcal E_i The length of the magenta edge below","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"using DelaunayTriangulation, CairoMakie, LinearAlgebra\na, b, c, d, e, f = (0.0, 0.0),\n(2.0, 3.0),\n(4.0, -1.0),\n(1.0, -4.0),\n(-4.0, -2.0),\n(-4.0, 2.0)\npoints = [a, b, c, d, e, f]\ntri = triangulate(points)\n\ncentroids = NTuple{2,Float64}[]\nlinesegments = NTuple{2,Float64}[]\nother_linesegments = NTuple{2,Float64}[]\nnon_cv_midpoints = collect.([\n    (f .+ b) ./ 2,\n    (b .+ c) ./ 2,\n    (c .+ d) ./ 2,\n    (d .+ e) ./ 2,\n    (e .+ f) ./ 2\n])\nfor T in each_solid_triangle(tri)\n    i, j, k = triangle_vertices(T)\n    p, q, r = get_point(tri, i, j, k)\n    cent = DelaunayTriangulation.triangle_centroid(p, q, r)\n    push!(centroids, cent)\n    u, v, w = DelaunayTriangulation.triangle_edge_midpoints(p, q, r)\n    any(≈(collect(u)), non_cv_midpoints) ? push!(other_linesegments, cent, u) : push!(linesegments, cent, u)\n    any(≈(collect(v)), non_cv_midpoints) ? push!(other_linesegments, cent, v) : push!(linesegments, cent, v)\n    any(≈(collect(w)), non_cv_midpoints) ? push!(other_linesegments, cent, w) : push!(linesegments, cent, w)\nend\n\ncontrol_volume_verts = vcat(linesegments, centroids)\ncv_idx = collect(eachindex(control_volume_verts))\nDelaunayTriangulation.sort_convex_polygon!(cv_idx, control_volume_verts)\nfig, ax, sc = poly(control_volume_verts[cv_idx],\n    color=:lightgreen,\n    axis=(width=400, height=400))\ntriplot!(tri,\n    show_convex_hull=false,\n    show_constrained_edges=false,\n    show_all_points=true,\n    point_color=:black,\n    markersize=11)\nscatter!(ax, [a, b, c], color=:cyan, markersize=11, strokecolor=:black, strokewidth=1)\nlinesegments!(ax, linesegments, color=:blue, linewidth=3)\nlinesegments!(ax, other_linesegments, color=(:grey, 0.5))\n\ncidx = findfirst(≈(collect((f .+ a .+ b) ./ 3)), collect.(centroids))\nlidx = findfirst(≈(collect((f .+ a) ./ 2)), collect.(linesegments))\nu, v = centroids[cidx], linesegments[lidx]\nrot90_uv = [0 -1; 1 0] * collect(u .- v)\nrot90_uv = 0.8rot90_uv ./ norm(rot90_uv)\nm = (u .+ v) ./ 2\np = scatter!(ax, [m], color=:blue, markersize=11, strokecolor=:black, strokewidth=1)\narrows!(ax, [m[1]], [m[2]], [rot90_uv[1]], [rot90_uv[2]], color=:black)\nlines!(ax, [u, v], color=:magenta, linewidth=3)\ntranslate!(p, 0, 0, 1)\n\nscatter!(ax, centroids, color=:red, markersize=11, strokecolor=:black, strokewidth=1)\ntext!(ax, -0.8, -1.7, text=L\"\\Omega_i\", fontsize=24)\ntext!(ax, -3.2, -1.0, text=L\"\\partial\\Omega_i\", fontsize=24)\ntext!(ax, -2.0, 1.1, text=L\"\\sigma\", fontsize=24)\ntext!(ax, -2.4, 1.6, text=L\"\\hat{\\mathbf{n}}_{\\sigma}\", fontsize=24)\ntext!(ax, -1.4, 0.8, text=L\"\\mathbf{x}_{\\sigma}\", fontsize=24)\ntext!(ax, 0.2, 0.0, text=L\"\\mathbf{x}_{i}\", fontsize=24)\ntext!(ax, 0.2, -0.5, text=L\"v_{k1}\", fontsize=24)\ntext!(ax, 3.1, -1.3, text=L\"v_{k2}\", fontsize=24)\ntext!(ax, 2.1, 2.9, text=L\"v_{k3}\", fontsize=24)\ntext!(ax, 1.7, 1.5, text=L\"T_k\", fontsize=24)\n\nhidedecorations!(ax)\nresize_to_layout!(fig)","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"fig #hide","category":"page"},{"location":"math/#Discretising-the-PDE","page":"Mathematical and Implementation Details","title":"Discretising the PDE","text":"","category":"section"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Now that we have our concept of control volumes, we can discretise the PDE \\eqref{eq:pde}. We do this  by considering each PDE inside each Omega_i and integrating. For a given control volume Omega_i, we can integrate the PDE to give","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqintegratedi\ndvtiint_Omega_i uddV + iint_Omega_i divvb q ddV = iint_Omega_i S ddV\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Using the divergence theorem, the second integral in \\eqref{eq:integratedi} becomes","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqapplieddthm\niint_Omega_i divvb q = oint_partialOmega_i vb q vdot vu n_sigma dds = sum_sigma in mathcal E_i int_sigma vb q vdot vu n_sigma dds\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"where the last equality in \\eqref{eq:applieddthm} follows from integrating over each individual line segment that defines partialOmega_i, which is simply mathcal E_i. We then define the control volume averages,","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqaverages\nbar u_i = frac1V_iiint_Omega_i uddVquad bar S_i = frac1V_iiint_Omega_i SddV\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"so that our integral formulation \\eqref{eq:integratedi} becomes","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqintform\ndvbar u_it + frac1V_isum_sigmainmathcal E_iint_sigma vb q vdot vu n_sigma dds = bar S_i\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Note that \\eqref{eq:intform} is still an exact expression.","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"To proceed, we need to approximate the integrals int_sigma vb q vdot vu n_sigmadds. To accomplish this, we use a midpoint rule, writing","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqmidpt_rule\nint_sigma vb q vdot vu n_sigma dds approx leftvb q(vb x_sigma t u(vb x_sigma t))vdot vu n_sigmarightL_sigma\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Then, replacing the control volume averages with their value at vb x_i, we obtain the following approximation:","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqnextapprox\ndvu_it + frac1V_isum_sigmainmathcal E_i leftvb q(vb x_sigma t u(vb x_sigma t)) vdot vu n_sigmarightL_sigma = S_i\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"where u_i = u(vb x_i t) and S_i = S(vb x_i t). ","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"The final step in this part of the approximation is the evaluation of vb q(vb x_sigma t u(vb x_sigma t)). To deal with this function, consider some T_k in mathcal T_i so that vb x_sigma is inside T_k. We use a linear shape function inside T_k to approximate u, writing","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqshape\nu(vb x t) = alpha_kx + beta_ky + gamma_k quad vb x in T_k\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"where we have suppressed the dependence of the coefficients (alpha_k beta_kgamma_k) on t. The vertices of T_k are given by v_k1 v_k2 v_k3 with corresponding coordinates vb x_k1 vb x_k2 vb x_k3, respectively. We can then solve for the coefficients in \\eqref{eq:shape} by requiring that u is equal to the values at the vertices of T_k, giving the system of equations","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqnear_cramer\nbeginaligned\nu(vb x_k1 t) = alpha_kx_k1 + beta_ky_k1 + gamma_k \nu(vb x_k2 t) = alpha_kx_k2 + beta_ky_k2 + gamma_k \nu(vb x_k3 t) = alpha_kx_k3 + beta_ky_k3 + gamma_k\nendaligned\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"where vb x_ki = (x_ki y_ki)^mkern-15mumathsfT. Note that the values on the left-hand side of \\eqref{eq:near_cramer} are all known from either the initial condition or the previous time-step. Using Cramer's rule, we define","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqshape_coeffs\nvb S_k = frac1Delta_kbeginbmatrix y_k2-y_k3  y_k3-y_k1  y_k1-y_k2  x_k3 - x_k2  x_k1-x_k3x_k2-x_k1  x_k2y_k3-x_k3y_k2  x_k3y_k1-x_k1y_k3x_k1y_k2-x_k2y_k1 endbmatrix\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"where","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqdeltak\nDelta_k = x_k1y_k2-x_k2y_k1-x_k1y_k3+x_k3y_k1+x_k2y_k3-x_k3y_k2\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"and thus we obtain","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqshapecoeffvals\nbeginaligned\nalpha_k = s_k11u_k1 + s_k12u_k2 + s_k13u_k3 \nbeta_k = s_k21u_k1 + s_k22u_k2 + s_k23u_k3 \ngamma_k = s_k31u_k1 + s_k32u_k2 + s_k33u_k3\nendaligned\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"where u_ki = u(vb x_ki t) and s_kij are the elements of vb S_k. With \\eqref{eq:shape} and \\eqref{eq:shapecoeffvals}, we can approximate vb q(vb x_sigma t u(vb x_sigma t)) and thus obtain the approximation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqinteriorapproximation\ndvu_it + frac1V_isum_sigmainmathcal E_i leftvb qleft(vb x_sigma t alpha_k(sigma)x_sigma + beta_k(sigma)y_sigma + gamma_k(sigma)right)vdot vu n_sigmarightL_sigma = S_i\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"where k(sigma) is the index of the triangle that contains vb x_sigma. This linear shape function also allows us to compute gradients like grad u(vb x_sigma t), since grad u(vb x_sigma t) = (alpha_k(sigma) beta_k(sigma))^mkern-15mumathsfT.","category":"page"},{"location":"math/#Boundary-Conditions","page":"Mathematical and Implementation Details","title":"Boundary Conditions","text":"","category":"section"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Let us now discuss how boundary conditions (BCs) are handled. We assume that BCs take on any of the following forms:","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginalign\nvb q(vb x t u) vdot vu n_sigma = a(vb x t u)  vb x in mathcal B subseteq partialOmega labeleqneumann \ndvu(vb x t)t = a(vb x t u)  vb x in mathcal B subseteq partialOmega labeleqdudtdirichlet \nu(vb x t) = a(vb x t u)  vb x in mathcal B subseteq partialOmega labeleqdirichlet\nendalign","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"where the functions a are user-provided functions. The conditions \\eqref{eq:neumann}–\\eqref{eq:dirichlet} are called Neumann, time-dependent Dirichlet, and Dirichlet, respectively. We discuss how we handle incompatible BCs below, and then how each of these three types are implemented. ","category":"page"},{"location":"math/#Dirichlet-boundary-conditions","page":"Mathematical and Implementation Details","title":"Dirichlet boundary conditions","text":"","category":"section"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"When we have a Dirichlet BC of the form \\eqref{eq:dirichlet}, the implementation is simple: Rather than using \\eqref{eq:interiorapproximation}, we instead leave mathrm du_imathrm dt = 0 and update the value of u_i with a(vb x_i t u_i) at the end of the iteration using a callback; note that the expression u_i = a(vb x_i t u_i) is not an implicit equation for u_i, rather it is simply a reassignment of u_i to a(vb x_i t u_i), i.e. u_i leftarrow a(vb x_i t u_i).","category":"page"},{"location":"math/#Time-dependent-Dirichlet-boundary-conditions","page":"Mathematical and Implementation Details","title":"Time-dependent Dirichlet boundary conditions","text":"","category":"section"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"For a time-dependent Dirichlet BC of the form \\eqref{eq:dudtdirichlet}, the implementation is again simple: Rather than using \\eqref{eq:interiorapproximation}, simply compute mathrm du_imathrm dt = a(vb x_i t u_i) instead. ","category":"page"},{"location":"math/#Neumann-boundary-conditions","page":"Mathematical and Implementation Details","title":"Neumann boundary conditions","text":"","category":"section"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Neumann boundary conditions \\eqref{eq:neumann} are the most complex out of the three. Let us return to our integral formulation \\eqref{eq:intform}. Let mathcal E_i^n be the set of edges in mathcal E_i that have a Neumann BC associated with them, and mathcal E_i^c = mathcal E_i setminus mathcal E_i^n. Then, also using \\eqref{eq:interiorapproximation}, in the case of \\eqref{eq:neumann} we can write","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqneumanndecomp\ndvu_it + frac1V_isum_sigmain mathcal E_i^c leftvb q(vb x_sigma t alpha_k(sigma)x_sigma + beta_k(sigma)y_sigma + gamma_k(sigma)) vdot vu n_sigmarightL_sigma + frac1V_isum_sigmainmathcal E_i^n int_sigma a_sigma(vb x t u)dds = S_i\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"where a_sigma is the BC function associated with sigma. This integral is then approximated using a midpoint rule as done previously, giving","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqneumanndecompapprox\ndvu_it + frac1V_isum_sigmain mathcal E_i^c leftvb q(vb x_sigma t u(vb x_sigma t)) vdot vu n_sigmarightL_sigma + frac1V_isum_sigmainmathcal E_i^n lefta_sigma(vb x_sigma t u(vb x_sigma t))rightL_sigma = S_i\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"where u(vb x_sigma t) = alpha_k(sigma)x_sigma + beta_k(sigma)y_sigma + gamma_k(sigma).","category":"page"},{"location":"math/#Internal-Conditions","page":"Mathematical and Implementation Details","title":"Internal Conditions","text":"","category":"section"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"We also allow for specifying internal conditions, meaning conditions of the form \\eqref{eq:neumann}–\\eqref{eq:dirichlet} that are applied away from the boundary. We do not currently allow for internal Neumann conditions directly.[1] These conditions are handled in the same way as BCs, except that the user is to provide them per-vertex rather than per-edge.","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"[1]: This is a technical limitation due to how the control volumes are defined. For vertices away from the boundary, the control volume edges do not lie along any of the triangle's edges, which is where we would like to impose Neumann conditions.","category":"page"},{"location":"math/#Putting-Everything-Together","page":"Mathematical and Implementation Details","title":"Putting Everything Together","text":"","category":"section"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"We have now specified how we discretise the PDE itself, and how we handle both boundary and internal conditions. The remaining task is to actually discuss how we compute mathrm du_imathrm dt. As written, \\eqref{eq:interiorapproximation} indicates that we loop over each vertex and, within each vertex, loop over each edge of its control volume. On average, mathcal E_i^c = 12 (since, on average, a point in a Delaunay triangulation has six neighbours), and so computing mathrm du_imathrm dt for each i requires mathcal O(12n) loop iterates and many repeated computations (since each control volume edge appears in another control volume), where n is the number of points in the mesh. An alternative approach is to instead loop over each triangle in mathcal T(Omega) and to then loop over each edge, adding the contributions from each to the associated vertices. This instead requires mathcal O(3mathcal T) loop iterates, where mathcal T is the number of triangles in mathcal T(Omega), and we instead only need to compute the relevant quantities for each control volume edge a single time; note that mathcal T = mathcal O(n) by Euler's formula. This is the approach we take in our implementation.","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Let us think about how we can instead loop over each triangle. Consider an interior control volume, shown below.","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"using DelaunayTriangulation, CairoMakie\nfunction get_control_volume(tri, i)\n    is_bnd, bnd_idx = DelaunayTriangulation.is_boundary_node(tri, i)\n    cv = NTuple{2,Float64}[]\n    if is_bnd\n        j = DelaunayTriangulation.get_right_boundary_node(tri, i, bnd_idx)\n        k = get_adjacent(tri, i, j)\n        p = get_point(tri, i)\n        push!(cv, p)\n        while !DelaunayTriangulation.is_ghost_vertex(k)\n            q, r = get_point(tri, j, k)\n            c = (p .+ q .+ r) ./ 3\n            m = (p .+ q) ./ 2\n            push!(cv, m, c)\n            j = k\n            k = get_adjacent(tri, i, j)\n            DelaunayTriangulation.is_ghost_vertex(k) && push!(cv, (p .+ r) ./ 2)\n        end\n        push!(cv, p)\n    else\n        S = DelaunayTriangulation.get_surrounding_polygon(tri, i)\n        push!(S, S[begin])\n        j = S[begin]\n        p = get_point(tri, i)\n        q = get_point(tri, j)\n        push!(cv, (p .+ q) ./ 2)\n        for k in S[2:end]\n            r = get_point(tri, k)\n            push!(cv, (p .+ q .+ r) ./ 3)\n            push!(cv, (p .+ r) ./ 2)\n            q = r\n        end\n    end\n    return cv\nend\na, b, c, d, e, f, g, h, i, j, k, ℓ = (0.0, 0.0),\n(2.0, 3.0),\n(4.0, -1.0),\n(1.0, -4.0),\n(-4.0, -2.0),\n(-4.0, 2.0),\n(-1.0, 5.0),\n(6.0, 3.0),\n(7.0, -2.0),\n(4.0, -5.0),\n(-3.0, -4.0),\n(-6.0, 0.0)\npoints = [a, b, c, d, e, f, g, h, i, j, k, ℓ]\ntri = triangulate(points)\n\nfig = Figure()\nax = Axis(fig[1, 1], width=400, height=400)\nfor i in 1:3\n    cv = get_control_volume(tri, i)\n    L = lines!(ax, cv, color=:blue, linewidth=3)\n    translate!(L, 0, 0, 1)\nend\npoly!(ax, [a, c, b],\n    color=:lightblue)\ntriplot!(tri,\n    show_convex_hull=false,\n    show_constrained_edges=false)\nscatter!(ax, [a, c, b], color=[:blue, :red, :darkgreen], strokecolor=:black, strokewidth=1)\ntext!(ax, 2.1, -0.3, text=L\"\\sigma_{br}\", fontsize=24)\ntext!(ax, 2.1, 1.0, text=L\"\\sigma_{rg}\", fontsize=24)\ntext!(ax, 1.0, 0.6, text=L\"\\sigma_{gb}\", fontsize=24)\nbr = lines!(ax, [(a .+ c) ./ 2, (a .+ b .+ c) ./ 3], color=:purple, linewidth=3)\ntranslate!(br, 0, 0, 1)\nbg = lines!(ax, [(a .+ b) ./ 2, (a .+ b .+ c) ./ 3], color=:teal, linewidth=3)\ntranslate!(bg, 0, 0, 1)\nrg = lines!(ax, [(b .+ c) ./ 2, (a .+ b .+ c) ./ 3], color=:yellow, linewidth=3)\ntranslate!(rg, 0, 0, 1)\nxlims!(ax, -3, 5.9)\nylims!(ax, -3.5, 4.5)\nhidedecorations!(ax)\nresize_to_layout!(fig)","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"fig #hide","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"We denote the triangle in blue by T, and refer to the blue, red, and green vertices by v_b, v_r, and v_g, respectively. The relevant edges that contribute to mathrm du_bmathrm dt, mathrm du_rmathrm dt, and mathrm du_gmathrm dt are sigma_br, sigma_rg, and sigma_gb, as annotated above. In particular, sigma_br contributes to both mathrm du_bmathrm dt and mathrm du_rmathrm dt, sigma_rg contributes to both mathrm du_rmathrm dt and mathrm du_gmathrm dt, and sigma_gb contributes to both mathrm du_gmathrm dt and mathrm du_bmathrm dt. ","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Let us focus on u_b and u_r. The contribution from e_br to mathrm du_bmathrm dt and mathrm du_rmathrm dt is given by:","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqtriangleupdate\nbeginaligned\ndvu_bt leftarrow dvu_bt - Q \ndvu_rt  leftarrow dvu_rt + Q \nendaligned\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"where ","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Q = leftvb qleft(vb x_br t alpha x_br + beta y_br + gammaright) vdot vu n_brrightL_br","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"and vb x_br is the midpoint of e_br; vu n_br is the unit normal vector to the edge sigma_br = overrightarrowvb x_brvb x_T, where vb x_T is the centroid of T which should only be computed once for the current T, which should point away from vb x_b but towards vb x_r; L_br = vb x_T - vb x_br, and alphabetagamma are computed from \\eqref{eq:shapecoeffvals} using the vertices of T. Notice that \\eqref{eq:triangleupdate} uses a minus sign for mathrm du_bmathrm dt and a plus sign for mathrm du_rmathrm dt, because we have brought the sum in \\eqref{eq:interiorapproximation} to the right-hand side of the equation. ","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"When we apply the procedure above to each triangle, we will have computed the contribution from each edge to each vertex - almost. The only issue is with boundary triangles, where the edges that lie on the boundary will not be iterated over as they not of the form overrightarrowvb x_brvb x_T (i.e., they are not connected to a centroid). There are two ways to handle this:","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"For each triangle looped over, also check if it is a boundary triangle and then consider its boundary edges.\nAfter looping over all triangles, loop over all boundary edges to pick up the missing contributions.","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"The second approach is preferable, as we don't need to worry about needless checks for boundary triangles, the number of boundary edges it has, etc. ","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"To understand how to pick up contributions from a single edge, consider the figure below which shows some control volumes in the corner of a domain:","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"tri = triangulate_rectangle(0, 1, 0, 1, 10, 10, single_boundary = false)\nadd_ghost_triangles!(tri)\nlinesegs = NTuple{2, Float64}[]\nfig = Figure()\nax = Axis(fig[1, 1], width=400, height=400)\ntriplot!(tri,\n    show_convex_hull=false,\n    show_constrained_edges=false)\nfor i in each_solid_vertex(tri)\n    cv = get_control_volume(tri, i)\n    L = lines!(ax, cv, color=:blue, linewidth=3)\n    translate!(L, 0, 0, 1)\nend\nxlims!(ax, -0.05, 0.2)\nylims!(ax, -0.05, 0.2)\nlin = lines!(ax, [get_point(tri, 1, 2)...], color=:red, linewidth=6)\ntranslate!(lin, 0, 0, 2)\nsc = scatter!(ax, [get_point(tri, 1, 2)...], color=:red, markersize=12)\ntranslate!(sc, 0, 0, 2)\ntext!(ax, (get_point(tri, 1) .- (0, 0.015))..., text = L\"v_i\", fontsize=24)\ntext!(ax, (get_point(tri, 2) .- (0, 0.015))..., text = L\"v_j\", fontsize=24)\nfig\nhidedecorations!(ax)\nresize_to_layout!(fig)","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"fig #hide","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Consider the edge e_ij shown in red. There two control volumes that lie on e_ij, the one for v_i and the other for v_j. We denote the midpoint of e_ij by vb x_ij = (vb x_i + vb x_j)2, so that the two control volume edges are overrightarrowvb x_ivb x_ij and overrightarrowvb x_ijvb x_j for v_i and v_j, respectively. The contributions from the flux over each edge gives","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqbndedgecontrbi\nbeginaligned\ndvu_it leftarrow dvu_it - Q_i 6pt\ndvu_jt leftarrow dvu_jt - Q_j 6pt\nendaligned\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"where ","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqbndedgecontrbiflux\nbeginaligned\nQ_i = leftvb qleft(vb m_i t alpha_ij m_ix + beta_ij m_iy + gamma_ijright) vdot vu n_ijrightL_i \nQ_j = leftvb qleft(vb m_j t alpha_ij m_jx + beta_ij m_jy + gamma_ijright) vdot vu n_ijrightL_j\nendaligned\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"where vb m_i = (vb x_i + vb x_ij)2 = (m_ix m_iy)^mkern-15mumathsfT, vb m_j = (vb x_ij + vb x_j)2 = (m_jx m_jy)^mkern-15mumathsfT, vb n_ij is the outward unit normal vector to e_ij, L_i = vb x_ij - vb x_i, L_j = vb x_j - vb x_ij, and alpha_ij beta_ij gamma_ij are computed from \\eqref{eq:shapecoeffvals} using the vertices of the triangle that contains e_ij. If there is a Neumann boundary condition on e_ij, \\eqref{eq:bndedgecontrbiflux} uses the boundary condition functions for computing the vb q vdot vu n terms.","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Now that we have looped over all triangles and also over all boundary edges, the final values for each mathrm du_imathrm dt is given by ","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"dvu_it leftarrow frac1V_idvu_it + S(vb x_i t u_i)","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Of course, if there is a Dirichlet boundary condition at u_i we set mathrm du_imathrm dt = 0, and if there is a boundary condition on mathrm du_imathrm dt we use that boundary condition instead.","category":"page"},{"location":"math/#Systems-of-Equations","page":"Mathematical and Implementation Details","title":"Systems of Equations","text":"","category":"section"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"We also provide support for systems of PDEs that take the form","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqsystem\nbeginaligned\npdvu_1(vb x t)t + div vb q_1(vb x t u_1 ldots u_n) = S_1(vb x t u_1 ldots u_n) \npdvu_2(vb x t)t + div vb q_2(vb x t u_1 ldots u_n) = S_2(vb x t u_1 ldots u_n) \nvdots \npdvu_n(vb x t)t + div vb q_n(vb x t u_1 ldots u_n) = S_n(vb x t u_1 ldots u_n)\nendaligned\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"where any of the divergences and source terms may also depend on the other variables u_1ldotsu_n. We can write this as,","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqsystemsim\npdvvb u(vb x t)t + div vb Q(vb x t vb u) = vb S(vb x t vb u)\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"where","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqsysdef\nbeginaligned\nvb u(vb x t) = beginbmatrix u_1(vb x t)  u_2(vb x t)  vdots  u_n(vb x t) endbmatrix in mathbb R^n times 1 vb Q(vb x t vb u) = beginbmatrix vb q_1(vb x t vb u)  vb q_2(vb x t vb u)  cdots  vb q_n(vb x t vb u) endbmatrix in mathbb R^2 times n vb S(vb x t vb u) = beginbmatrix S_1(vb x t vb u)  S_2(vb x t vb u)  vdots  S_n(vb x t vb u) endbmatrix in mathbb R^n times 1\nendaligned\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"and the divergence div vb Q is defined as","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqdivdef\ndiv vb Q(vb x t vb u) = beginbmatrix div vb q_1(vb x t vb u)  div vb q_2(vb x t vb u)  vdots  divvb q_n(vb x t vb u) endbmatrix in mathbb R^n times 1\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"The method we use for solving these equations is basically the same as what we do for a single PDE. Letting vb u_i = vb u(vb x_i t) and vb S_i = vb S(vb x_i t), the analogous approximation to \\eqref{eq:interiorapproximation} is","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqsysapproxint\ndvu_it + frac1V_isum_sigmainmathcal E_i leftvb Qleft(vb x_sigma t t boldsymbolalpha_k(sigma)x_sigma + boldsymbolbeta_k(sigma)y_sigma + boldsymbolgamma_kright)^mkern-15mumathsfTvun_sigmarightL_sigma = vb S_i\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"where boldsymbolalpha_k(sigma), boldsymbolbeta_k(sigma), and boldsymbolgamma_k are the vectors of coefficients from \\eqref{eq:shapecoeffvals}, e.g.","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"boldsymbolalpha_k(sigma) = s_k(sigma)11vb u_k1 + s_k(sigma)12vb u_k2 + s_k(sigma)13vb u_k3","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"where vb u_ki = vb u(vb x_ki t) and s_k(sigma)ij are the elements of vb S_k(sigma). The only difference between \\eqref{eq:sysapproxint} and \\eqref{eq:interiorapproximation} is that we now have a vector of PDEs rather than a single PDE. The procedure for computing the contribution from each edge is the same as before, except that we now have to loop over each PDE in the system. In the code, we use a FVMSystem type to represent a system of PDEs, constructed by providing a vector of FVMProblems. The FVMSystem replaces the initial conditions with a matrix initial condition, where the ith column refers to the ith component of the system.","category":"page"},{"location":"math/#Steady-State-Problems","page":"Mathematical and Implementation Details","title":"Steady-State Problems","text":"","category":"section"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"We provide support for steady-state problems, in which case \\eqref{eq:pde} (and similarly for \\eqref{eq:system}) becomes","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequation\ndiv vb q(vb x t u) = S(vb x t vb u)\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"This is solved in exactly the same way, except rootfinding is used and there is no timestepping.","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"EditURL = \"https://github.com/SciML/FiniteVolumeMethod.jl/tree/main/docs/src/literate_tutorials/diffusion_equation_on_an_annulus.jl\"","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"using DisplayAs #hide\ntc = DisplayAs.withcontext(:displaysize => (15, 80), :limit => true); #hide\nnothing #hide","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/#Diffusion-Equation-on-an-Annulus","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"","category":"section"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"In this tutorial, we consider a diffusion equation on an annulus:","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"beginequation\nbeginaligned\npdvu(vb x t)t = grad^2 u(vb x t)  vb x in Omega \ngrad u(vb x t) vdot vu n(vb x) = 0  vb x in mathcal D(0 1) \nu(vb x t) = c(t)  vb x in mathcal D(002) \nu(vb x t) = u_0(vb x)\nendaligned\nendequation","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"demonstrating how we can solve PDEs over multiply-connected domains. Here, mathcal D(0 r) is a circle of radius r centred at the origin, Omega is the annulus between mathcal D(002) and mathcal D(0 1), c(t) = 501-mathrme^-t2, and","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"u_0(x) = 10mathrme^-25leftleft(x+frac12right)^2+left(y+frac12right)^2right - 10mathrme^-45leftleft(x-frac12right)^2+left(y-frac12right)^2right - 5mathrme^-50leftleft(x+frac310right)^2+left(y+frac12right)^2right","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"For the mesh, we use two CircularArcs to define the annulus.","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"using DelaunayTriangulation, FiniteVolumeMethod, CairoMakie\nR₁, R₂ = 0.2, 1.0\ninner = CircularArc((R₁, 0.0), (R₁, 0.0), (0.0, 0.0), positive=false)\nouter = CircularArc((R₂, 0.0), (R₂, 0.0), (0.0, 0.0))\nboundary_nodes = [[[outer]], [[inner]]]\npoints = NTuple{2,Float64}[]\ntri = triangulate(points; boundary_nodes)\nA = get_area(tri)\nrefine!(tri; max_area=1e-4A)\ntriplot(tri)","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"mesh = FVMGeometry(tri)","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"Now let us define the boundary conditions. Remember, the order of the boundary conditions follows the order of the boundaries in the mesh. The outer boundary came first, and then came the inner boundary. We can verify that this is the order of the boundary indices as follows:","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"fig = Figure()\nax = Axis(fig[1, 1])\nouter = [get_point(tri, i) for i in get_neighbours(tri, -1)]\ninner = [get_point(tri, i) for i in get_neighbours(tri, -2)]\ntriplot!(ax, tri)\nscatter!(ax, outer, color=:red)\nscatter!(ax, inner, color=:blue)\nfig","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"So, the boundary conditions are:","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"outer_bc = (x, y, t, u, p) -> zero(u)\ninner_bc = (x, y, t, u, p) -> oftype(u, 50(1 - exp(-t / 2)))\ntypes = (Neumann, Dirichlet)\nBCs = BoundaryConditions(mesh, (outer_bc, inner_bc), types)","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"Finally, let's define the problem and solve it.","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"initial_condition_f = (x, y) -> begin\n    10 * exp(-25 * ((x + 0.5) * (x + 0.5) + (y + 0.5) * (y + 0.5))) - 5 * exp(-50 * ((x + 0.3) * (x + 0.3) + (y + 0.5) * (y + 0.5))) - 10 * exp(-45 * ((x - 0.5) * (x - 0.5) + (y - 0.5) * (y - 0.5)))\nend\ndiffusion_function = (x, y, t, u, p) -> one(u)\ninitial_condition = [initial_condition_f(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)]\nfinal_time = 2.0\nprob = FVMProblem(mesh, BCs;\n    diffusion_function,\n    final_time,\n    initial_condition)","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"using OrdinaryDiffEq, LinearSolve\nsol = solve(prob, TRBDF2(linsolve=KLUFactorization()), saveat=0.2)\nsol |> tc #hide","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"fig = Figure(fontsize=38)\nfor (i, j) in zip(1:3, (1, 6, 11))\n    local ax\n    ax = Axis(fig[1, i], width=600, height=600,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[j])\",\n        titlealign=:left)\n    tricontourf!(ax, tri, sol.u[j], levels=-10:2:40, colormap=:matter)\n    tightlimits!(ax)\nend\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"To finish this example, let us consider how natural neighbour interpolation can be applied here. The application is more complicated for this problem since the mesh has holes. Before we do that, though, let us show how we could use pl_interpolate, which could be useful if we did not need a higher quality interpolant. Let us interpolate the solution at t = 1, which is sol.t[6]. For this, we need to put the ghost triangles back into tri so that we can safely apply jump_and_march. This is done with add_ghost_triangles!.","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"add_ghost_triangles!(tri)","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"(Actually, tri already had these ghost triangles, but we are just showing how you would add them back in if needed.)","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"Now let's interpolate.","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"x = LinRange(-R₂, R₂, 400)\ny = LinRange(-R₂, R₂, 400)\ninterp_vals = zeros(length(x), length(y))\nu = sol.u[6]\nlast_triangle = Ref((1, 1, 1))\nfor (j, _y) in enumerate(y)\n    for (i, _x) in enumerate(x)\n        T = jump_and_march(tri, (_x, _y), try_points=last_triangle[])\n        last_triangle[] = triangle_vertices(T) # used to accelerate jump_and_march, since the points we're looking for are close to each other\n        if DelaunayTriangulation.is_ghost_triangle(T) # don't extrapolate\n            interp_vals[i, j] = NaN\n        else\n            interp_vals[i, j] = pl_interpolate(prob, T, sol.u[6], _x, _y)\n        end\n    end\nend\nfig, ax, sc = contourf(x, y, interp_vals, levels=-10:2:40, colormap=:matter)\nfig","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"Let's now consider applying NaturalNeighbours.jl. We apply it naively first to highlight some complications.","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"using NaturalNeighbours\n_x = vec([x for x in x, y in y]) # NaturalNeighbours.jl needs vector data\n_y = vec([y for x in x, y in y])\nitp = interpolate(tri, u, derivatives=true)\nitp |> tc #hide","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"itp_vals = itp(_x, _y; method=Farin())\nitp_vals |> tc #hide","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"fig, ax, sc = contourf(x, y, reshape(itp_vals, length(x), length(y)), colormap=:matter, levels=-10:2:40)\nfig","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"The issue here is that the interpolant is trying to extrapolate inside the hole and outside of the annulus. To avoid this, you need to pass project=false.","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"itp_vals = itp(_x, _y; method=Farin(), project=false)\nitp_vals |> tc #hide","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"fig, ax, sc = contourf(x, y, reshape(itp_vals, length(x), length(y)), colormap=:matter, levels=-10:2:40)\nfig","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/#Just-the-code","page":"Diffusion Equation on an Annulus","title":"Just the code","text":"","category":"section"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"using DelaunayTriangulation, FiniteVolumeMethod, CairoMakie\nR₁, R₂ = 0.2, 1.0\ninner = CircularArc((R₁, 0.0), (R₁, 0.0), (0.0, 0.0), positive=false)\nouter = CircularArc((R₂, 0.0), (R₂, 0.0), (0.0, 0.0))\nboundary_nodes = [[[outer]], [[inner]]]\npoints = NTuple{2,Float64}[]\ntri = triangulate(points; boundary_nodes)\nA = get_area(tri)\nrefine!(tri; max_area=1e-4A)\ntriplot(tri)\n\nmesh = FVMGeometry(tri)\n\nfig = Figure()\nax = Axis(fig[1, 1])\nouter = [get_point(tri, i) for i in get_neighbours(tri, -1)]\ninner = [get_point(tri, i) for i in get_neighbours(tri, -2)]\ntriplot!(ax, tri)\nscatter!(ax, outer, color=:red)\nscatter!(ax, inner, color=:blue)\nfig\n\nouter_bc = (x, y, t, u, p) -> zero(u)\ninner_bc = (x, y, t, u, p) -> oftype(u, 50(1 - exp(-t / 2)))\ntypes = (Neumann, Dirichlet)\nBCs = BoundaryConditions(mesh, (outer_bc, inner_bc), types)\n\ninitial_condition_f = (x, y) -> begin\n    10 * exp(-25 * ((x + 0.5) * (x + 0.5) + (y + 0.5) * (y + 0.5))) - 5 * exp(-50 * ((x + 0.3) * (x + 0.3) + (y + 0.5) * (y + 0.5))) - 10 * exp(-45 * ((x - 0.5) * (x - 0.5) + (y - 0.5) * (y - 0.5)))\nend\ndiffusion_function = (x, y, t, u, p) -> one(u)\ninitial_condition = [initial_condition_f(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)]\nfinal_time = 2.0\nprob = FVMProblem(mesh, BCs;\n    diffusion_function,\n    final_time,\n    initial_condition)\n\nusing OrdinaryDiffEq, LinearSolve\nsol = solve(prob, TRBDF2(linsolve=KLUFactorization()), saveat=0.2)\n\nfig = Figure(fontsize=38)\nfor (i, j) in zip(1:3, (1, 6, 11))\n    local ax\n    ax = Axis(fig[1, i], width=600, height=600,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[j])\",\n        titlealign=:left)\n    tricontourf!(ax, tri, sol.u[j], levels=-10:2:40, colormap=:matter)\n    tightlimits!(ax)\nend\nresize_to_layout!(fig)\nfig\n\nadd_ghost_triangles!(tri)\n\nx = LinRange(-R₂, R₂, 400)\ny = LinRange(-R₂, R₂, 400)\ninterp_vals = zeros(length(x), length(y))\nu = sol.u[6]\nlast_triangle = Ref((1, 1, 1))\nfor (j, _y) in enumerate(y)\n    for (i, _x) in enumerate(x)\n        T = jump_and_march(tri, (_x, _y), try_points=last_triangle[])\n        last_triangle[] = triangle_vertices(T) # used to accelerate jump_and_march, since the points we're looking for are close to each other\n        if DelaunayTriangulation.is_ghost_triangle(T) # don't extrapolate\n            interp_vals[i, j] = NaN\n        else\n            interp_vals[i, j] = pl_interpolate(prob, T, sol.u[6], _x, _y)\n        end\n    end\nend\nfig, ax, sc = contourf(x, y, interp_vals, levels=-10:2:40, colormap=:matter)\nfig\n\nusing NaturalNeighbours\n_x = vec([x for x in x, y in y]) # NaturalNeighbours.jl needs vector data\n_y = vec([y for x in x, y in y])\nitp = interpolate(tri, u, derivatives=true)\n\nitp_vals = itp(_x, _y; method=Farin())\n\nfig, ax, sc = contourf(x, y, reshape(itp_vals, length(x), length(y)), colormap=:matter, levels=-10:2:40)\nfig\n\nitp_vals = itp(_x, _y; method=Farin(), project=false)\n\nfig, ax, sc = contourf(x, y, reshape(itp_vals, length(x), length(y)), colormap=:matter, levels=-10:2:40)\nfig","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"This page was generated using Literate.jl.","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"EditURL = \"https://github.com/SciML/FiniteVolumeMethod.jl/tree/main/docs/src/literate_wyos/poissons_equation.jl\"","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"using DisplayAs #hide\ntc = DisplayAs.withcontext(:displaysize => (15, 80), :limit => true); #hide\nnothing #hide","category":"page"},{"location":"wyos/poissons_equation/#Poisson's-Equation","page":"Poisson's Equation","title":"Poisson's Equation","text":"","category":"section"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"Pages = [\"poissons_equation.md\"]","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"We now write a solver for Poisson's equation. What we produce in this section can also be accessed in FiniteVolumeMethod.PoissonsEquation.","category":"page"},{"location":"wyos/poissons_equation/#Mathematical-Details","page":"Poisson's Equation","title":"Mathematical Details","text":"","category":"section"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"We start by describing the mathematical details. The problems we will be solving take the form","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"divD(vb x)grad u = f(vb x)","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"Note that this is very similar to a mean exit time problem, except f(vb x) = -1 for mean exit time problems. Note that this is actually a generalised Poisson equation - typically these equations look like grad^2 u = f.[1]","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"[1]: See, for example, this paper.","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"From these similarities, we already know that","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"frac1V_isum_sigmainmathcal E_i D(vb x_sigma)leftleft(s_k 11n_sigma^x+s_k21n_sigma^yright)u_k1 + left(s_k12n_sigma^x+s_k22n_sigma^yright)u_k2+left(s_k13n_sigma^x+s_k23n_sigma^yright)u_k3rightL_sigma = f(vb x_i)","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"and thus we can write this as vb a_i^mkern-15mumathsf Tvb u = b_i as usual, with b_i = f(vb x_i). The boundary conditions are handled in the same way as in mean exit time problems.","category":"page"},{"location":"wyos/poissons_equation/#Implementation","page":"Poisson's Equation","title":"Implementation","text":"","category":"section"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"Let us now implement our problem. For mean exit time problems, we had a function create_met_b that we used for defining vb b. We should generalise that function to now accept a source function:","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"function create_rhs_b(mesh, conditions, source_function, source_parameters)\n    b = zeros(DelaunayTriangulation.num_points(mesh.triangulation))\n    for i in each_solid_vertex(mesh.triangulation)\n        if !FVM.is_dirichlet_node(conditions, i)\n            p = get_point(mesh, i)\n            x, y = getxy(p)\n            b[i] = source_function(x, y, source_parameters)\n        end\n    end\n    return b\nend","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"We also need a function that applies the Dirichlet conditions.","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"function apply_steady_dirichlet_conditions!(A, b, mesh, conditions)\n    for (i, function_index) in FVM.get_dirichlet_nodes(conditions)\n        x, y = get_point(mesh, i)\n        b[i] = FVM.eval_condition_fnc(conditions, function_index, x, y, nothing, nothing)\n        A[i, i] = 1.0\n    end\nend","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"So, our problem can be defined by:","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"using FiniteVolumeMethod, SparseArrays, DelaunayTriangulation, LinearSolve\nconst FVM = FiniteVolumeMethod\nfunction poissons_equation(mesh::FVMGeometry,\n    BCs::BoundaryConditions,\n    ICs::InternalConditions=InternalConditions();\n    diffusion_function=(x,y,p)->1.0,\n    diffusion_parameters=nothing,\n    source_function,\n    source_parameters=nothing)\n    conditions = Conditions(mesh, BCs, ICs)\n    n = DelaunayTriangulation.num_points(mesh.triangulation)\n    A = zeros(n, n)\n    b = create_rhs_b(mesh, conditions, source_function, source_parameters)\n    FVM.triangle_contributions!(A, mesh, conditions, diffusion_function, diffusion_parameters)\n    FVM.boundary_edge_contributions!(A, b, mesh, conditions, diffusion_function, diffusion_parameters)\n    apply_steady_dirichlet_conditions!(A, b, mesh, conditions)\n    FVM.fix_missing_vertices!(A, b, mesh)\n    return LinearProblem(sparse(A), b)\nend","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"Now let's test this problem. We consider","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"beginequation*\nbeginaligned\ngrad^2 u = -sin(pi x)sin(pi y)  vb x in 01^2 \nu = 0  vb x inpartial01^2\nendaligned\nendequation*","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"tri = triangulate_rectangle(0, 1, 0, 1, 100, 100, single_boundary=true)\nmesh = FVMGeometry(tri)\nBCs = BoundaryConditions(mesh, (x, y, t, u, p) -> zero(x), Dirichlet)\nsource_function = (x, y, p) -> -sin(π * x) * sin(π * y)\nprob = poissons_equation(mesh, BCs;  source_function)\nusing DisplayAs #hide\nprob |> tc #hide","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"sol = solve(prob, KLUFactorization())\nsol |> tc #hide","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"using CairoMakie\nfig, ax, sc = tricontourf(tri, sol.u, levels=LinRange(0, 0.05, 10), colormap=:matter, extendhigh=:auto)\ntightlimits!(ax)\nfig","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"If we wanted to turn this into a SteadyFVMProblem, we use a similar call to poissons_equation above except with an initial_condition for the initial guess. Moreover, we need to change the sign of the source function, since above we are solving divD(vb x)grad u = f(vb x), when FVMProblems assume that we are solving 0 = divD(vb x)grad u + f(vb x).","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"initial_condition = zeros(DelaunayTriangulation.num_points(tri))\nfvm_prob = SteadyFVMProblem(FVMProblem(mesh, BCs;\n    diffusion_function= (x, y, t, u, p) -> 1.0,\n    source_function=let S = source_function\n        (x, y, t, u, p) -> -S(x, y, p)\n    end,\n    initial_condition,\n    final_time=Inf))","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"using SteadyStateDiffEq, OrdinaryDiffEq\nfvm_sol = solve(fvm_prob, DynamicSS(TRBDF2(linsolve=KLUFactorization())))\nfvm_sol |> tc #hide","category":"page"},{"location":"wyos/poissons_equation/#Using-the-Provided-Template","page":"Poisson's Equation","title":"Using the Provided Template","text":"","category":"section"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"Let's now use the built-in PoissonsEquation which implements the above template inside FiniteVolumeMethod.jl. The above problem can be constructed as follows:","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"prob = PoissonsEquation(mesh, BCs; source_function=source_function)","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"sol = solve(prob, KLUFactorization())\nsol |> tc #hide","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"Here is a benchmark comparison of the PoissonsEquation approach against the FVMProblem approach.","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"using BenchmarkTools\n@btime solve($prob, $KLUFactorization());","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"  15.442 ms (56 allocations: 15.21 MiB)","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"@btime solve($fvm_prob, $DynamicSS(TRBDF2(linsolve=KLUFactorization())));","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"  189.406 ms (185761 allocations: 93.63 MiB)","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"Let's now also solve a generalised Poisson equation. Based on Section 7 of this paper by Nagel (2012), we consider an equation of the form","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"divleftepsilon(vb x)grad V(vb x)right = -fracrho(vb x)epsilon_0","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"We consider this equation on the domain Omega = 0 10^2. We put two parallel capacitor plates inside the domain, with the first in 2 leq x leq 8 along y = 3, and the other at 2 leq x leq 8 along y=7. We use V = 1 on the top plate, and V = -1 on the bottom plate. For the domain boundaries, partialOmega, we use homogeneous Dirichlet conditions on the top and bottom sides, and homogeneous Neumann conditions on the left and right sides. For the space-varying electric constant epsilon(vb x), we use[2]","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"epsilon(vb x) = 1 + frac12(epsilon_0 - 1)left1 + erfleft(fracrDeltaright)right","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"where r is the distance between vb x and the parallel plates, Delta  = 4. The value of epsilon_0 is approximately epsilon_0 = 88541878128 times 10^-12. For the charge density rho(vb x), we use a Gaussian density,","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"rho(vb x) = fracQ2pimathrme^-r^22","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"where, again, r is the distance between vb x and the parallel plates, and Q = 10^-6.","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"[2]: This form of epsilon(vb x) is based on this paper by Fisicaro et al. (2016).","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"To define this problem, let us first define the mesh. We will need to manually put in the capacitor plates so that we can enforce Dirichlet conditions on them.","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"a, b, c, d = 0.0, 10.0, 0.0, 10.0\ne, f = (2.0, 3.0), (8.0, 3.0)\ng, h = (2.0, 7.0), (8.0, 7.0)\npoints = [(a, c), (b, c), (b, d), (a, d), e, f, g, h]\nboundary_nodes = [[1, 2], [2, 3], [3, 4], [4, 1]]\nsegments = Set(((5, 6), (7, 8)))\ntri = triangulate(points; boundary_nodes, segments, delete_ghosts=false)\nrefine!(tri; max_area=1e-4get_area(tri))\nfig, ax, sc = triplot(tri, show_constrained_edges=true, constrained_edge_linewidth=5)\nfig","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"mesh = FVMGeometry(tri)","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"The boundary conditions are given by:","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"zero_f = (x, y, t, u, p) -> zero(x)\nbc_f = (zero_f, zero_f, zero_f, zero_f)\nbc_types = (Dirichlet, Neumann, Dirichlet, Neumann) # bot, right, top, left\nBCs = BoundaryConditions(mesh, bc_f, bc_types)","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"To define the internal conditions, we need to get the indices for the plates.","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"function find_vertices_on_plates(tri)\n    lower_plate = Int[]\n    upper_plate = Int[]\n    for i in each_solid_vertex(tri)\n        x, y = get_point(tri, i)\n        in_range = 2 ≤ x ≤ 8\n        if in_range\n            y == 3 && push!(lower_plate, i)\n            y == 7 && push!(upper_plate, i)\n        end\n    end\n    return lower_plate, upper_plate\nend\nlower_plate, upper_plate = find_vertices_on_plates(tri)\ndirichlet_nodes = Dict(\n    (lower_plate .=> 1)...,\n    (upper_plate .=> 2)...\n)\ninternal_f = ((x, y, t, u, p) -> -one(x), (x, y, t, u, p) -> one(x))\nICs = InternalConditions(internal_f, dirichlet_nodes=dirichlet_nodes)","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"Next, we define epsilon(vb x) and rho(vb x). We need a function that computes the distance between a point and the plates. For the distance between a point and a line segment, we can use:[3]","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"using LinearAlgebra\nfunction dist_to_line(p, a, b)\n    ℓ² = norm(a .- b)^2\n    t = max(0.0, min(1.0, dot(p .- a, b .- a) / ℓ²))\n    pv = a .+ t .* (b .- a)\n    return norm(p .- pv)\nend","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"[3]: Taken from here.","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"Thus, the distance between a point and the two plates is:","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"function dist_to_plates(x, y)\n    p = (x, y)\n    a1, b1 = (2.0, 3.0), (8.0, 3.0)\n    a2, b2 = (2.0, 7.0), (8.0, 7.0)\n    d1 = dist_to_line(p, a1, b1)\n    d2 = dist_to_line(p, a2, b2)\n    return min(d1, d2)\nend","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"So, our function epsilon(vb x) is defined by:","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"using SpecialFunctions\nfunction dielectric_function(x, y, p)\n    r = dist_to_plates(x, y)\n    return 1 + (p.ϵ₀ - 1) * (1 + erf(r / p.Δ)) / 2\nend","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"The charge density is:","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"function charge_density(x, y, p)\n    r = dist_to_plates(x, y)\n    return p.Q / (2π) * exp(-r^2 / 2)\nend","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"Using this charge density, our source function is defined by:","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"function plate_source_function(x, y, p)\n    ρ = charge_density(x, y, p)\n    return -ρ / p.ϵ₀\nend","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"Now we can define our problem.","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"diffusion_parameters = (ϵ₀=8.8541878128e-12, Δ=4.0)\nsource_parameters = (ϵ₀=8.8541878128e-12, Q=1e-6)\nprob = PoissonsEquation(mesh, BCs, ICs;\n    diffusion_function=dielectric_function,\n    diffusion_parameters=diffusion_parameters,\n    source_function=plate_source_function,\n    source_parameters=source_parameters)","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"sol = solve(prob, KLUFactorization())\nsol |> tc #hide","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"With this solution, we can also define the electric field vb E, using vb E = -grad V. To compute the gradients, we use NaturalNeighbours.jl.","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"using NaturalNeighbours\nitp = interpolate(tri, sol.u; derivatives=true)\nE = map(.-, itp.gradient) # E = -∇V\nE |> tc #hide","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"For plotting the electric field, we will show the electric field intensity vb E, and we can also show the arrows. Rather than showing all arrows, we will show them at a smaller grid of values, which requires differentiating itp so that we can get the gradients at arbitary points.","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"∂ = differentiate(itp, 1)\nx = LinRange(0, 10, 25)\ny = LinRange(0, 10, 25)\nx_vec = [x for x in x, y in y] |> vec\ny_vec = [y for x in x, y in y] |> vec\nE_itp = map(.-, ∂(x_vec, y_vec, interpolant_method=Hiyoshi(2)))\nE_intensity = norm.(E_itp)\nfig = Figure(fontsize=38)\nax = Axis(fig[1, 1], width=600, height=600, titlealign=:left,\n    xlabel=\"x\", ylabel=\"y\", title=\"Voltage\")\ntricontourf!(ax, tri, sol.u, levels=15, colormap=:ocean)\narrow_positions = [Point2f(x, y) for (x, y) in zip(x_vec, y_vec)]\narrow_directions = [Point2f(e...) for e in E_itp]\narrows!(ax, arrow_positions, arrow_directions,\n    lengthscale=0.3, normalize=true, arrowcolor=E_intensity, linecolor=E_intensity)\n    xlims!(ax,0,10)\n    ylims!(ax,0,10)\nax = Axis(fig[1, 2], width=600, height=600, titlealign=:left,\n    xlabel=\"x\", ylabel=\"y\", title=\"Electric Field\")\ntricontourf!(ax, tri, norm.(E), levels=15, colormap=:ocean)\narrows!(ax, arrow_positions, arrow_directions,\n    lengthscale=0.3, normalize=true, arrowcolor=E_intensity, linecolor=E_intensity)\nxlims!(ax,0,10)\nylims!(ax,0,10)\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"To finish, let us benchmark the PoissonsEquation approach against the FVMProblem approach.","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"fvm_prob = SteadyFVMProblem(FVMProblem(mesh, BCs, ICs;\n    diffusion_function=let D = dielectric_function\n        (x, y, t, u, p) -> D(x, y, p)\n    end,\n    source_function=let S = plate_source_function\n        (x, y, t, u, p) -> -S(x, y, p)\n    end,\n    diffusion_parameters=diffusion_parameters,\n    source_parameters=source_parameters,\n    initial_condition=zeros(DelaunayTriangulation.num_points(tri)),\n    final_time=Inf))","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"@btime solve($prob, $KLUFactorization());","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"  9.061 ms (56 allocations: 10.81 MiB)","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"@btime solve($fvm_prob, $DynamicSS(TRBDF2(linsolve=KLUFactorization())));","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"  329.327 ms (201134 allocations: 93.70 MiB)","category":"page"},{"location":"wyos/poissons_equation/#Just-the-code","page":"Poisson's Equation","title":"Just the code","text":"","category":"section"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"function create_rhs_b(mesh, conditions, source_function, source_parameters)\n    b = zeros(DelaunayTriangulation.num_points(mesh.triangulation))\n    for i in each_solid_vertex(mesh.triangulation)\n        if !FVM.is_dirichlet_node(conditions, i)\n            p = get_point(mesh, i)\n            x, y = getxy(p)\n            b[i] = source_function(x, y, source_parameters)\n        end\n    end\n    return b\nend\n\nfunction apply_steady_dirichlet_conditions!(A, b, mesh, conditions)\n    for (i, function_index) in FVM.get_dirichlet_nodes(conditions)\n        x, y = get_point(mesh, i)\n        b[i] = FVM.eval_condition_fnc(conditions, function_index, x, y, nothing, nothing)\n        A[i, i] = 1.0\n    end\nend\n\nusing FiniteVolumeMethod, SparseArrays, DelaunayTriangulation, LinearSolve\nconst FVM = FiniteVolumeMethod\nfunction poissons_equation(mesh::FVMGeometry,\n    BCs::BoundaryConditions,\n    ICs::InternalConditions=InternalConditions();\n    diffusion_function=(x,y,p)->1.0,\n    diffusion_parameters=nothing,\n    source_function,\n    source_parameters=nothing)\n    conditions = Conditions(mesh, BCs, ICs)\n    n = DelaunayTriangulation.num_points(mesh.triangulation)\n    A = zeros(n, n)\n    b = create_rhs_b(mesh, conditions, source_function, source_parameters)\n    FVM.triangle_contributions!(A, mesh, conditions, diffusion_function, diffusion_parameters)\n    FVM.boundary_edge_contributions!(A, b, mesh, conditions, diffusion_function, diffusion_parameters)\n    apply_steady_dirichlet_conditions!(A, b, mesh, conditions)\n    FVM.fix_missing_vertices!(A, b, mesh)\n    return LinearProblem(sparse(A), b)\nend\n\ntri = triangulate_rectangle(0, 1, 0, 1, 100, 100, single_boundary=true)\nmesh = FVMGeometry(tri)\nBCs = BoundaryConditions(mesh, (x, y, t, u, p) -> zero(x), Dirichlet)\nsource_function = (x, y, p) -> -sin(π * x) * sin(π * y)\nprob = poissons_equation(mesh, BCs;  source_function)\n\nsol = solve(prob, KLUFactorization())\n\nusing CairoMakie\nfig, ax, sc = tricontourf(tri, sol.u, levels=LinRange(0, 0.05, 10), colormap=:matter, extendhigh=:auto)\ntightlimits!(ax)\nfig\n\ninitial_condition = zeros(DelaunayTriangulation.num_points(tri))\nfvm_prob = SteadyFVMProblem(FVMProblem(mesh, BCs;\n    diffusion_function= (x, y, t, u, p) -> 1.0,\n    source_function=let S = source_function\n        (x, y, t, u, p) -> -S(x, y, p)\n    end,\n    initial_condition,\n    final_time=Inf))\n\nusing SteadyStateDiffEq, OrdinaryDiffEq\nfvm_sol = solve(fvm_prob, DynamicSS(TRBDF2(linsolve=KLUFactorization())))\n\nprob = PoissonsEquation(mesh, BCs; source_function=source_function)\n\nsol = solve(prob, KLUFactorization())\n\na, b, c, d = 0.0, 10.0, 0.0, 10.0\ne, f = (2.0, 3.0), (8.0, 3.0)\ng, h = (2.0, 7.0), (8.0, 7.0)\npoints = [(a, c), (b, c), (b, d), (a, d), e, f, g, h]\nboundary_nodes = [[1, 2], [2, 3], [3, 4], [4, 1]]\nsegments = Set(((5, 6), (7, 8)))\ntri = triangulate(points; boundary_nodes, segments, delete_ghosts=false)\nrefine!(tri; max_area=1e-4get_area(tri))\nfig, ax, sc = triplot(tri, show_constrained_edges=true, constrained_edge_linewidth=5)\nfig\n\nmesh = FVMGeometry(tri)\n\nzero_f = (x, y, t, u, p) -> zero(x)\nbc_f = (zero_f, zero_f, zero_f, zero_f)\nbc_types = (Dirichlet, Neumann, Dirichlet, Neumann) # bot, right, top, left\nBCs = BoundaryConditions(mesh, bc_f, bc_types)\n\nfunction find_vertices_on_plates(tri)\n    lower_plate = Int[]\n    upper_plate = Int[]\n    for i in each_solid_vertex(tri)\n        x, y = get_point(tri, i)\n        in_range = 2 ≤ x ≤ 8\n        if in_range\n            y == 3 && push!(lower_plate, i)\n            y == 7 && push!(upper_plate, i)\n        end\n    end\n    return lower_plate, upper_plate\nend\nlower_plate, upper_plate = find_vertices_on_plates(tri)\ndirichlet_nodes = Dict(\n    (lower_plate .=> 1)...,\n    (upper_plate .=> 2)...\n)\ninternal_f = ((x, y, t, u, p) -> -one(x), (x, y, t, u, p) -> one(x))\nICs = InternalConditions(internal_f, dirichlet_nodes=dirichlet_nodes)\n\nusing LinearAlgebra\nfunction dist_to_line(p, a, b)\n    ℓ² = norm(a .- b)^2\n    t = max(0.0, min(1.0, dot(p .- a, b .- a) / ℓ²))\n    pv = a .+ t .* (b .- a)\n    return norm(p .- pv)\nend\n\nfunction dist_to_plates(x, y)\n    p = (x, y)\n    a1, b1 = (2.0, 3.0), (8.0, 3.0)\n    a2, b2 = (2.0, 7.0), (8.0, 7.0)\n    d1 = dist_to_line(p, a1, b1)\n    d2 = dist_to_line(p, a2, b2)\n    return min(d1, d2)\nend\n\nusing SpecialFunctions\nfunction dielectric_function(x, y, p)\n    r = dist_to_plates(x, y)\n    return 1 + (p.ϵ₀ - 1) * (1 + erf(r / p.Δ)) / 2\nend\n\nfunction charge_density(x, y, p)\n    r = dist_to_plates(x, y)\n    return p.Q / (2π) * exp(-r^2 / 2)\nend\n\nfunction plate_source_function(x, y, p)\n    ρ = charge_density(x, y, p)\n    return -ρ / p.ϵ₀\nend\n\ndiffusion_parameters = (ϵ₀=8.8541878128e-12, Δ=4.0)\nsource_parameters = (ϵ₀=8.8541878128e-12, Q=1e-6)\nprob = PoissonsEquation(mesh, BCs, ICs;\n    diffusion_function=dielectric_function,\n    diffusion_parameters=diffusion_parameters,\n    source_function=plate_source_function,\n    source_parameters=source_parameters)\n\nsol = solve(prob, KLUFactorization())\n\nusing NaturalNeighbours\nitp = interpolate(tri, sol.u; derivatives=true)\nE = map(.-, itp.gradient) # E = -∇V\n\n∂ = differentiate(itp, 1)\nx = LinRange(0, 10, 25)\ny = LinRange(0, 10, 25)\nx_vec = [x for x in x, y in y] |> vec\ny_vec = [y for x in x, y in y] |> vec\nE_itp = map(.-, ∂(x_vec, y_vec, interpolant_method=Hiyoshi(2)))\nE_intensity = norm.(E_itp)\nfig = Figure(fontsize=38)\nax = Axis(fig[1, 1], width=600, height=600, titlealign=:left,\n    xlabel=\"x\", ylabel=\"y\", title=\"Voltage\")\ntricontourf!(ax, tri, sol.u, levels=15, colormap=:ocean)\narrow_positions = [Point2f(x, y) for (x, y) in zip(x_vec, y_vec)]\narrow_directions = [Point2f(e...) for e in E_itp]\narrows!(ax, arrow_positions, arrow_directions,\n    lengthscale=0.3, normalize=true, arrowcolor=E_intensity, linecolor=E_intensity)\n    xlims!(ax,0,10)\n    ylims!(ax,0,10)\nax = Axis(fig[1, 2], width=600, height=600, titlealign=:left,\n    xlabel=\"x\", ylabel=\"y\", title=\"Electric Field\")\ntricontourf!(ax, tri, norm.(E), levels=15, colormap=:ocean)\narrows!(ax, arrow_positions, arrow_directions,\n    lengthscale=0.3, normalize=true, arrowcolor=E_intensity, linecolor=E_intensity)\nxlims!(ax,0,10)\nylims!(ax,0,10)\nresize_to_layout!(fig)\nfig\n\nfvm_prob = SteadyFVMProblem(FVMProblem(mesh, BCs, ICs;\n    diffusion_function=let D = dielectric_function\n        (x, y, t, u, p) -> D(x, y, p)\n    end,\n    source_function=let S = plate_source_function\n        (x, y, t, u, p) -> -S(x, y, p)\n    end,\n    diffusion_parameters=diffusion_parameters,\n    source_parameters=source_parameters,\n    initial_condition=zeros(DelaunayTriangulation.num_points(tri)),\n    final_time=Inf))","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"","category":"page"},{"location":"wyos/poissons_equation/","page":"Poisson's Equation","title":"Poisson's Equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"EditURL = \"https://github.com/SciML/FiniteVolumeMethod.jl/tree/main/docs/src/literate_tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions.jl\"","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"using DisplayAs #hide\ntc = DisplayAs.withcontext(:displaysize => (15, 80), :limit => true); #hide\nnothing #hide","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/#Helmholtz-Equation-with-Inhomogeneous-Boundary-Conditions","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"","category":"section"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"In this tutorial, we consider the following steady state problem:","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"beginequation\nbeginaligned\ngrad^2 u(vb x) + u(vb x) = 0  vb x in -1 1^2 \npdvuvb n = 1  vb x inpartial-11^2\nendaligned\nendequation","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"We can define this problem in the same way we have defined previous problems, except that the final FVMProblem must be wrapped in a SteadyFVMProblem. Let us start by defining the mesh and the boundary conditions.","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"using DelaunayTriangulation, FiniteVolumeMethod\ntri = triangulate_rectangle(-1, 1, -1, 1, 125, 125, single_boundary=true)\nmesh = FVMGeometry(tri)","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"For the boundary condition,","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"pdvuvb n = 1","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"which is the same as grad u vdot vu n = 1, this needs to be expressed in terms of vb q. Since vb q = -grad u for this problem, the boundary condition is vb q vdot vu n = -1.","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"BCs = BoundaryConditions(mesh, (x, y, t, u, p) -> -one(u), Neumann)","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"To now define the problem, we note that the initial_condition and final_time fields have different interpretations for steady state problems. The initial_condition now serves as an initial estimate for the steady state solution, which is needed for the nonlinear solver, and final_time should now be Inf. For the initial condition, let us simply let the initial estimate be all zeros. For the diffusion and source terms, note that previously we have been considered equations of the form","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"pdvut + divvb q = S quad textnormalor quad pdvut = divDgrad u + S","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"while steady state problems take the form","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"divvb q = S quad textnormalor quad divDgrad u + S = 0","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"So, for this problem, D = 1 and S = u.","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"diffusion_function = (x, y, t, u, p) -> one(u)\nsource_function = (x, y, t, u, p) -> u\ninitial_condition = zeros(DelaunayTriangulation.num_solid_vertices(tri))\nfinal_time = Inf\nprob = FVMProblem(mesh, BCs;\n    diffusion_function,\n    source_function,\n    initial_condition,\n    final_time)","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"steady_prob = SteadyFVMProblem(prob)","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"To now solve this problem, we use a Newton-Raphson solver. Alternative solvers, such as DynamicSS(TRBDF2(linsolve=KLUFactorization()), reltol=1e-4) from SteadyStateDiffEq can also be used. A good method could be to use a simple solver, like NewtonRaphson(), and then use that solution as the initial guess in a finer algorithm like the DynamicSS algorithm above.","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"using NonlinearSolve\nsol = solve(steady_prob, NewtonRaphson())\ncopyto!(prob.initial_condition, sol.u) # this also changes steady_prob's initial condition\nusing SteadyStateDiffEq, LinearSolve, OrdinaryDiffEq\nsol = solve(steady_prob, DynamicSS(TRBDF2(linsolve=KLUFactorization())))\nsol |> tc #hide","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"For this problem, this correction by DynamicSS doesn't seem to actually be needed. Now let's visualise.","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"using CairoMakie\nfig, ax, sc = tricontourf(tri, sol.u, levels=-2.5:0.15:-1.0, colormap=:matter)\nfig","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/#Just-the-code","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Just the code","text":"","category":"section"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"using DelaunayTriangulation, FiniteVolumeMethod\ntri = triangulate_rectangle(-1, 1, -1, 1, 125, 125, single_boundary=true)\nmesh = FVMGeometry(tri)\n\nBCs = BoundaryConditions(mesh, (x, y, t, u, p) -> -one(u), Neumann)\n\ndiffusion_function = (x, y, t, u, p) -> one(u)\nsource_function = (x, y, t, u, p) -> u\ninitial_condition = zeros(DelaunayTriangulation.num_solid_vertices(tri))\nfinal_time = Inf\nprob = FVMProblem(mesh, BCs;\n    diffusion_function,\n    source_function,\n    initial_condition,\n    final_time)\n\nsteady_prob = SteadyFVMProblem(prob)\n\nusing NonlinearSolve\nsol = solve(steady_prob, NewtonRaphson())\ncopyto!(prob.initial_condition, sol.u) # this also changes steady_prob's initial condition\nusing SteadyStateDiffEq, LinearSolve, OrdinaryDiffEq\nsol = solve(steady_prob, DynamicSS(TRBDF2(linsolve=KLUFactorization())))\n\nusing CairoMakie\nfig, ax, sc = tricontourf(tri, sol.u, levels=-2.5:0.15:-1.0, colormap=:matter)\nfig","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"EditURL = \"https://github.com/SciML/FiniteVolumeMethod.jl/tree/main/docs/src/literate_tutorials/solving_mazes_with_laplaces_equation.jl\"","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"using DisplayAs #hide\ntc = DisplayAs.withcontext(:displaysize => (15, 80), :limit => true); #hide\nnothing #hide","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/#Solving-Mazes-with-Laplace's-Equation","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"","category":"section"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"In this tutorial, we consider solving mazes using Laplace's equation, applying the result of Conolly, Burns, and Weis (1990). In particular, given a maze mathcal M, represented as a collection of edges together with some starting point mathcal S_1 and an endpoint mathcal S_2, Laplace's equation can be used to find the solution:","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"beginequation\nbeginaligned\ngrad^2 phi = 0  vb x in mathcal M \nphi = 0  vb x in mathcal S_1 \nphi = 1  vb x in mathcal S_2 \ngradphivdotvu n = 0  vb x in partial M setminus (mathcal S_1 cup mathcal S_2)\nendaligned\nendequation","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"The gradient gradphi will reveal the solution to the maze.  We just look at gradphi for revealing this solution, although other methods could e.g. use gradphi to follow the associated streamlines.","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"Here is what the maze looks like, where the start is in blue and the end is in red.","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"using DelaunayTriangulation, CairoMakie, DelimitedFiles\nA = readdlm(joinpath(@__DIR__, \"../tutorials/maze.txt\"))\nA = unique(A, dims=1)\nx = A[1:10:end, 2] # downsample to make the problem faster\ny = A[1:10:end, 1]\nstart = findall(y .== 648)\nfinish = findall(y .== 5)\nstart_idx_init, start_idx_end = extrema(start)\nfinish_idx_init, finish_idx_end = extrema(finish)\nx_start = x[start]\ny_start = y[start]\nx_start_to_finish = [x[start_idx_end:end]; x[begin:finish_idx_init]]\ny_start_to_finish = [y[start_idx_end:end]; y[begin:finish_idx_init]]\nx_finish = x[finish]\ny_finish = y[finish]\nx_finish_to_start = x[finish_idx_end:start_idx_init]\ny_finish_to_start = y[finish_idx_end:start_idx_init]\nx_bnd = [x_start, x_start_to_finish, x_finish, x_finish_to_start]\ny_bnd = [y_start, y_start_to_finish, y_finish, y_finish_to_start]\nboundary_nodes, points = convert_boundary_points_to_indices(x_bnd, y_bnd)\ntri = triangulate(points; boundary_nodes) # takes a while because maze.txt contains so many points\nrefine!(tri)\n\nfig, ax, sc, = triplot(tri,\n    show_convex_hull=false,\n    show_constrained_edges=false)\nlines!(ax, [get_point(tri, get_boundary_nodes(tri, 1)...)...], color=:blue, linewidth=6)\nlines!(ax, [get_point(tri, get_boundary_nodes(tri, 3)...)...], color=:red, linewidth=6)\nfig","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"Now we can solve the problem.","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"using FiniteVolumeMethod, StableRNGs\nmesh = FVMGeometry(tri)\nstart_bc = (x, y, t, u, p) -> zero(u)\nstart_to_finish_bc = (x, y, t, u, p) -> zero(u)\nfinish_bc = (x, y, t, u, p) -> one(u)\nfinish_to_start_bc = (x, y, t, u, p) -> zero(u)\nfncs = (start_bc, start_to_finish_bc, finish_bc, finish_to_start_bc)\ntypes = (Dirichlet, Neumann, Dirichlet, Neumann)\nBCs = BoundaryConditions(mesh, fncs, types)\ndiffusion_function = (x, y, t, u, p) -> one(u)\ninitial_condition = 0.05randn(StableRNG(123), DelaunayTriangulation.num_points(tri)) # random initial condition - this is the initial guess for the solution\nfinal_time = Inf\nprob = FVMProblem(mesh, BCs;\n    diffusion_function=diffusion_function,\n    initial_condition=initial_condition,\n    final_time=final_time)\nsteady_prob = SteadyFVMProblem(prob)","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"using SteadyStateDiffEq, LinearSolve, OrdinaryDiffEq\nsol = solve(steady_prob, DynamicSS(TRBDF2(linsolve=KLUFactorization(), autodiff=false)))\nsol |> tc #hide","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"We now have our solution.","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"tricontourf(tri, sol.u, colormap=:matter)","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"This is not what we use to compute the solution to the maze, instead we need gradphi. We compute the gradient at each point using NaturalNeighbours.jl.","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"using NaturalNeighbours, LinearAlgebra\nitp = interpolate(tri, sol.u; derivatives=true)\n∇ = NaturalNeighbours.get_gradient(itp)\n∇norms = norm.(∇)\ntricontourf(tri, ∇norms, colormap=:matter)","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"The solution to the maze is now extremely clear from this plot!","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"An alternative way to look at this solution is to consider the transient problem, where we do not solve the steady state problem and instead view the solution over time.","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"using Accessors\nprob = @set prob.final_time = 1e8\nLogRange(a, b, n) = exp10.(LinRange(log10(a), log10(b), n))\nsol = solve(prob, TRBDF2(linsolve=KLUFactorization()), saveat=LogRange(1e2, prob.final_time, 24 * 10))\nall_∇norms = map(sol.u) do u\n    itp = interpolate(tri, u; derivatives=true)\n    ∇ = NaturalNeighbours.get_gradient(itp)\n    norm.(∇)\nend\ni = Observable(1)\n∇norms = map(i -> all_∇norms[i], i)\nfig, ax, sc = tricontourf(tri, ∇norms, colormap=:matter, levels=LinRange(0, 0.0035, 25), extendlow=:auto, extendhigh=:auto)\nhidedecorations!(ax)\ntightlimits!(ax)\nrecord(fig, joinpath(@__DIR__, \"../figures\", \"maze_solution_1.mp4\"), eachindex(sol);\n    framerate=24) do _i\n    i[] = _i\nend;\nnothing #hide","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"(Image: Animation of the solution of the maze)","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/#Just-the-code","page":"Solving Mazes with Laplace's Equation","title":"Just the code","text":"","category":"section"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"using DelaunayTriangulation, CairoMakie, DelimitedFiles\nA = readdlm(joinpath(@__DIR__, \"../tutorials/maze.txt\"))\nA = unique(A, dims=1)\nx = A[1:10:end, 2] # downsample to make the problem faster\ny = A[1:10:end, 1]\nstart = findall(y .== 648)\nfinish = findall(y .== 5)\nstart_idx_init, start_idx_end = extrema(start)\nfinish_idx_init, finish_idx_end = extrema(finish)\nx_start = x[start]\ny_start = y[start]\nx_start_to_finish = [x[start_idx_end:end]; x[begin:finish_idx_init]]\ny_start_to_finish = [y[start_idx_end:end]; y[begin:finish_idx_init]]\nx_finish = x[finish]\ny_finish = y[finish]\nx_finish_to_start = x[finish_idx_end:start_idx_init]\ny_finish_to_start = y[finish_idx_end:start_idx_init]\nx_bnd = [x_start, x_start_to_finish, x_finish, x_finish_to_start]\ny_bnd = [y_start, y_start_to_finish, y_finish, y_finish_to_start]\nboundary_nodes, points = convert_boundary_points_to_indices(x_bnd, y_bnd)\ntri = triangulate(points; boundary_nodes) # takes a while because maze.txt contains so many points\nrefine!(tri)\n\nfig, ax, sc, = triplot(tri,\n    show_convex_hull=false,\n    show_constrained_edges=false)\nlines!(ax, [get_point(tri, get_boundary_nodes(tri, 1)...)...], color=:blue, linewidth=6)\nlines!(ax, [get_point(tri, get_boundary_nodes(tri, 3)...)...], color=:red, linewidth=6)\nfig\n\nusing FiniteVolumeMethod, StableRNGs\nmesh = FVMGeometry(tri)\nstart_bc = (x, y, t, u, p) -> zero(u)\nstart_to_finish_bc = (x, y, t, u, p) -> zero(u)\nfinish_bc = (x, y, t, u, p) -> one(u)\nfinish_to_start_bc = (x, y, t, u, p) -> zero(u)\nfncs = (start_bc, start_to_finish_bc, finish_bc, finish_to_start_bc)\ntypes = (Dirichlet, Neumann, Dirichlet, Neumann)\nBCs = BoundaryConditions(mesh, fncs, types)\ndiffusion_function = (x, y, t, u, p) -> one(u)\ninitial_condition = 0.05randn(StableRNG(123), DelaunayTriangulation.num_points(tri)) # random initial condition - this is the initial guess for the solution\nfinal_time = Inf\nprob = FVMProblem(mesh, BCs;\n    diffusion_function=diffusion_function,\n    initial_condition=initial_condition,\n    final_time=final_time)\nsteady_prob = SteadyFVMProblem(prob)\n\nusing SteadyStateDiffEq, LinearSolve, OrdinaryDiffEq\nsol = solve(steady_prob, DynamicSS(TRBDF2(linsolve=KLUFactorization(), autodiff=false)))\n\ntricontourf(tri, sol.u, colormap=:matter)\n\nusing NaturalNeighbours, LinearAlgebra\nitp = interpolate(tri, sol.u; derivatives=true)\n∇ = NaturalNeighbours.get_gradient(itp)\n∇norms = norm.(∇)\ntricontourf(tri, ∇norms, colormap=:matter)\n\nusing Accessors\nprob = @set prob.final_time = 1e8\nLogRange(a, b, n) = exp10.(LinRange(log10(a), log10(b), n))\nsol = solve(prob, TRBDF2(linsolve=KLUFactorization()), saveat=LogRange(1e2, prob.final_time, 24 * 10))\nall_∇norms = map(sol.u) do u\n    itp = interpolate(tri, u; derivatives=true)\n    ∇ = NaturalNeighbours.get_gradient(itp)\n    norm.(∇)\nend\ni = Observable(1)\n∇norms = map(i -> all_∇norms[i], i)\nfig, ax, sc = tricontourf(tri, ∇norms, colormap=:matter, levels=LinRange(0, 0.0035, 25), extendlow=:auto, extendhigh=:auto)\nhidedecorations!(ax)\ntightlimits!(ax)\nrecord(fig, joinpath(@__DIR__, \"../figures\", \"maze_solution_1.mp4\"), eachindex(sol);\n    framerate=24) do _i\n    i[] = _i\nend;","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"EditURL = \"https://github.com/SciML/FiniteVolumeMethod.jl/tree/main/docs/src/literate_tutorials/reaction_diffusion_brusselator_system_of_pdes.jl\"","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"using DisplayAs #hide\ntc = DisplayAs.withcontext(:displaysize => (15, 80), :limit => true); #hide\nnothing #hide","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/#A-Reaction-Diffusion-Brusselator-System-of-PDEs","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"","category":"section"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"In this tutorial, we show how we can solve systems of PDEs. We consider the reaction-diffusion Brusselator system:","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"beginequationlabeleqbrusleeq\nbeginaligned\npdvPhit = frac14grad^2 Phi + Phi^2Psi - 2Phi  vb x in 0 1^2 \npdvPsit = frac14grad^2 Psi - Phi^2Psi + Phi  vb x in 0 1^2\nendaligned\nendequation","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"Since this is a somewhat contrived example, we will be using the exact solution to define sensible initial and boundary conditions:[1]","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"beginequationlabeleqbrusleexct\nbeginaligned\nPhi(x y t) =exp(-x-y-t2) \nPsi(x y t) = exp(x+y+t2)\nendaligned\nendequation","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"[1]: See Islam, Ali, and Haq (2010).","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"We can use these exact solutions \\eqref{eq:brusleexct} to also show how we can mix boundary conditions. We use:","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"beginequation*\nbeginaligned\nPhi(x y 0) = exp(-x-y) \nPsi(x y 0) = exp(x + y) \npdvPhiy = -exp(-x-t2)  y = 0 6pt\nPsi = exp(x + t2)  y = 0 \npdvPhix = -exp(-1-y-t2)  x=1 6pt\npdvPsix = exp(1 + y+ t2)  x=1 6pt\nPhi = exp(-1-x-t2)  y=1 \npdvPsiy = exp(1 + x + t2)  y=1 6pt\npdvPhix = -exp(-y-t2)  x=0 6pt\nPsi = exp(y + t2)  x=0\nendaligned\nendequation*","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"For implementing these equations, we need to write the Neumann boundary conditions in the forms vb q_1 vdot vu n = f(vb x t) and vb q_2 vdot vu n = f(vb x t), where vb q_1 and vb q_2 are the fluxes for Phi and Psi, respectively. So, we need to rewrite \\eqref{eq:brusleeq} in the conservation form; previously, we've also allowed for reaction-diffusion formulations, but unfortunately we do not allow this specification for systems due to some technical limitations. We can write \\eqref{eq:brusleeq} in the conservation form as follows:","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"beginequation\nbeginaligned\npdvPhit + divvb q_1 = S_1 \npdvPsit + divvb q_2 = S_2\nendaligned\nendequation","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"where vb q_1 = -gradPhi4, S_1 = Phi^2Psi - 2Phi, vb q_2 = -gradPsi4, and S_2 = -Phi^2Psi + Phi. Now that we have these flux functions, let us rewrite our boundary conditions. Remember that vu n is the outward unit normal, so for example on the bottom boundary we have","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"vb q_1 vdot vu n = -frac14gradPhi vdot -vu j = frac14pdvPhiy","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"The normal vectors are -vu j, vu i, vu j, and -vu i for the bottom, right, top, and left sides of the square, respectively. So, our boundary become:","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"beginequation*\nbeginaligned\nPhi(x y 0) = exp(-x-y) \nPsi(x y 0) = exp(x + y) \nvb q_1 vdot vu n = -frac14exp(-x-t2)  y = 0 6pt\nPsi = exp(x + t2)  y = 0 \nvb q_1 vdot vu n = frac14exp(-1-y-t2)   x=1 6pt\nvb q_2 vdot vu n = -frac14exp(1 + y+ t2)  x=1 6pt\nPhi = exp(-1-x-t2)  y=1 \nvb q_2 vdot vu n = -frac14exp(1 + x + t2)  y=1 6pt\nvb q_1 vdot vu n = -frac14exp(-y-t2)  x=0 6pt\nPsi = exp(y + t2)  x=0\nendaligned\nendequation*","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"using FiniteVolumeMethod, DelaunayTriangulation\ntri = triangulate_rectangle(0, 1, 0, 1, 100, 100, single_boundary=false)\nmesh = FVMGeometry(tri)","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"Now we define the boundary conditions. When considering a system of PDEs, you need to define the boundary conditions for each variable separately. The signatures are the same, namely (x, y, t, u, p) -> Number, except now u is a vector (or Tuple) of the solution values for each variable instead of just a scalar. This last point is not relevant here, but you do need to know about it for other problems more generally. So, let us now define the boundary conditions. First, for Phi:","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"Φ_bot = (x, y, t, u, p) -> -1 / 4 * exp(-x - t / 2)\nΦ_right = (x, y, t, u, p) -> 1 / 4 * exp(-1 - y - t / 2)\nΦ_top = (x, y, t, u, p) -> exp(-1 - x - t / 2)\nΦ_left = (x, y, t, u, p) -> -1 / 4 * exp(-y - t / 2)\nΦ_bc_fncs = (Φ_bot, Φ_right, Φ_top, Φ_left)\nΦ_bc_types = (Neumann, Neumann, Dirichlet, Neumann)\nΦ_BCs = BoundaryConditions(mesh, Φ_bc_fncs, Φ_bc_types)","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"Now, for Psi:","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"Ψ_bot = (x, y, t, u, p) -> exp(x + t / 2)\nΨ_right = (x, y, t, u, p) -> -1 / 4 * exp(1 + y + t / 2)\nΨ_top = (x, y, t, u, p) -> -1 / 4 * exp(1 + x + t / 2)\nΨ_left = (x, y, t, u, p) -> exp(y + t / 2)\nΨ_bc_fncs = (Ψ_bot, Ψ_right, Ψ_top, Ψ_left)\nΨ_bc_types = (Dirichlet, Neumann, Neumann, Dirichlet)\nΨ_BCs = BoundaryConditions(mesh, Ψ_bc_fncs, Ψ_bc_types)","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"Now we need to define the actual problems. Let us first define the flux and source functions, remembering that the variables get replaced with linear approximants. The flux functions also now take Tuples for alpha, beta, and gamma, where the ith element of the Tuple refers to the ith variable. Similarly, the source function takes a Tuple of the variables in the u argument.","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"Φ_q = (x, y, t, α, β, γ, p) -> (-α[1] / 4, -β[1] / 4)\nΨ_q = (x, y, t, α, β, γ, p) -> (-α[2] / 4, -β[2] / 4)\nΦ_S = (x, y, t, (Φ, Ψ), p) -> Φ^2 * Ψ - 2Φ\nΨ_S = (x, y, t, (Φ, Ψ), p) -> -Φ^2 * Ψ + Φ","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"Now we define the initial conditions.","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"Φ_exact = (x, y, t) -> exp(-x - y - t / 2)\nΨ_exact = (x, y, t) -> exp(x + y + t / 2)\nΦ₀ = [Φ_exact(x, y, 0) for (x, y) in DelaunayTriangulation.each_point(tri)]\nΨ₀ = [Ψ_exact(x, y, 0) for (x, y) in DelaunayTriangulation.each_point(tri)];\nnothing #hide","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"Next, we can define the FVMProblems for each variable.","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"Φ_prob = FVMProblem(mesh, Φ_BCs; flux_function=Φ_q, source_function=Φ_S,\n    initial_condition=Φ₀, final_time=5.0)","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"Ψ_prob = FVMProblem(mesh, Ψ_BCs; flux_function=Ψ_q, source_function=Ψ_S,\n    initial_condition=Ψ₀, final_time=5.0)","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"Finally, the FVMSystem is constructed by these two problems:","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"system = FVMSystem(Φ_prob, Ψ_prob)","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"We can now solve the problem just as we've done previously.","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"using OrdinaryDiffEq, LinearSolve\nsol = solve(system, TRBDF2(linsolve=KLUFactorization()), saveat=1.0)\nsol |> tc #hide","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"For this solution, note that the u values are matrices. For example:","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"sol.u[3]\nsol.u[3] |> tc #hide","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"The ith row is the ith variable, so","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"sol.u[3][1, :]\nsol.u[3][1, :] |> tc #hide","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"are the value of Phi at the third time, and similarly sol.u[3][2, :] are the values of Psi at the third time. We can visualise the solutions as follows:","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"using CairoMakie\nfig = Figure(fontsize=38)\nfor i in eachindex(sol)\n    ax1 = Axis(fig[1, i], xlabel=L\"x\", ylabel=L\"y\",\n        width=400, height=400,\n        title=L\"\\Phi: t = %$(sol.t[i])\", titlealign=:left)\n    ax2 = Axis(fig[2, i], xlabel=L\"x\", ylabel=L\"y\",\n        width=400, height=400,\n        title=L\"\\Psi: t = %$(sol.t[i])\", titlealign=:left)\n    tricontourf!(ax1, tri, sol[i][1, :], levels=0:0.1:1, colormap=:matter)\n    tricontourf!(ax2, tri, sol[i][2, :], levels=1:10:100, colormap=:matter)\nend\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/#Just-the-code","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"Just the code","text":"","category":"section"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"using FiniteVolumeMethod, DelaunayTriangulation\ntri = triangulate_rectangle(0, 1, 0, 1, 100, 100, single_boundary=false)\nmesh = FVMGeometry(tri)\n\nΦ_bot = (x, y, t, u, p) -> -1 / 4 * exp(-x - t / 2)\nΦ_right = (x, y, t, u, p) -> 1 / 4 * exp(-1 - y - t / 2)\nΦ_top = (x, y, t, u, p) -> exp(-1 - x - t / 2)\nΦ_left = (x, y, t, u, p) -> -1 / 4 * exp(-y - t / 2)\nΦ_bc_fncs = (Φ_bot, Φ_right, Φ_top, Φ_left)\nΦ_bc_types = (Neumann, Neumann, Dirichlet, Neumann)\nΦ_BCs = BoundaryConditions(mesh, Φ_bc_fncs, Φ_bc_types)\n\nΨ_bot = (x, y, t, u, p) -> exp(x + t / 2)\nΨ_right = (x, y, t, u, p) -> -1 / 4 * exp(1 + y + t / 2)\nΨ_top = (x, y, t, u, p) -> -1 / 4 * exp(1 + x + t / 2)\nΨ_left = (x, y, t, u, p) -> exp(y + t / 2)\nΨ_bc_fncs = (Ψ_bot, Ψ_right, Ψ_top, Ψ_left)\nΨ_bc_types = (Dirichlet, Neumann, Neumann, Dirichlet)\nΨ_BCs = BoundaryConditions(mesh, Ψ_bc_fncs, Ψ_bc_types)\n\nΦ_q = (x, y, t, α, β, γ, p) -> (-α[1] / 4, -β[1] / 4)\nΨ_q = (x, y, t, α, β, γ, p) -> (-α[2] / 4, -β[2] / 4)\nΦ_S = (x, y, t, (Φ, Ψ), p) -> Φ^2 * Ψ - 2Φ\nΨ_S = (x, y, t, (Φ, Ψ), p) -> -Φ^2 * Ψ + Φ\n\nΦ_exact = (x, y, t) -> exp(-x - y - t / 2)\nΨ_exact = (x, y, t) -> exp(x + y + t / 2)\nΦ₀ = [Φ_exact(x, y, 0) for (x, y) in DelaunayTriangulation.each_point(tri)]\nΨ₀ = [Ψ_exact(x, y, 0) for (x, y) in DelaunayTriangulation.each_point(tri)];\n\nΦ_prob = FVMProblem(mesh, Φ_BCs; flux_function=Φ_q, source_function=Φ_S,\n    initial_condition=Φ₀, final_time=5.0)\n\nΨ_prob = FVMProblem(mesh, Ψ_BCs; flux_function=Ψ_q, source_function=Ψ_S,\n    initial_condition=Ψ₀, final_time=5.0)\n\nsystem = FVMSystem(Φ_prob, Ψ_prob)\n\nusing OrdinaryDiffEq, LinearSolve\nsol = solve(system, TRBDF2(linsolve=KLUFactorization()), saveat=1.0)\n\nsol.u[3]\n\nsol.u[3][1, :]\n\nusing CairoMakie\nfig = Figure(fontsize=38)\nfor i in eachindex(sol)\n    ax1 = Axis(fig[1, i], xlabel=L\"x\", ylabel=L\"y\",\n        width=400, height=400,\n        title=L\"\\Phi: t = %$(sol.t[i])\", titlealign=:left)\n    ax2 = Axis(fig[2, i], xlabel=L\"x\", ylabel=L\"y\",\n        width=400, height=400,\n        title=L\"\\Psi: t = %$(sol.t[i])\", titlealign=:left)\n    tricontourf!(ax1, tri, sol[i][1, :], levels=0:0.1:1, colormap=:matter)\n    tricontourf!(ax2, tri, sol[i][2, :], levels=1:10:100, colormap=:matter)\nend\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"CurrentModule = FiniteVolumeMethod","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This is the documentation for FiniteVolumeMethod.jl. Click here to go back to the GitHub repository.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This is a Julia package for solving partial differential equations (PDEs) of the form","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pdvu(vb x t)t + div vb q(vb x t u) = S(vb x t u) quad (x y)^mkern-15mumathsfT in Omega subset mathbb R^2t0","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using the finite volume method, with additional support for steady-state problems and for systems of PDEs of the above form. We support Neumann, Dirichlet, and boundary conditions on mathrm dumathrm dt, as well as internal conditions and custom constraints. We also provide an interface for solving special cases of the above PDE, namely reaction-diffusion equations","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pdvu(vb x t)t = divleftD(vb x t u)grad u(vb x t)right + S(vb x t u)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The tutorials in the sidebar demonstrate the many possibilities of this package. In addition to these two generic forms, we also provide support for specific problems that can be solved in a more efficient manner, namely:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"DiffusionEquations: partial_tu = divD(vb x)grad u.\nMeanExitTimeProblems: divD(vb x)grad T(vb x) = -1.\nLinearReactionDiffusionEquations: partial_tu = divD(vb x)grad u + f(vb x)u.\nPoissonsEquation: divD(vb x)grad u  = f(vb x).\nLaplacesEquation: divD(vb x)grad u = 0.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"See the Solvers for Specific Problems, and Writing Your Own section for more information on these templates.","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"EditURL = \"https://github.com/SciML/FiniteVolumeMethod.jl/tree/main/docs/src/literate_tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions.jl\"","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"using DisplayAs #hide\ntc = DisplayAs.withcontext(:displaysize => (15, 80), :limit => true); #hide\nnothing #hide","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/#Diffusion-Equation-in-a-Wedge-with-Mixed-Boundary-Conditions","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"","category":"section"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"In this example, we consider a diffusion equation on a wedge with angle alpha and mixed boundary conditions:","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"beginequation*\nbeginaligned\npdvu(r theta t)t = grad^2u(rthetat)  0r10thetaalphat06pt\npdvu(r 0 t)theta  = 0  0r1t06pt\nu(1 theta t) = 0  0thetaalphat06pt\npdvu(ralphat)theta  = 0  0thetaalphat06pt\nu(r theta 0) = f(rtheta)  0r10thetaalpha\nendaligned\nendequation*","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"where we take f(rtheta) = 1-r and alpha=pi4.","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"Note that the PDE is provided in polar form, but Cartesian coordinates are assumed for the operators in our code. The conversion is easy, noting that the two Neumann conditions are just equations of the form grad u vdot vu n = 0. Moreover, although the right-hand side of the PDE is given as a Laplacian, recall that grad^2 = divgrad, so we can write the PDE as partial upartial t + div vb q = 0, where vb q = -grad u.","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"Let us now setup the problem. To define the geometry, we need to be careful that the Triangulation recognises that we need to split the boundary into three parts, one part for each boundary condition. This is accomplished by providing a single vector for each part of the boundary as follows (and as described in DelaunayTriangulation.jl's documentation), where we also refine! the mesh to get a better mesh. For the arc, we use the CircularArc so that the mesh knows that it is triangulating a certain arc in that area.","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"using DelaunayTriangulation, FiniteVolumeMethod, ElasticArrays\n\nα = π / 4\npoints = [(0.0, 0.0), (1.0, 0.0), (cos(α), sin(α))]\nbottom_edge = [1, 2]\narc = CircularArc((1.0, 0.0), (cos(α), sin(α)), (0.0, 0.0))\nupper_edge = [3, 1]\nboundary_nodes = [bottom_edge, [arc], upper_edge]\ntri = triangulate(points; boundary_nodes)\nA = get_area(tri)\nrefine!(tri; max_area=1e-4A)\nmesh = FVMGeometry(tri)","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"This is the mesh we've constructed.","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"using CairoMakie\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"To confirm that the boundary is now in three parts, see:","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"get_boundary_nodes(tri)","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"We now need to define the boundary conditions. For this, we need to provide Tuples, where the ith element of the Tuples refers to the ith part of the boundary. The boundary conditions are thus:","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"lower_bc = arc_bc = upper_bc = (x, y, t, u, p) -> zero(u)\ntypes = (Neumann, Dirichlet, Neumann)\nBCs = BoundaryConditions(mesh, (lower_bc, arc_bc, upper_bc), types)","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"Now we can define the PDE. We use the reaction-diffusion formulation, specifying the diffusion function as a constant.","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"f = (x, y) -> 1 - sqrt(x^2 + y^2)\nD = (x, y, t, u, p) -> one(u)\ninitial_condition = [f(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)]\nfinal_time = 0.1\nprob = FVMProblem(mesh, BCs; diffusion_function=D, initial_condition, final_time)","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"If you did want to use the flux formulation, you would need to provide","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"flux = (x, y, t, α, β, γ, p) -> (-α, -β)","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"which replaces u with αx + βy + γ so that we approximate grad u by (alphabeta)^mkern-15mumathsfT, and the negative is needed since vb q = -grad u.","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"We now solve the problem. We provide the solver for this problem. In my experience, I've found that TRBDF2(linsolve=KLUFactorization()) typically has the best performance for these problems.","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"using OrdinaryDiffEq, LinearSolve\nsol = solve(prob, TRBDF2(linsolve=KLUFactorization()), saveat=0.01, parallel=Val(false))\nind = findall(DelaunayTriangulation.each_point_index(tri)) do i #hide\n    !DelaunayTriangulation.has_vertex(tri, i) #hide\nend #hide\nusing Test #hide\n@test sol[ind, :] ≈ reshape(repeat(initial_condition, length(sol)), :, length(sol))[ind, :] # make sure that missing vertices don't change #hide\nsol |> tc #hide","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"using CairoMakie\nfig = Figure(fontsize=38)\nfor (i, j) in zip(1:3, (1, 6, 11))\n    local ax\n    ax = Axis(fig[1, i], width=600, height=600,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[j])\",\n        titlealign=:left)\n    tricontourf!(ax, tri, sol.u[j], levels=0:0.01:1, colormap=:matter)\n    tightlimits!(ax)\nend\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/#Just-the-code","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Just the code","text":"","category":"section"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"using DelaunayTriangulation, FiniteVolumeMethod, ElasticArrays\n\nα = π / 4\npoints = [(0.0, 0.0), (1.0, 0.0), (cos(α), sin(α))]\nbottom_edge = [1, 2]\narc = CircularArc((1.0, 0.0), (cos(α), sin(α)), (0.0, 0.0))\nupper_edge = [3, 1]\nboundary_nodes = [bottom_edge, [arc], upper_edge]\ntri = triangulate(points; boundary_nodes)\nA = get_area(tri)\nrefine!(tri; max_area=1e-4A)\nmesh = FVMGeometry(tri)\n\nusing CairoMakie\nfig, ax, sc = triplot(tri)\nfig\n\nget_boundary_nodes(tri)\n\nlower_bc = arc_bc = upper_bc = (x, y, t, u, p) -> zero(u)\ntypes = (Neumann, Dirichlet, Neumann)\nBCs = BoundaryConditions(mesh, (lower_bc, arc_bc, upper_bc), types)\n\nf = (x, y) -> 1 - sqrt(x^2 + y^2)\nD = (x, y, t, u, p) -> one(u)\ninitial_condition = [f(x, y) for (x, y) in DelaunayTriangulation.each_point(tri)]\nfinal_time = 0.1\nprob = FVMProblem(mesh, BCs; diffusion_function=D, initial_condition, final_time)\n\nflux = (x, y, t, α, β, γ, p) -> (-α, -β)\n\nusing OrdinaryDiffEq, LinearSolve\nsol = solve(prob, TRBDF2(linsolve=KLUFactorization()), saveat=0.01, parallel=Val(false))\n\nusing CairoMakie\nfig = Figure(fontsize=38)\nfor (i, j) in zip(1:3, (1, 6, 11))\n    local ax\n    ax = Axis(fig[1, i], width=600, height=600,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[j])\",\n        titlealign=:left)\n    tricontourf!(ax, tri, sol.u[j], levels=0:0.01:1, colormap=:matter)\n    tightlimits!(ax)\nend\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/keller_segel_chemotaxis/#Keller-Segel-Model-of-Chemotaxis","page":"Keller-Segel Model of Chemotaxis","title":"Keller-Segel Model of Chemotaxis","text":"","category":"section"},{"location":"tutorials/keller_segel_chemotaxis/","page":"Keller-Segel Model of Chemotaxis","title":"Keller-Segel Model of Chemotaxis","text":"In this tutorial, we consider the following Keller-Segel model of chemotaxis:","category":"page"},{"location":"tutorials/keller_segel_chemotaxis/","page":"Keller-Segel Model of Chemotaxis","title":"Keller-Segel Model of Chemotaxis","text":"beginequation*\nbeginaligned\npdvut = grad^2u - div left(fraccu1+u^2grad vright) + u(1-u) \npdvvt = Dgrad^2 v + u - av\nendaligned\nendequation*","category":"page"},{"location":"tutorials/keller_segel_chemotaxis/","page":"Keller-Segel Model of Chemotaxis","title":"Keller-Segel Model of Chemotaxis","text":"inside the square 0 100^2 with homogeneous Neumann boundary conditions. We  start by defining the problem, remembering that we need one problem for each variable u and v.","category":"page"},{"location":"tutorials/keller_segel_chemotaxis/","page":"Keller-Segel Model of Chemotaxis","title":"Keller-Segel Model of Chemotaxis","text":"using FiniteVolumeMethod, DelaunayTriangulation\ntri = triangulate_rectangle(0, 100, 0, 100, 250, 250, single_boundary=true)\nmesh = FVMGeometry(tri)\nbc_u = (x, y, t, (u, v), p) -> zero(u)\nbc_v = (x, y, t, (u, v), p) -> zero(v)\nBCs_u = BoundaryConditions(mesh, bc_u, Neumann)\nBCs_v = BoundaryConditions(mesh, bc_v, Neumann)\nq_u = (x, y, t, (αu, αv), (βu, βv), (γu, γv), p) -> begin\n    u = αu * x + βu * y + γu\n    ∇u = (αu, βu)\n    ∇v = (αv, βv)\n    χu = p.c * u / (1 + u^2)\n    _q = χu .* ∇v .- ∇u\n    return _q\nend\nq_v = (x, y, t, (αu, αv), (βu, βv), (γu, γv), p) -> begin\n    ∇v = (αv, βv)\n    _q = -p.D .* ∇v\n    return _q\nend\nS_u = (x, y, t, (u, v), p) -> begin\n    return u * (1 - u)\nend\nS_v = (x, y, t, (u, v), p) -> begin\n    return u - p.a * v\nend\nq_u_parameters = (c=4.0,)\nq_v_parameters = (D=1.0,)\nS_v_parameters = (a=0.1,)\nu_initial_condition = 0.01rand(DelaunayTriangulation.num_points(tri))\nv_initial_condition = zeros(DelaunayTriangulation.num_points(tri))\nfinal_time = 1000.0\nu_prob = FVMProblem(mesh, BCs_u;\n    flux_function=q_u, flux_parameters=q_u_parameters,\n    source_function=S_u,\n    initial_condition=u_initial_condition, final_time=final_time)\nv_prob = FVMProblem(mesh, BCs_v;\n    flux_function=q_v, flux_parameters=q_v_parameters,\n    source_function=S_v, source_parameters=S_v_parameters,\n    initial_condition=v_initial_condition, final_time=final_time)\nprob = FVMSystem(u_prob, v_prob)","category":"page"},{"location":"tutorials/keller_segel_chemotaxis/#Now-let's-solve-and-animate-the-problem.","page":"Keller-Segel Model of Chemotaxis","title":"Now let's solve and animate the problem.","text":"","category":"section"},{"location":"tutorials/keller_segel_chemotaxis/","page":"Keller-Segel Model of Chemotaxis","title":"Keller-Segel Model of Chemotaxis","text":"using OrdinaryDiffEq, Sundials, CairoMakie\nsol = solve(prob, CVODE_BDF(linear_solver=:GMRES), saveat=1.0, parallel=Val(false)) \nfig = Figure(fontsize=44)\nx = LinRange(0, 100, 250)\ny = LinRange(0, 100, 250)\ni = Observable(1)\naxu = Axis(fig[1, 1], width=600, height=600,\n    title=map(i -> L\"u(x,~ y,~ %$(sol.t[i]))\", i), xlabel=L\"x\", ylabel=L\"y\")\naxv = Axis(fig[1, 2], width=600, height=600,\n    title=map(i -> L\"v(x,~ y,~ %$(sol.t[i]))\", i), xlabel=L\"x\", ylabel=L\"y\")\nu = map(i -> reshape(sol.u[i][1, :], 250, 250), i)\nv = map(i -> reshape(sol.u[i][2, :], 250, 250), i)\nheatmap!(axu, x, y, u, colorrange=(0.0, 2.5), colormap=:turbo)\nheatmap!(axv, x, y, v, colorrange=(0.0, 10.0), colormap=:turbo)\nresize_to_layout!(fig)\nrecord(fig, joinpath(@__DIR__, \"../figures\", \"keller_segel_chemotaxis.mp4\"), eachindex(sol);\n    framerate=60) do _i\n    i[] = _i\nend;","category":"page"},{"location":"tutorials/keller_segel_chemotaxis/","page":"Keller-Segel Model of Chemotaxis","title":"Keller-Segel Model of Chemotaxis","text":"(Image: Animation of Keller-Segel chemotaxis)","category":"page"},{"location":"tutorials/keller_segel_chemotaxis/","page":"Keller-Segel Model of Chemotaxis","title":"Keller-Segel Model of Chemotaxis","text":"Some pretty amazing patterns!","category":"page"},{"location":"tutorials/keller_segel_chemotaxis/#Just-the-code","page":"Keller-Segel Model of Chemotaxis","title":"Just the code","text":"","category":"section"},{"location":"tutorials/keller_segel_chemotaxis/","page":"Keller-Segel Model of Chemotaxis","title":"Keller-Segel Model of Chemotaxis","text":"An uncommented version of this example is given below.","category":"page"},{"location":"tutorials/keller_segel_chemotaxis/","page":"Keller-Segel Model of Chemotaxis","title":"Keller-Segel Model of Chemotaxis","text":"using FiniteVolumeMethod, DelaunayTriangulation\ntri = triangulate_rectangle(0, 100, 0, 100, 250, 250, single_boundary=true)\nmesh = FVMGeometry(tri)\nbc_u = (x, y, t, (u, v), p) -> zero(u)\nbc_v = (x, y, t, (u, v), p) -> zero(v)\nBCs_u = BoundaryConditions(mesh, bc_u, Neumann)\nBCs_v = BoundaryConditions(mesh, bc_v, Neumann)\nq_u = (x, y, t, (αu, αv), (βu, βv), (γu, γv), p) -> begin\n    u = αu * x + βu * y + γu\n    ∇u = (αu, βu)\n    ∇v = (αv, βv)\n    χu = p.c * u / (1 + u^2)\n    _q = χu .* ∇v .- ∇u\n    return _q\nend\nq_v = (x, y, t, (αu, αv), (βu, βv), (γu, γv), p) -> begin\n    ∇v = (αv, βv)\n    _q = -p.D .* ∇v\n    return _q\nend\nS_u = (x, y, t, (u, v), p) -> begin\n    return u * (1 - u)\nend\nS_v = (x, y, t, (u, v), p) -> begin\n    return u - p.a * v\nend\nq_u_parameters = (c=4.0,)\nq_v_parameters = (D=1.0,)\nS_v_parameters = (a=0.1,)\nu_initial_condition = 0.01rand(DelaunayTriangulation.num_points(tri))\nv_initial_condition = zeros(DelaunayTriangulation.num_points(tri))\nfinal_time = 1000.0\nu_prob = FVMProblem(mesh, BCs_u;\n    flux_function=q_u, flux_parameters=q_u_parameters,\n    source_function=S_u,\n    initial_condition=u_initial_condition, final_time=final_time)\nv_prob = FVMProblem(mesh, BCs_v;\n    flux_function=q_v, flux_parameters=q_v_parameters,\n    source_function=S_v, source_parameters=S_v_parameters,\n    initial_condition=v_initial_condition, final_time=final_time)\nprob = FVMSystem(u_prob, v_prob);\n\nusing OrdinaryDiffEq, Sundials, CairoMakie\nsol = solve(prob, CVODE_BDF(linear_solver=:GMRES), saveat=1.0, parallel=Val(false)) \nfig = Figure(fontsize=44)\nx = LinRange(0, 100, 250)\ny = LinRange(0, 100, 250)\ni = Observable(1)\naxu = Axis(fig[1, 1], width=600, height=600,\n    title=map(i -> L\"u(x,~ y,~ %$(sol.t[i]))\", i), xlabel=L\"x\", ylabel=L\"y\")\naxv = Axis(fig[1, 2], width=600, height=600,\n    title=map(i -> L\"v(x,~ y,~ %$(sol.t[i]))\", i), xlabel=L\"x\", ylabel=L\"y\")\nu = map(i -> reshape(sol.u[i][1, :], 250, 250), i)\nv = map(i -> reshape(sol.u[i][2, :], 250, 250), i)\nheatmap!(axu, x, y, u, colorrange=(0.0, 2.5), colormap=:turbo)\nheatmap!(axv, x, y, v, colorrange=(0.0, 10.0), colormap=:turbo)\nresize_to_layout!(fig)\nrecord(fig, joinpath(@__DIR__, \"../figures\", \"keller_segel_chemotaxis.mp4\"), eachindex(sol);\n    framerate=60) do _i\n    i[] = _i\nend;","category":"page"},{"location":"tutorials/keller_segel_chemotaxis/","page":"Keller-Segel Model of Chemotaxis","title":"Keller-Segel Model of Chemotaxis","text":"","category":"page"},{"location":"tutorials/keller_segel_chemotaxis/","page":"Keller-Segel Model of Chemotaxis","title":"Keller-Segel Model of Chemotaxis","text":"This page was generated using Literate.jl.","category":"page"}]
}
