var documenterSearchIndex = {"docs":
[{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"EditURL = \"https://github.com/DanielVandH/FiniteVolumeMethod.jl/tree/main/docs/src/literate_tutorials/mean_exit_time.jl\"","category":"page"},{"location":"tutorials/mean_exit_time/#Mean-Exit-Time","page":"Mean Exit Time","title":"Mean Exit Time","text":"","category":"section"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"Pages = [\"mean_exit_time.md\"]","category":"page"},{"location":"tutorials/mean_exit_time/#Definition-of-the-problem","page":"Mean Exit Time","title":"Definition of the problem","text":"","category":"section"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"In this tutorial, we consider the problem of mean exit time, based on some of my previous work.[1] Typically, mean exit time problems with linear diffusion take the form","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"beginequationlabeleqmet\nbeginaligned\nDgrad^2T(vb x) = -1  vb x in Omega \nT(vb x) = 0  vb x in partial Omega\nendaligned\nendequation","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"for some diffusivity D. T(vb x) is the mean exit time at vb x, meaning the average time it would take a particle starting at vb x to exit the domain through partialOmega. For this interpretation of T, we are letting D = mathcal Pdelta^2(4tau), where delta  0 is the step length of the particle, tau0 is the duration between steps, and mathcal P in 0 1 is the probability that the particle actually moves at a given time step.","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"[1]: See Simpson et al. (2021) and Carr et al. (2022).","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"In this previous work, we also use the finite volume method, but the problems are instead formulated  as linear problems, which makes the solution significantly simpler to implement. The approach we give here  is more generally applicable for other nonlinear problems, though.","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"A more complicated extension of \\eqref{eq:met} is to allow the particle to be moving through a heterogenous media, so that the diffusivity depends on vb x. In particular, let us consider a compound disk Omega = 0  r  R_1 cup R_1  r  R_2, and let mathcal P (the probability of movement) be piecewise constant across Omega (and thus also D):","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"P = begincases P_1  0rR_1P_2R_1rR_2endcasesquad D=begincasesD_10rR_1D_2R_1rR_2endcases","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"where D_1 = P_1delta^2(4tau) and D_2=P_2delta^2(4tau). The inner region, where 0  r  R_1, and the outer region, where R_1rR_2, are separated by an interface at r=R_1 and we apply an absorbing boundary condition at r=R_2, meaning particles that reach r=R_2 exit the domain. For this problem, \\eqref{eq:met} is instead given by","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"beginequationlabeleqmet2\nbeginaligned\nfracD_1rdvrleft(rdvT^(1)rright) = -1  0 rR_1 6pt\nfracD_2rdvrleft(rdvT^(2)rright) = -1  R_1rR_26pt\nT^(1)(R_1) = T^(2)(R_1) \nD_1dvT^(1)r(R_1) = D_2dvT^(2)r(R_1) 6pt\ndvT^(1)r(0) = 0 6pt\nT^(2)(R_2) = 0\nendaligned\nendequation","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"which we describe using polar coordinates, and we let T^(1)(r) be the mean exit time for 0  r  R_1, and T^(2)(r) be the mean exit time for R_1  r  R_2. The boundary conditions at the interface are to enforce continuity of T and continuity of the flux of T across the interface, and the condition mathrm dT^(1)mathrm dr = 0 at r=0 is to ensure that T^(1) is finite at r=0. This problem actually has an exact solution,","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"beginequationlabeleqmet2exact\nbeginaligned\nT^(1)(r) = fracR_1^2-r^24D_1+fracR_2^2-R_1^24D_2 \nT^(2)(r) = fracR_2^2-r^24D_2\nendaligned\nendequation","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"which will be useful later.","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"One other extension we can make is to allow the interface to be more complicated than just a circle. We take a perturbed interface, mathcal R_1(theta), so that the inner region is now 0  r  mathcal R_1(theta) and the outer region is mathcal R_1(theta)  r  R_2. The function mathcal R_1(theta) is written in the form mathcal R_1(theta) = R_1(1+varepsilon g(theta)), where varepsilon ll 1 is a perturbation parameter, R_1 is the radius of the unperturbed interface, and g(theta) is a smooth mathcal O(1) periodic function with period 2pi; we let g(theta) = sin(3theta) + cos(5theta) and varepsilon=005 for this tutorial. With this setup, \\eqref{eq:met2} now becomes","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"beginequationlabeleqmet3\nbeginaligned\nD_1grad^2 T^(1)(vb x) = -1  0  r  mathcal R_1(theta) \nD_2grad^2 T^(2)(vb x) = -1  mathcal R_1(theta)  r  R_2 \nT^(1)(mathcal R_1(theta)theta) = T^(2)(mathcal R_1(theta)theta) \nD_1grad T^(1)(mathcal R_1(theta) theta) vdot vu n(theta) = D_2grad T^(2)(mathcal R_1(theta) theta) vdot vu n(theta) \nT^(2)(R_2 theta) = 0 \nendaligned\nendequation","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"This problem has no exact solution (it has a perturbation solution, though, derived in Carr et al. (2022)).","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"At the end of this tutorial, we also consider modifying \\eqref{eq:met3} even further so that there are holes in the domain, and an internal Dirichlet condition at the origin.","category":"page"},{"location":"tutorials/mean_exit_time/#Unperturbed-interface","page":"Mean Exit Time","title":"Unperturbed interface","text":"","category":"section"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"Let us start by solving the problem on an unperturbed interface. We note that, while \\eqref{eq:met2} is defined so that there are two variables T^(1) and T^(2), which therefore requires continuity equations across the interface, numerically we can solve this in terms of a single variable T with a space-varying diffusivity. Moreover, the finiteness condition at the origin is not needed. Thus, we can solve","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"beginequation\nbeginaligned\nD(vb x)grad^2 T(vb x) = -1  vb x in mathcal D(0 R_2) \nT(vb x) = 0  vb x in partial mathcal D(0 R_2)\nendaligned\nendequation","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"Here, mathcal D(0R_2) is the circle of radius R_2 centred at the origin, and","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"D(vb x) = begincases D_1  vb x  R_1  D_2  R_1 leq vb x leq R_2 endcases","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"The mesh is defined as follows. To help the accuracy of the solution, we add more triangles around the boundary by putting some constrained edges there.","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"using DelaunayTriangulation, FiniteVolumeMethod, CairoMakie\nθ = LinRange(0, 2π, 250)\nR₁, R₂ = 2.0, 3.0\nx = @. R₂ * cos(θ)\ny = @. R₂ * sin(θ)\nx[end] = x[begin]\ny[end] = y[begin]\nboundary_nodes, points = convert_boundary_points_to_indices(x, y)\ntri = triangulate(points; boundary_nodes, delete_ghosts=false)\nxin = @views @. R₁ * cos(θ)[begin:end-1]\nyin = @views @. R₁ * sin(θ)[begin:end-1]\nadd_point!(tri, xin[1], yin[1])\nfor i in 2:length(xin)\n    add_point!(tri, xin[i], yin[i])\n    n = num_points(tri)\n    add_edge!(tri, n - 1, n)\nend\nn = num_points(tri)\nadd_edge!(tri, n - 1, n)\nrefine!(tri; max_area=1e-3get_total_area(tri))\ntriplot(tri)","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"mesh = FVMGeometry(tri)","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"The boundary conditions are simple absorbing conditions.","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"BCs = BoundaryConditions(mesh, ((x, y, t, u, p) -> zero(u),), (Dirichlet,))","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"For the problem, let us first define the diffusivity.","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"D₁, D₂ = 6.25e-4, 6.25e-5\ndiffusion_function = (x, y, t, u, p) -> let r = sqrt(x^2 + y^2)\n    return ifelse(r < p.R₁, p.D₁, p.D₂)\nend\ndiffusion_parameters = (R₁=R₁, D₁=D₁, D₂=D₂)","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"For the initial condition, which recall is the initial guess for the steady problem, let us use the exact solution for the mean exit time problem on a disk with a uniform diffusivity, which is given by (R_2^2 - r^2)(4D_2).","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"f = (x, y) -> let r = sqrt(x^2 + y^2)\n    return (R₂^2 - r^2) / (4D₂)\nend\ninitial_condition = [f(x, y) for (x, y) in each_point(tri)]","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"We now define the problem.","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"source_function = (x, y, t, u, p) -> one(u)\nprob = FVMProblem(mesh, BCs;\n    diffusion_function, diffusion_parameters,\n    source_function, initial_condition,\n    final_time=Inf)","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"steady_prob = SteadyFVMProblem(prob)","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"We now solve this problem as we've done for any previous problem.","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"using SteadyStateDiffEq, LinearSolve, OrdinaryDiffEq\nsol = solve(steady_prob, DynamicSS(Rosenbrock23()))","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"fig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=\"x\", ylabel=\"y\")\ntricontourf!(ax, tri, sol.u, levels=0:500:20000, extendhigh=:auto)\nfig","category":"page"},{"location":"tutorials/mean_exit_time/#Perturbed-interface","page":"Mean Exit Time","title":"Perturbed interface","text":"","category":"section"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"Let us now solve the problem with a perturbed interface. The mesh is defined as follows.","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"g = θ -> sin(3θ) + cos(5θ)\nε = 0.05\nR1_f = θ -> R₁ * (1 + ε * g(θ))\nx = @. R₂ * cos(θ)\ny = @. R₂ * sin(θ)\nx[end] = x[begin]\ny[end] = y[begin]\nboundary_nodes, points = convert_boundary_points_to_indices(x, y)\ntri = triangulate(points; boundary_nodes, delete_ghosts=false)\nxin = @views (@. R1_f(θ) * cos(θ))[begin:end-1]\nyin = @views (@. R1_f(θ) * sin(θ))[begin:end-1]\nadd_point!(tri, xin[1], yin[1])\nfor i in 2:length(xin)\n    add_point!(tri, xin[i], yin[i])\n    n = num_points(tri)\n    add_edge!(tri, n - 1, n)\nend\nn = num_points(tri)\nadd_edge!(tri, n - 1, n)\nrefine!(tri; max_area=1e-3get_total_area(tri))\ntriplot(tri)","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"mesh = FVMGeometry(tri)","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"The boundary conditions are simple absorbing conditions.","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"BCs = BoundaryConditions(mesh, (x, y, t, u, p) -> zero(u), Dirichlet)","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"Now we define the problem. For the initial condition that we use, we will use the exact solution for the problem with an unperturbed interface.","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"function T_exact(x, y)\n    r = sqrt(x^2 + y^2)\n    if r < R₁\n        return (R₁^2 - r^2) / (4D₁) + (R₂^2 - R₁^2) / (4D₂)\n    else\n        return (R₂^2 - r^2) / (4D₂)\n    end\nend\ndiffusion_function = (x, y, t, u, p) -> let r = sqrt(x^2 + y^2), θ = atan(y, x)\n    interface_val = p.R1_f(θ)\n    return ifelse(r < interface_val, p.D₁, p.D₂)\nend\ndiffusion_parameters = (D₁=D₁, D₂=D₂, R1_f=R1_f)\ninitial_condition = [T_exact(x, y) for (x, y) in each_point(tri)]\nsource_function = (x, y, t, u, p) -> one(u)\nprob = FVMProblem(mesh, BCs;\n    diffusion_function, diffusion_parameters,\n    source_function, initial_condition,\n    final_time=Inf)\nsteady_prob = SteadyFVMProblem(prob)","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"sol = solve(steady_prob, DynamicSS(Rosenbrock23()))","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"fig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=\"x\", ylabel=\"y\")\ntricontourf!(ax, tri, sol.u, levels=0:500:20000, extendhigh=:auto)\nlines!(ax, [xin; xin[1]], [yin; yin[1]], color=:magenta, linewidth=5)\nfig","category":"page"},{"location":"tutorials/mean_exit_time/#Adding-obstacles","page":"Mean Exit Time","title":"Adding obstacles","text":"","category":"section"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"Let us now add some obstacles into the problem. We add in components one at a time, exploring the impact of each component individually. When we update the triangulation, we do need to update the mesh since it is constructed from the initial tri.","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"The first obstacle we consider adding is a single hole at the origin, which we accomplish by adding a point at the origin and then using InternalConditions. This point will be used to absorb any nearby particles, i.e. T(00)=0.","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"add_point!(tri, 0.0, 0.0)\nmesh = FVMGeometry(tri)\nICs = InternalConditions((x, y, t, u, p) -> zero(u), dirichlet_nodes=Dict(num_points(tri) => 1))\nBCs = BoundaryConditions(mesh, (x, y, t, u, p) -> zero(u), Dirichlet)\ninitial_condition = [T_exact(x, y) for (x, y) in each_point(tri)]\nprob = FVMProblem(mesh, BCs, ICs;\n    diffusion_function, diffusion_parameters,\n    source_function, initial_condition,\n    final_time=Inf)\nsteady_prob = SteadyFVMProblem(prob)\nsol = solve(steady_prob, DynamicSS(Rosenbrock23()))\nfig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=\"x\", ylabel=\"y\")\ntricontourf!(ax, tri, sol.u, levels=0:500:10000, extendhigh=:auto)\nlines!(ax, [xin; xin[1]], [yin; yin[1]], color=:magenta, linewidth=5)\nfig","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"We see that the hole has changed the interior significantly. For the next constraint, let us change the boundary so that we only allow particles to exit through a small part of the boundary, reflecting off all other parts. For the reflecting boundary condition, this is enforced by using Neumann boundary conditions.","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"εr = 0.25\nθref = LinRange(εr, 2π - εr, 200)\nθabs = LinRange(2π - εr, 2π + εr, 200)\nxref = @. R₂ * cos(θref)\nyref = @. R₂ * sin(θref)\nxabs = @. R₂ * cos(θabs)\nyabs = @. R₂ * sin(θabs)\nxref[end] = xabs[begin]\nyref[end] = yabs[begin]\nx = [xref, xabs]\ny = [yref, yabs]\nboundary_nodes, points = convert_boundary_points_to_indices(x, y)\ntri = triangulate(points; boundary_nodes, delete_ghosts=false)\nxin = @views (@. R1_f(θ) * cos(θ))[begin:end-1]\nyin = @views (@. R1_f(θ) * sin(θ))[begin:end-1]\nadd_point!(tri, xin[1], yin[1])\nfor i in 2:length(xin)\n    add_point!(tri, xin[i], yin[i])\n    n = num_points(tri)\n    add_edge!(tri, n - 1, n)\nend\nn = num_points(tri)\nadd_edge!(tri, n - 1, n)\nadd_point!(tri, 0.0, 0.0)\norigin_idx = num_points(tri)\nrefine!(tri; max_area=1e-3get_total_area(tri))\ntriplot(tri)","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"mesh = FVMGeometry(tri)\nICs = InternalConditions((x, y, t, u, p) -> zero(u), dirichlet_nodes=Dict(origin_idx => 1))\nzero_f = (x, y, t, u, p) -> zero(u)\nBCs = BoundaryConditions(mesh, (zero_f, zero_f), (Neumann, Dirichlet))\nICs = InternalConditions((x, y, t, u, p) -> zero(u), dirichlet_nodes=Dict(origin_idx => 1))\ninitial_condition = [T_exact(x, y) for (x, y) in each_point(tri)]\nprob = FVMProblem(mesh, BCs, ICs;\n    diffusion_function, diffusion_parameters,\n    source_function, initial_condition,\n    final_time=Inf)\nsteady_prob = SteadyFVMProblem(prob)\nsol = solve(steady_prob, DynamicSS(Rosenbrock23()))\nfig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=\"x\", ylabel=\"y\")\ntricontourf!(ax, tri, sol.u, levels=0:2500:35000, extendhigh=:auto)\nlines!(ax, [xin; xin[1]], [yin; yin[1]], color=:magenta, linewidth=5)\nfig","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"Now, as a last constraint, let's add a hole. We'll put hole at the origin,  and we'll move the point hole to (-2 0) rather than at the origin, and we'll also put a hole at (0 295).","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"xhole = @. cos(θ)\nyhole = @. sin(θ)\nreverse!(xhole) # clockwise\nreverse!(yhole)\nxhole[begin] = xhole[end]\nyhole[begin] = yhole[end]\nx = [[xref, xabs], [xhole]]\ny = [[yref, yabs], [yhole]]\nboundary_nodes, points = convert_boundary_points_to_indices(x, y)\ntri = triangulate(points; boundary_nodes, delete_ghosts=false)\nxin = @views (@. R1_f(θ) * cos(θ))[begin:end-1]\nyin = @views (@. R1_f(θ) * sin(θ))[begin:end-1]\nadd_point!(tri, xin[1], yin[1])\nfor i in 2:length(xin)\n    add_point!(tri, xin[i], yin[i])\n    n = num_points(tri)\n    add_edge!(tri, n - 1, n)\nend\nn = num_points(tri)\nadd_edge!(tri, n - 1, n)\nadd_point!(tri, -2.0, 0.0)\nadd_point!(tri, 0.0, 2.95)\npointhole_idxs = [num_points(tri), num_points(tri)-1]\nrefine!(tri; max_area=1e-3get_total_area(tri))\ntriplot(tri)","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"The boundary condition we'll use at the new interior hole will be an absorbing boundary condition.","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"mesh = FVMGeometry(tri)\nICs = InternalConditions((x, y, t, u, p) -> zero(u), dirichlet_nodes=Dict(origin_idx => 1))\nzero_f = (x, y, t, u, p) -> zero(u)\nBCs = BoundaryConditions(mesh, (zero_f, zero_f, zero_f), (Neumann, Dirichlet, Dirichlet))\nICs = InternalConditions((x, y, t, u, p) -> zero(u), dirichlet_nodes=Dict(pointhole_idxs .=> 1))\ninitial_condition = [T_exact(x, y) for (x, y) in each_point(tri)]\nprob = FVMProblem(mesh, BCs, ICs;\n    diffusion_function, diffusion_parameters,\n    source_function, initial_condition,\n    final_time=Inf)\nsteady_prob = SteadyFVMProblem(prob)\nsol = solve(steady_prob, DynamicSS(Rosenbrock23()))\nfig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=\"x\", ylabel=\"y\")\ntricontourf!(ax, tri, sol.u, levels=0:1000:15000, extendhigh=:auto)\nlines!(ax, [xin; xin[1]], [yin; yin[1]], color=:magenta, linewidth=5)\nfig","category":"page"},{"location":"tutorials/mean_exit_time/#Just-the-code","page":"Mean Exit Time","title":"Just the code","text":"","category":"section"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"using DelaunayTriangulation, FiniteVolumeMethod, CairoMakie\nθ = LinRange(0, 2π, 250)\nR₁, R₂ = 2.0, 3.0\nx = @. R₂ * cos(θ)\ny = @. R₂ * sin(θ)\nx[end] = x[begin]\ny[end] = y[begin]\nboundary_nodes, points = convert_boundary_points_to_indices(x, y)\ntri = triangulate(points; boundary_nodes, delete_ghosts=false)\nxin = @views @. R₁ * cos(θ)[begin:end-1]\nyin = @views @. R₁ * sin(θ)[begin:end-1]\nadd_point!(tri, xin[1], yin[1])\nfor i in 2:length(xin)\n    add_point!(tri, xin[i], yin[i])\n    n = num_points(tri)\n    add_edge!(tri, n - 1, n)\nend\nn = num_points(tri)\nadd_edge!(tri, n - 1, n)\nrefine!(tri; max_area=1e-3get_total_area(tri))\ntriplot(tri)\n\nmesh = FVMGeometry(tri)\n\nBCs = BoundaryConditions(mesh, ((x, y, t, u, p) -> zero(u),), (Dirichlet,))\n\nD₁, D₂ = 6.25e-4, 6.25e-5\ndiffusion_function = (x, y, t, u, p) -> let r = sqrt(x^2 + y^2)\n    return ifelse(r < p.R₁, p.D₁, p.D₂)\nend\ndiffusion_parameters = (R₁=R₁, D₁=D₁, D₂=D₂)\n\nf = (x, y) -> let r = sqrt(x^2 + y^2)\n    return (R₂^2 - r^2) / (4D₂)\nend\ninitial_condition = [f(x, y) for (x, y) in each_point(tri)]\n\nsource_function = (x, y, t, u, p) -> one(u)\nprob = FVMProblem(mesh, BCs;\n    diffusion_function, diffusion_parameters,\n    source_function, initial_condition,\n    final_time=Inf)\n\nsteady_prob = SteadyFVMProblem(prob)\n\nusing SteadyStateDiffEq, LinearSolve, OrdinaryDiffEq\nsol = solve(steady_prob, DynamicSS(Rosenbrock23()))\n\nfig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=\"x\", ylabel=\"y\")\ntricontourf!(ax, tri, sol.u, levels=0:500:20000, extendhigh=:auto)\nfig\n\ng = θ -> sin(3θ) + cos(5θ)\nε = 0.05\nR1_f = θ -> R₁ * (1 + ε * g(θ))\nx = @. R₂ * cos(θ)\ny = @. R₂ * sin(θ)\nx[end] = x[begin]\ny[end] = y[begin]\nboundary_nodes, points = convert_boundary_points_to_indices(x, y)\ntri = triangulate(points; boundary_nodes, delete_ghosts=false)\nxin = @views (@. R1_f(θ) * cos(θ))[begin:end-1]\nyin = @views (@. R1_f(θ) * sin(θ))[begin:end-1]\nadd_point!(tri, xin[1], yin[1])\nfor i in 2:length(xin)\n    add_point!(tri, xin[i], yin[i])\n    n = num_points(tri)\n    add_edge!(tri, n - 1, n)\nend\nn = num_points(tri)\nadd_edge!(tri, n - 1, n)\nrefine!(tri; max_area=1e-3get_total_area(tri))\ntriplot(tri)\n\nmesh = FVMGeometry(tri)\n\nBCs = BoundaryConditions(mesh, (x, y, t, u, p) -> zero(u), Dirichlet)\n\nfunction T_exact(x, y)\n    r = sqrt(x^2 + y^2)\n    if r < R₁\n        return (R₁^2 - r^2) / (4D₁) + (R₂^2 - R₁^2) / (4D₂)\n    else\n        return (R₂^2 - r^2) / (4D₂)\n    end\nend\ndiffusion_function = (x, y, t, u, p) -> let r = sqrt(x^2 + y^2), θ = atan(y, x)\n    interface_val = p.R1_f(θ)\n    return ifelse(r < interface_val, p.D₁, p.D₂)\nend\ndiffusion_parameters = (D₁=D₁, D₂=D₂, R1_f=R1_f)\ninitial_condition = [T_exact(x, y) for (x, y) in each_point(tri)]\nsource_function = (x, y, t, u, p) -> one(u)\nprob = FVMProblem(mesh, BCs;\n    diffusion_function, diffusion_parameters,\n    source_function, initial_condition,\n    final_time=Inf)\nsteady_prob = SteadyFVMProblem(prob)\n\nsol = solve(steady_prob, DynamicSS(Rosenbrock23()))\n\nfig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=\"x\", ylabel=\"y\")\ntricontourf!(ax, tri, sol.u, levels=0:500:20000, extendhigh=:auto)\nlines!(ax, [xin; xin[1]], [yin; yin[1]], color=:magenta, linewidth=5)\nfig\n\nadd_point!(tri, 0.0, 0.0)\nmesh = FVMGeometry(tri)\nICs = InternalConditions((x, y, t, u, p) -> zero(u), dirichlet_nodes=Dict(num_points(tri) => 1))\nBCs = BoundaryConditions(mesh, (x, y, t, u, p) -> zero(u), Dirichlet)\ninitial_condition = [T_exact(x, y) for (x, y) in each_point(tri)]\nprob = FVMProblem(mesh, BCs, ICs;\n    diffusion_function, diffusion_parameters,\n    source_function, initial_condition,\n    final_time=Inf)\nsteady_prob = SteadyFVMProblem(prob)\nsol = solve(steady_prob, DynamicSS(Rosenbrock23()))\nfig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=\"x\", ylabel=\"y\")\ntricontourf!(ax, tri, sol.u, levels=0:500:10000, extendhigh=:auto)\nlines!(ax, [xin; xin[1]], [yin; yin[1]], color=:magenta, linewidth=5)\nfig\n\nεr = 0.25\nθref = LinRange(εr, 2π - εr, 200)\nθabs = LinRange(2π - εr, 2π + εr, 200)\nxref = @. R₂ * cos(θref)\nyref = @. R₂ * sin(θref)\nxabs = @. R₂ * cos(θabs)\nyabs = @. R₂ * sin(θabs)\nxref[end] = xabs[begin]\nyref[end] = yabs[begin]\nx = [xref, xabs]\ny = [yref, yabs]\nboundary_nodes, points = convert_boundary_points_to_indices(x, y)\ntri = triangulate(points; boundary_nodes, delete_ghosts=false)\nxin = @views (@. R1_f(θ) * cos(θ))[begin:end-1]\nyin = @views (@. R1_f(θ) * sin(θ))[begin:end-1]\nadd_point!(tri, xin[1], yin[1])\nfor i in 2:length(xin)\n    add_point!(tri, xin[i], yin[i])\n    n = num_points(tri)\n    add_edge!(tri, n - 1, n)\nend\nn = num_points(tri)\nadd_edge!(tri, n - 1, n)\nadd_point!(tri, 0.0, 0.0)\norigin_idx = num_points(tri)\nrefine!(tri; max_area=1e-3get_total_area(tri))\ntriplot(tri)\n\nmesh = FVMGeometry(tri)\nICs = InternalConditions((x, y, t, u, p) -> zero(u), dirichlet_nodes=Dict(origin_idx => 1))\nzero_f = (x, y, t, u, p) -> zero(u)\nBCs = BoundaryConditions(mesh, (zero_f, zero_f), (Neumann, Dirichlet))\nICs = InternalConditions((x, y, t, u, p) -> zero(u), dirichlet_nodes=Dict(origin_idx => 1))\ninitial_condition = [T_exact(x, y) for (x, y) in each_point(tri)]\nprob = FVMProblem(mesh, BCs, ICs;\n    diffusion_function, diffusion_parameters,\n    source_function, initial_condition,\n    final_time=Inf)\nsteady_prob = SteadyFVMProblem(prob)\nsol = solve(steady_prob, DynamicSS(Rosenbrock23()))\nfig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=\"x\", ylabel=\"y\")\ntricontourf!(ax, tri, sol.u, levels=0:2500:35000, extendhigh=:auto)\nlines!(ax, [xin; xin[1]], [yin; yin[1]], color=:magenta, linewidth=5)\nfig\n\nxhole = @. cos(θ)\nyhole = @. sin(θ)\nreverse!(xhole) # clockwise\nreverse!(yhole)\nxhole[begin] = xhole[end]\nyhole[begin] = yhole[end]\nx = [[xref, xabs], [xhole]]\ny = [[yref, yabs], [yhole]]\nboundary_nodes, points = convert_boundary_points_to_indices(x, y)\ntri = triangulate(points; boundary_nodes, delete_ghosts=false)\nxin = @views (@. R1_f(θ) * cos(θ))[begin:end-1]\nyin = @views (@. R1_f(θ) * sin(θ))[begin:end-1]\nadd_point!(tri, xin[1], yin[1])\nfor i in 2:length(xin)\n    add_point!(tri, xin[i], yin[i])\n    n = num_points(tri)\n    add_edge!(tri, n - 1, n)\nend\nn = num_points(tri)\nadd_edge!(tri, n - 1, n)\nadd_point!(tri, -2.0, 0.0)\nadd_point!(tri, 0.0, 2.95)\npointhole_idxs = [num_points(tri), num_points(tri)-1]\nrefine!(tri; max_area=1e-3get_total_area(tri))\ntriplot(tri)\n\nmesh = FVMGeometry(tri)\nICs = InternalConditions((x, y, t, u, p) -> zero(u), dirichlet_nodes=Dict(origin_idx => 1))\nzero_f = (x, y, t, u, p) -> zero(u)\nBCs = BoundaryConditions(mesh, (zero_f, zero_f, zero_f), (Neumann, Dirichlet, Dirichlet))\nICs = InternalConditions((x, y, t, u, p) -> zero(u), dirichlet_nodes=Dict(pointhole_idxs .=> 1))\ninitial_condition = [T_exact(x, y) for (x, y) in each_point(tri)]\nprob = FVMProblem(mesh, BCs, ICs;\n    diffusion_function, diffusion_parameters,\n    source_function, initial_condition,\n    final_time=Inf)\nsteady_prob = SteadyFVMProblem(prob)\nsol = solve(steady_prob, DynamicSS(Rosenbrock23()))\nfig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=\"x\", ylabel=\"y\")\ntricontourf!(ax, tri, sol.u, levels=0:1000:15000, extendhigh=:auto)\nlines!(ax, [xin; xin[1]], [yin; yin[1]], color=:magenta, linewidth=5)\nfig","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"","category":"page"},{"location":"tutorials/mean_exit_time/","page":"Mean Exit Time","title":"Mean Exit Time","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"EditURL = \"https://github.com/DanielVandH/FiniteVolumeMethod.jl/tree/main/docs/src/literate_tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk.jl\"","category":"page"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/#Reaction-Diffusion-Equation-with-a-Time-dependent-Dirichlet-Boundary-Condition-on-a-Disk","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"","category":"section"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"In this tutorial, we consider a reaction-diffusion equation on a disk with a boundary condition of the form mathrm dumathrm dt = u:","category":"page"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"beginequation*\nbeginaligned\npdvu(r theta t)t = divugrad u + u(1-u)  0r10theta2pi6pt\ndvu(1 theta t)t = u(1thetat)  0theta2pit06pt\nu(rtheta0) = sqrtI_0(sqrt2r)  0r10theta2pi\nendaligned\nendequation*","category":"page"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"where I_0 is the modified Bessel function of the first kind of order zero. For this problem the diffusion function is D(vb x t u) = u and the source function is R(vb x t u) = u(1-u), or equivalently the force function is","category":"page"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"vb q(vb x t alphabetagamma) = left(-alpha(alpha x + beta y + gamma) -beta(alpha x + beta y + gamma)right)^mkern-15mumathsfT","category":"page"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"As usual, we start by generating the mesh.","category":"page"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"using FiniteVolumeMethod, DelaunayTriangulation, ElasticArrays\nr = fill(1, 100)\nθ = LinRange(0, 2π, 100)\nx = @. r * cos(θ)\ny = @. r * sin(θ)\nx[end] = x[begin]\ny[end] = y[begin] # make sure the curve connects at the endpoints\nboundary_nodes, points = convert_boundary_points_to_indices(x, y; existing_points=ElasticMatrix{Float64}(undef, 2, 0))\ntri = triangulate(points; boundary_nodes)\nA = get_total_area(tri)\nrefine!(tri; max_area=1e-4A)\nmesh = FVMGeometry(tri)","category":"page"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"triplot(tri)","category":"page"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"Now we define the boundary conditions and the PDE.","category":"page"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"using Bessels\nBCs = BoundaryConditions(mesh, (x, y, t, u, p) -> u, Dudt)","category":"page"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"f = (x, y) -> sqrt(besseli(0.0, sqrt(2) * sqrt(x^2 + y^2)))\nD = (x, y, t, u, p) -> u\nR = (x, y, t, u, p) -> u * (1 - u)\ninitial_condition = [f(x, y) for (x, y) in each_point(tri)]\nfinal_time = 0.10\nprob = FVMProblem(mesh, BCs;\n    diffusion_function=D,\n    source_function=R,\n    final_time,\n    initial_condition)","category":"page"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"We can now solve.","category":"page"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"using OrdinaryDiffEq, LinearSolve\nalg = FBDF(linsolve=UMFPACKFactorization(), autodiff=false)\nsol = solve(prob, alg, saveat=0.01)","category":"page"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"using CairoMakie\nfig = Figure(fontsize=38)\nfor (i, j) in zip(1:3, (1, 6, 11))\n    ax = Axis(fig[1, i], width=600, height=600,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[j])\",\n        titlealign=:left)\n    tricontourf!(ax, tri, sol.u[j], levels=1:0.01:1.4, colormap=:matter)\n    tightlimits!(ax)\nend\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/#Just-the-code","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Just the code","text":"","category":"section"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"using FiniteVolumeMethod, DelaunayTriangulation, ElasticArrays\nr = fill(1, 100)\nθ = LinRange(0, 2π, 100)\nx = @. r * cos(θ)\ny = @. r * sin(θ)\nx[end] = x[begin]\ny[end] = y[begin] # make sure the curve connects at the endpoints\nboundary_nodes, points = convert_boundary_points_to_indices(x, y; existing_points=ElasticMatrix{Float64}(undef, 2, 0))\ntri = triangulate(points; boundary_nodes)\nA = get_total_area(tri)\nrefine!(tri; max_area=1e-4A)\nmesh = FVMGeometry(tri)\n\ntriplot(tri)\n\nusing Bessels\nBCs = BoundaryConditions(mesh, (x, y, t, u, p) -> u, Dudt)\n\nf = (x, y) -> sqrt(besseli(0.0, sqrt(2) * sqrt(x^2 + y^2)))\nD = (x, y, t, u, p) -> u\nR = (x, y, t, u, p) -> u * (1 - u)\ninitial_condition = [f(x, y) for (x, y) in each_point(tri)]\nfinal_time = 0.10\nprob = FVMProblem(mesh, BCs;\n    diffusion_function=D,\n    source_function=R,\n    final_time,\n    initial_condition)\n\nusing OrdinaryDiffEq, LinearSolve\nalg = FBDF(linsolve=UMFPACKFactorization(), autodiff=false)\nsol = solve(prob, alg, saveat=0.01)\n\nusing CairoMakie\nfig = Figure(fontsize=38)\nfor (i, j) in zip(1:3, (1, 6, 11))\n    ax = Axis(fig[1, i], width=600, height=600,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[j])\",\n        titlealign=:left)\n    tricontourf!(ax, tri, sol.u[j], levels=1:0.01:1.4, colormap=:matter)\n    tightlimits!(ax)\nend\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"","category":"page"},{"location":"tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/","page":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","title":"Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"EditURL = \"https://github.com/DanielVandH/FiniteVolumeMethod.jl/tree/main/docs/src/literate_tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems.jl\"","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/#Equilibrium-Temperature-Distribution-with-Mixed-Boundary-Conditions-and-using-EnsembleProblems","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"","category":"section"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"For this tutorial, we consider the following problem:","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"beginequation\nbeginaligned\ngrad^2 T = 0  vb x in Omega \ngrad T vdot vu n = 0  vb x in Gamma_1 \nT = 40  vb x in Gamma_2 \nkgrad T vdot vu n = h(T_infty - T)  vb x in Gamma_3 \nT = 70  vb x in Gamma_4 \nendaligned\nendequation","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"This domain Omega with boundary partialOmega=Gamma_1cupGamma_2cupGamma_3cupGamma_4 is shown below.","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"using CairoMakie #hide\nA = (0.0, 0.06) #hide\nB = (0.03, 0.06) #hide\nF = (0.03, 0.05) #hide\nG = (0.05, 0.03) #hide\nC = (0.06, 0.03) #hide\nD = (0.06, 0.0) #hide\nE = (0.0, 0.0) #hide\nfig = Figure(fontsize=33) #hide\nax = Axis(fig[1, 1], xlabel=\"x\", ylabel=\"y\") #hide\nlines!(ax, [A, E, D], color=:red, linewidth=5) #hide\nlines!(ax, [B, F, G, C], color=:blue, linewidth=5) #hide\nlines!(ax, [C, D], color=:black, linewidth=5) #hide\nlines!(ax, [A, B], color=:magenta, linewidth=5) #hide\ntext!(ax, [(0.03, 0.001)], text=L\"\\Gamma_1\", fontsize=44) #hide\ntext!(ax, [(0.055, 0.01)], text=L\"\\Gamma_2\", fontsize=44) #hide\ntext!(ax, [(0.04, 0.04)], text=L\"\\Gamma_3\", fontsize=44) #hide\ntext!(ax, [(0.015, 0.053)], text=L\"\\Gamma_4\", fontsize=44) #hide\ntext!(ax, [(0.001, 0.03)], text=L\"\\Gamma_1\", fontsize=44) #hide\nfig #hide","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"Let us start by defining the mesh.","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"using DelaunayTriangulation, FiniteVolumeMethod, CairoMakie\nA, B, C, D, E, F, G = (0.0, 0.0),\n(0.06, 0.0),\n(0.06, 0.03),\n(0.05, 0.03),\n(0.03, 0.05),\n(0.03, 0.06),\n(0.0, 0.06)\nbn1 = [G, A, B]\nbn2 = [B, C]\nbn3 = [C, D, E, F]\nbn4 = [F, G]\nbn = [bn1, bn2, bn3, bn4]\nboundary_nodes, points = convert_boundary_points_to_indices(bn)\ntri = triangulate(points; boundary_nodes)\nrefine!(tri; max_area=1e-4get_total_area(tri))\ntriplot(tri)","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"mesh = FVMGeometry(tri)","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"For the boundary conditions, the parameters that we use are k = 3, h = 20, and T_infty = 20 for thermal conductivity, heat transfer coefficient, and ambient temperature, respectively.","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"k = 3.0\nh = 20.0\nT∞ = 20.0\nbc1 = (x, y, t, T, p) -> zero(T) # ∇T⋅n=0\nbc2 = (x, y, t, T, p) -> oftype(T, 40.0) # T=40\nbc3 = (x, y, t, T, p) -> -p.h * (p.T∞ - T) / p.k # k∇T⋅n=h(T∞-T). The minus is since q = -∇T\nbc4 = (x, y, t, T, p) -> oftype(T, 70.0) # T=70\nparameters = (nothing, nothing, (h=h, T∞=T∞, k=k), nothing)\nBCs = BoundaryConditions(mesh, (bc1, bc2, bc3, bc4),\n    (Neumann, Dirichlet, Neumann, Dirichlet);\n    parameters)","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"Now we can define the actual problem. For the initial condition, which recall is used as an initial guess for steady state problems, let us use an initial condition which ranges from T=70 at y=006 down to T=40 at y=0.","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"diffusion_function = (x, y, t, T, p) -> one(T)\nf = (x, y) -> 500y + 40\ninitial_condition = [f(x, y) for (x, y) in each_point(tri)]\nfinal_time = Inf\nprob = FVMProblem(mesh, BCs;\n    diffusion_function,\n    initial_condition,\n    final_time)","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"steady_prob = SteadyFVMProblem(prob)","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"Now we can solve.","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"using OrdinaryDiffEq, SteadyStateDiffEq\nsol = solve(steady_prob, DynamicSS(Rosenbrock23()))","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"fig, ax, sc = tricontourf(tri, sol.u, levels=40:70, axis=(xlabel=\"x\", ylabel=\"y\"))\nfig","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"Let us now suppose we are interested in how the ambient temperature, T_infty, affects the temperature distribution. In particular, let us ask the following question:","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"What range of T_infty will allow the temperature at (003 003) to be between 50 and 55?","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"To answer this question, we use an EnsembleProblem so that we can solve the problem over many values of T_infty efficiently. For these new problems, it would be a good idea to use a new initial condition given by the solution of the previous problem.","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"copyto!(prob.initial_condition, sol.u)\nusing Accessors\nT∞_range = LinRange(-100, 100, 101)\nens_prob = EnsembleProblem(steady_prob,\n    prob_func=(prob, i, repeat) -> let T∞_range = T∞_range, h = h, k = k\n        _prob =\n            @set prob.problem.conditions.functions[3].parameters =\n                (h=h, T∞=T∞_range[i], k=k)\n        return _prob\n    end,\n    safetycopy=false)\nesol = solve(ens_prob, DynamicSS(Rosenbrock23()); trajectories=length(T∞_range))","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"From these results, let us now extract the temperature at (003 003). We will use NaturalNeighbours.jl for this.","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"using NaturalNeighbours\nitps = [interpolate(tri, esol[i].u) for i in eachindex(esol)];\nitp_vals = [itp(0.03, 0.03; method=Sibson()) for itp in itps]\n# If you want piecewise linear interpolation, use either method=Triangle()\n# or itp_vals = [pl_interpolate(prob, T, sol.u, 0.03, 0.03) for sol in esol], where\n# T = jump_and_march(tri, (0.03, 0.03)).\nfig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=L\"T_{\\infty}\", ylabel=L\"T(0.03, 0.03)\")\nlines!(ax, T∞_range, itp_vals, linewidth=4)\nfig","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"We see that the temperature at this point seems to increase linearly with T_infty. Let us find precisely where this curve meets T=50 and T=55.","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"using NonlinearSolve, DataInterpolations\nitp = LinearInterpolation(itp_vals, T∞_range)\nrootf = (u, p) -> p.itp(u) - p.τ[]\nTthresh = Ref(50.0)\nprob = IntervalNonlinearProblem(rootf, (-100.0, 100.0), (itp=itp, τ=Tthresh))\nsol50 = solve(prob, ITP())","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"Tthresh[] = 55.0\nsol55 = solve(prob, ITP())","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"So, it seems like the answer to our question is -118 leq T_infty leq 55. Here is an an animation of the temperature distribution as T_infty varies.","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"fig = Figure(fontsize=33)\ni = Observable(1)\ntt = map(i -> L\"T_{\\infty} = %$(rpad(round(T∞_range[i], digits=3),5,'0'))\", i)\nu = map(i -> esol.u[i], i)\nax = Axis(fig[1, 1], xlabel=L\"x\", ylabel=L\"y\",\n    title=tt, titlealign=:left)\ntricontourf!(ax, tri, u, levels=40:70, extendlow=:auto, extendhigh=:auto)\ntightlimits!(ax)\nrecord(fig, joinpath(@__DIR__, \"../figures\", \"temperature_animation.mp4\"), eachindex(esol);\n    framerate=12) do _i\n    i[] = _i\nend;\nnothing #hide","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"(Image: Animation of the temperature distribution)","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/#Just-the-code","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Just the code","text":"","category":"section"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"using DelaunayTriangulation, FiniteVolumeMethod, CairoMakie\nA, B, C, D, E, F, G = (0.0, 0.0),\n(0.06, 0.0),\n(0.06, 0.03),\n(0.05, 0.03),\n(0.03, 0.05),\n(0.03, 0.06),\n(0.0, 0.06)\nbn1 = [G, A, B]\nbn2 = [B, C]\nbn3 = [C, D, E, F]\nbn4 = [F, G]\nbn = [bn1, bn2, bn3, bn4]\nboundary_nodes, points = convert_boundary_points_to_indices(bn)\ntri = triangulate(points; boundary_nodes)\nrefine!(tri; max_area=1e-4get_total_area(tri))\ntriplot(tri)\n\nmesh = FVMGeometry(tri)\n\nk = 3.0\nh = 20.0\nT∞ = 20.0\nbc1 = (x, y, t, T, p) -> zero(T) # ∇T⋅n=0\nbc2 = (x, y, t, T, p) -> oftype(T, 40.0) # T=40\nbc3 = (x, y, t, T, p) -> -p.h * (p.T∞ - T) / p.k # k∇T⋅n=h(T∞-T). The minus is since q = -∇T\nbc4 = (x, y, t, T, p) -> oftype(T, 70.0) # T=70\nparameters = (nothing, nothing, (h=h, T∞=T∞, k=k), nothing)\nBCs = BoundaryConditions(mesh, (bc1, bc2, bc3, bc4),\n    (Neumann, Dirichlet, Neumann, Dirichlet);\n    parameters)\n\ndiffusion_function = (x, y, t, T, p) -> one(T)\nf = (x, y) -> 500y + 40\ninitial_condition = [f(x, y) for (x, y) in each_point(tri)]\nfinal_time = Inf\nprob = FVMProblem(mesh, BCs;\n    diffusion_function,\n    initial_condition,\n    final_time)\n\nsteady_prob = SteadyFVMProblem(prob)\n\nusing OrdinaryDiffEq, SteadyStateDiffEq\nsol = solve(steady_prob, DynamicSS(Rosenbrock23()))\n\nfig, ax, sc = tricontourf(tri, sol.u, levels=40:70, axis=(xlabel=\"x\", ylabel=\"y\"))\nfig\n\ncopyto!(prob.initial_condition, sol.u)\nusing Accessors\nT∞_range = LinRange(-100, 100, 101)\nens_prob = EnsembleProblem(steady_prob,\n    prob_func=(prob, i, repeat) -> let T∞_range = T∞_range, h = h, k = k\n        _prob =\n            @set prob.problem.conditions.functions[3].parameters =\n                (h=h, T∞=T∞_range[i], k=k)\n        return _prob\n    end,\n    safetycopy=false)\nesol = solve(ens_prob, DynamicSS(Rosenbrock23()); trajectories=length(T∞_range))\n\nusing NaturalNeighbours\nitps = [interpolate(tri, esol[i].u) for i in eachindex(esol)];\nitp_vals = [itp(0.03, 0.03; method=Sibson()) for itp in itps]\n# If you want piecewise linear interpolation, use either method=Triangle()\n# or itp_vals = [pl_interpolate(prob, T, sol.u, 0.03, 0.03) for sol in esol], where\n# T = jump_and_march(tri, (0.03, 0.03)).\nfig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=L\"T_{\\infty}\", ylabel=L\"T(0.03, 0.03)\")\nlines!(ax, T∞_range, itp_vals, linewidth=4)\nfig\n\nusing NonlinearSolve, DataInterpolations\nitp = LinearInterpolation(itp_vals, T∞_range)\nrootf = (u, p) -> p.itp(u) - p.τ[]\nTthresh = Ref(50.0)\nprob = IntervalNonlinearProblem(rootf, (-100.0, 100.0), (itp=itp, τ=Tthresh))\nsol50 = solve(prob, ITP())\n\nTthresh[] = 55.0\nsol55 = solve(prob, ITP())\n\nfig = Figure(fontsize=33)\ni = Observable(1)\ntt = map(i -> L\"T_{\\infty} = %$(rpad(round(T∞_range[i], digits=3),5,'0'))\", i)\nu = map(i -> esol.u[i], i)\nax = Axis(fig[1, 1], xlabel=L\"x\", ylabel=L\"y\",\n    title=tt, titlealign=:left)\ntricontourf!(ax, tri, u, levels=40:70, extendlow=:auto, extendhigh=:auto)\ntightlimits!(ax)\nrecord(fig, joinpath(@__DIR__, \"../figures\", \"temperature_animation.mp4\"), eachindex(esol);\n    framerate=12) do _i\n    i[] = _i\nend;","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"","category":"page"},{"location":"tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/","page":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"EditURL = \"https://github.com/DanielVandH/FiniteVolumeMethod.jl/tree/main/docs/src/literate_tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation.jl\"","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/#Piecewise-Linear-and-Natural-Neighbour-Inteprolation-for-an-Advection-Diffusion-Equation","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Inteprolation for an Advection-Diffusion Equation","text":"","category":"section"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"In this tutorial, we have three aims:","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"Demonstrate how to solve an advection-diffusion equation.\nDemonstrate how piecewise linear interpolation can be applied to a PDE solution at each time.\nDemonstrate how  NaturalNeighbours.jl can be applied to compute more accurate interpolants than piecewise linear interpolation at each time.","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"The equation we will be considering is","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"beginequationlabeleqadvdiffeq\nbeginaligned\npdvut = Dpdv2ux + Dpdv2uy - nupdvux\nendaligned\nendequation","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"with u(vb x 0) = delta(vb x) and homogeneous Dirichlet conditions, where delta is the Dirac delta function. This equation is defined on mathbb R^2, but we will replace mathbb R^2 with Omega = -L L^2 for L = 30.","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/#Solving-the-problem","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Solving the problem","text":"","category":"section"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"We start by defining and solving the problem associated with \\eqref{eq:advdiffeq}. For the mesh, we could use triangulate_rectangle, but we want to put most of the triangles near the origin, so we need to use refine! on an initial mesh.","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"using DelaunayTriangulation, FiniteVolumeMethod, LinearAlgebra, CairoMakie\nL = 30\ntri = triangulate_rectangle(-L, L, -L, L, 2, 2, single_boundary=true)\ntot_area = get_total_area(tri)\nmax_area_function = (A, r) -> 1e-6tot_area * r^2 / A\narea_constraint = (T, p, q, r, A) -> begin\n    p, q, r = get_point(tri, T...)\n    c = (p .+ q .+ r) ./ 3\n    dist_to_origin = norm(c)\n    flag = A ≥ max_area_function(A, dist_to_origin)\n    return flag\nend\nrefine!(tri; min_angle=33.0, max_area=area_constraint)\ntriplot(tri)","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"mesh = FVMGeometry(tri)","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"The boundary conditions are homogeneous Dirichlet conditions.","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"BCs = BoundaryConditions(mesh, (x, y, t, u, p) -> zero(u), Dirichlet)","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"We now need to define the actual problem. We need to write \\eqref{eq:advdiffeq} in the form","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"pdvut + divvb q = 0","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"To do this, write:","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"beginalign*\ndiv vb q = nupdvux - Dpdv2ux - Dpdv2uy \n= pdvxleft(nu u - Dpdvuxright) - pdvyleft(Dpdvuyright) \n= div beginbmatrix nu u - Dpdvux  -Dpdvuy endbmatrix^mkern-15mumathsfT \n= div left(boldsymbolnu u - Dgrad uright)\nendalign*","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"where boldsymbolnu = (nu 0)^mkern-15mumathsfT. Thus, we can write","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"vb q = boldsymbolnu u - Dgrad u","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"We now have our flux function. Next, let us define the initial condition. We approximate by","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"delta(vb x) approx g(vb x) approx frac1varepsilon^2piexpleft-frac1varepsilon^2left(x^2+y^2right)right","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"taking varepsilon=110. We can now define the problem. Remember that the flux function takes argument (alpha beta gamma) rather than u, replacing u with u(x y) = alpha x + beta y + gamma, and it returns a Tuple representing the vector. We let D = 002 and nu = 005.","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"ε = 1 / 10\nf = (x, y) -> 1 / (ε^2 * π) * exp(-(x^2 + y^2) / ε^2)\ninitial_condition = [f(x, y) for (x, y) in each_point(tri)]\nflux_function = (x, y, t, α, β, γ, p) -> begin\n    ∂x = α\n    ∂y = β\n    u = α * x + β * y + γ\n    qx = p.ν * u - p.D * ∂x\n    qy = -p.D * ∂y\n    return (qx, qy)\nend\nflux_parameters = (D=0.02, ν=0.05)\nfinal_time = 250.0\nprob = FVMProblem(mesh, BCs;\n    initial_condition,\n    flux_function,\n    flux_parameters,\n    final_time)","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"Now we can solve and visualise the solution.","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"using OrdinaryDiffEq, LinearSolve\ntimes = [0, 10, 25, 50, 100, 200, 250]\nsol = solve(prob, TRBDF2(linsolve=KLUFactorization()), saveat=times)","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"using CairoMakie\nfig = Figure(fontsize=38)\nfor i in eachindex(sol)\n    ax = Axis(fig[1, i], width=400, height=400,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[i])\",\n        titlealign=:left)\n    tricontourf!(ax, tri, sol.u[i], levels=0:0.00001:0.001, extendhigh=:auto, extendlow=:auto, colormap=:matter)\n    tightlimits!(ax)\n    ylims!(ax, -10, 10)\nend\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/#Piecewise-linear-interpolation","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise linear interpolation","text":"","category":"section"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"As mentioned in mathematical details section, a key part of the finite volume method is the assumption that u is piecewise linear between each triangular element, letting u(x y) = alpha x + beta y + gamma. Thus, it may be natural to want to interpolate the solution using piecewise linear interpolation. This could be done by making use of jump_and_march from DelaunayTriangulation.jl to find the triangle containing a given point (x y) and then use pl_interpolate to interpolate the solution at the point; we do not provide a method that gets this triangle for you and then interpolates without this intermediate jump_and_march, as it is typically more efficient to first obtain all the triangles you need and then interpolate. In what follows, we:","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"Define a grid to interpolate over.\nFind the triangles containing each point in the grid.\nInterpolate at each point for the given times.","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"We consider the times t = 10 25 50 100 200 250. You could also of course amend the procedure so that you evaluate the interpolant at each time for a given point first, allowing you to avoid storing the triangle since you only consider each point a single time.","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"x = LinRange(-L, L, 250)\ny = LinRange(-L, L, 250)\ntriangles = Matrix{NTuple{3,Int}}(undef, length(x), length(y))\nfor j in eachindex(y)\n    for i in eachindex(x)\n        triangles[i, j] = jump_and_march(tri, (x[i], y[j]))\n    end\nend\ninterpolated_vals = zeros(length(x), length(y), length(sol))\nfor k in eachindex(sol)\n    for j in eachindex(y)\n        for i in eachindex(x)\n            interpolated_vals[i, j, k] = pl_interpolate(prob, triangles[i, j], sol.u[k], x[i], y[j])\n        end\n    end\nend","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"Let's visualise these results to check their accuracy. We compute the triangulation of our grid to make the tricontourf call faster.","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"_tri = triangulate([[x for x in x, _ in y] |> vec [y for _ in x, y in y] |> vec]')\nfig = Figure(fontsize=38)\nfor i in eachindex(sol)\n    ax = Axis(fig[1, i], width=400, height=400,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[i])\",\n        titlealign=:left)\n    tricontourf!(ax, _tri, interpolated_vals[:, :, i] |> vec, levels=0:0.00001:0.001, extendhigh=:auto, extendlow=:auto, colormap=:matter)\n    tightlimits!(ax)\n    ylims!(ax, -10, 10)\nend\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/#Natural-neighbour-interpolation","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Natural neighbour interpolation","text":"","category":"section"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"Since the solution is defined over a triangulation, the most natural form of inteprolation to use, other than piecewise linear interpolation, is natural neighbour interpolation. We can use NaturalNeighbours.jl for this; NaturalNeighbours.jl also provides the same piecewise linear interpolant above via its Triangle() interpolator, which may be more efficient as it has multithreading built in.","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"The way to construct a natural neighbour interpolant is as follows, where we provide the interpolant with the solution at t = 50.","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"using NaturalNeighbours\nitp = interpolate(tri, sol.u[4], derivatives=true) # sol.t[4] == 50","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"We need derivatives = true so that we can use the higher order interpolants Sibson(1), Hiyoshi(2), and Farin() below - if you don't use those, then you shouldn't need this option (unless you want to later differentiate the interpolant using differentiate, then yes you do need it).","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"We can then evaluate this interpolant by simply calling it. The most efficient way to call it is by providing it with a vector of points, rather than broadcasting over points, since multithreading can be used in this case. Let us interpolate at the grid from before, which requires us to collect it into a vector:","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"_x = [x for x in x, _ in y] |> vec\n_y = [y for _ in x, y in y] |> vec","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"We will look at all the interpolants provided by NaturalNeighbours.jl.[1]","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"[1]: This list is available from ?NaturalNeighbours.AbstractInterpolator. Look at the help page (?) for the respective interpolators or NaturalNeighbours.jl's documentation for more information.","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"sibson_vals = itp(_x, _y; method=Sibson())\ntriangle_vals = itp(_x, _y; method=Triangle()) # this is the same as pl_interpolate\nlaplace_vals = itp(_x, _y; method=Laplace())\nsibson_1_vals = itp(_x, _y; method=Sibson(1))\nnearest_vals = itp(_x, _y; method=Nearest())\nfarin_vals = itp(_x, _y; method=Farin())\nhiyoshi_vals = itp(_x, _y; method=Hiyoshi(2))\npde_vals = sol.u[4]","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"We visualise these results as follows.","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"fig = Figure(fontsize=38)\nall_vals = (sibson_vals, triangle_vals, laplace_vals, sibson_1_vals, nearest_vals, farin_vals, hiyoshi_vals, pde_vals)\ntitles = (\"(a): Sibson\", \"(b): Triangle\", \"(c): Laplace\", \"(d): Sibson-1\", \"(e): Nearest\", \"(f): Farin\", \"(g): Hiyoshi\", \"(h): PDE\")\nfig = Figure(fontsize=55, resolution=(6350, 1550)) # resolution from resize_to_layout!(fig) - had to manually adjust to fix missing ticks\nfor (i, (vals, title)) in enumerate(zip(all_vals, titles))\n    ax2d = Axis(fig[1, i], xlabel=\"x\", ylabel=\"y\", width=600, height=600, title=title, titlealign=:left)\n    ax3d = Axis3(fig[2, i], xlabel=\"x\", ylabel=\"y\", width=600, height=600, title=title, titlealign=:left)\n    ax3d.zlabeloffset[] = 125\n    xlims!(ax2d, -4, 6)\n    ylims!(ax2d, -4, 4)\n    xlims!(ax3d, -4, 6)\n    ylims!(ax3d, -4, 4)\n    if vals ≠ pde_vals\n        contourf!(ax2d, _x, _y, vals, color=vals, colormap=:matter, levels=0:0.001:0.1, extendlow=:auto, extendhigh=:auto)\n        vals = copy(vals)\n        vals[(_x.<-4).|(_x.>6)] .= NaN\n        vals[(_y.<-4).|(_y.>4)] .= NaN # This is the only way to fix the weird issues with Axis3 when changing the (x/y/z)lims...\n        surface!(ax3d, _x, _y, vals, color=vals, colormap=:matter, colorrange=(0, 0.1), extendlow=:auto, extendhigh=:auto)\n    else\n        tricontourf!(ax2d, tri, vals, color=vals, colormap=:matter, levels=0:0.001:0.1, extendlow=:auto, extendhigh=:auto)\n        triangles = [T[j] for T in each_solid_triangle(tri), j in 1:3]\n        x = getx.(get_points(tri))\n        y = gety.(get_points(tri))\n        vals = copy(vals)\n        vals[(x.<-4).|(x.>6)] .= NaN\n        vals[(y.<-4).|(y.>4)] .= NaN # This is the only way to fix the weird issues with Axis3 when changing the (x/y/z)lims...\n        mesh!(ax3d, hcat(x, y, vals), triangles, color=vals, colormap=:matter, colorrange=(0, 0.1))\n    end\nend\nfig","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"We note that natural neighbour interpolation is not technically well defined for constrained triangulations. In this case it is fine, but for regions with, say, holes or non-convex boundaries, you may run into issues. For such cases, you should usually call the interpolant with project=false to at least help the procedure a bit. You may also be interested in identify_exterior_points. We consider interpolating data over a region with holes in this annulus example.","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/#Just-the-code","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Just the code","text":"","category":"section"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"using DelaunayTriangulation, FiniteVolumeMethod, LinearAlgebra, CairoMakie\nL = 30\ntri = triangulate_rectangle(-L, L, -L, L, 2, 2, single_boundary=true)\ntot_area = get_total_area(tri)\nmax_area_function = (A, r) -> 1e-6tot_area * r^2 / A\narea_constraint = (T, p, q, r, A) -> begin\n    p, q, r = get_point(tri, T...)\n    c = (p .+ q .+ r) ./ 3\n    dist_to_origin = norm(c)\n    flag = A ≥ max_area_function(A, dist_to_origin)\n    return flag\nend\nrefine!(tri; min_angle=33.0, max_area=area_constraint)\ntriplot(tri)\n\nmesh = FVMGeometry(tri)\n\nBCs = BoundaryConditions(mesh, (x, y, t, u, p) -> zero(u), Dirichlet)\n\nε = 1 / 10\nf = (x, y) -> 1 / (ε^2 * π) * exp(-(x^2 + y^2) / ε^2)\ninitial_condition = [f(x, y) for (x, y) in each_point(tri)]\nflux_function = (x, y, t, α, β, γ, p) -> begin\n    ∂x = α\n    ∂y = β\n    u = α * x + β * y + γ\n    qx = p.ν * u - p.D * ∂x\n    qy = -p.D * ∂y\n    return (qx, qy)\nend\nflux_parameters = (D=0.02, ν=0.05)\nfinal_time = 250.0\nprob = FVMProblem(mesh, BCs;\n    initial_condition,\n    flux_function,\n    flux_parameters,\n    final_time)\n\nusing OrdinaryDiffEq, LinearSolve\ntimes = [0, 10, 25, 50, 100, 200, 250]\nsol = solve(prob, TRBDF2(linsolve=KLUFactorization()), saveat=times)\n\nusing CairoMakie\nfig = Figure(fontsize=38)\nfor i in eachindex(sol)\n    ax = Axis(fig[1, i], width=400, height=400,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[i])\",\n        titlealign=:left)\n    tricontourf!(ax, tri, sol.u[i], levels=0:0.00001:0.001, extendhigh=:auto, extendlow=:auto, colormap=:matter)\n    tightlimits!(ax)\n    ylims!(ax, -10, 10)\nend\nresize_to_layout!(fig)\nfig\n\nx = LinRange(-L, L, 250)\ny = LinRange(-L, L, 250)\ntriangles = Matrix{NTuple{3,Int}}(undef, length(x), length(y))\nfor j in eachindex(y)\n    for i in eachindex(x)\n        triangles[i, j] = jump_and_march(tri, (x[i], y[j]))\n    end\nend\ninterpolated_vals = zeros(length(x), length(y), length(sol))\nfor k in eachindex(sol)\n    for j in eachindex(y)\n        for i in eachindex(x)\n            interpolated_vals[i, j, k] = pl_interpolate(prob, triangles[i, j], sol.u[k], x[i], y[j])\n        end\n    end\nend\n\n_tri = triangulate([[x for x in x, _ in y] |> vec [y for _ in x, y in y] |> vec]')\nfig = Figure(fontsize=38)\nfor i in eachindex(sol)\n    ax = Axis(fig[1, i], width=400, height=400,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[i])\",\n        titlealign=:left)\n    tricontourf!(ax, _tri, interpolated_vals[:, :, i] |> vec, levels=0:0.00001:0.001, extendhigh=:auto, extendlow=:auto, colormap=:matter)\n    tightlimits!(ax)\n    ylims!(ax, -10, 10)\nend\nresize_to_layout!(fig)\nfig\n\nusing NaturalNeighbours\nitp = interpolate(tri, sol.u[4], derivatives=true) # sol.t[4] == 50\n\n_x = [x for x in x, _ in y] |> vec\n_y = [y for _ in x, y in y] |> vec\n\nsibson_vals = itp(_x, _y; method=Sibson())\ntriangle_vals = itp(_x, _y; method=Triangle()) # this is the same as pl_interpolate\nlaplace_vals = itp(_x, _y; method=Laplace())\nsibson_1_vals = itp(_x, _y; method=Sibson(1))\nnearest_vals = itp(_x, _y; method=Nearest())\nfarin_vals = itp(_x, _y; method=Farin())\nhiyoshi_vals = itp(_x, _y; method=Hiyoshi(2))\npde_vals = sol.u[4]\n\nfig = Figure(fontsize=38)\nall_vals = (sibson_vals, triangle_vals, laplace_vals, sibson_1_vals, nearest_vals, farin_vals, hiyoshi_vals, pde_vals)\ntitles = (\"(a): Sibson\", \"(b): Triangle\", \"(c): Laplace\", \"(d): Sibson-1\", \"(e): Nearest\", \"(f): Farin\", \"(g): Hiyoshi\", \"(h): PDE\")\nfig = Figure(fontsize=55, resolution=(6350, 1550)) # resolution from resize_to_layout!(fig) - had to manually adjust to fix missing ticks\nfor (i, (vals, title)) in enumerate(zip(all_vals, titles))\n    ax2d = Axis(fig[1, i], xlabel=\"x\", ylabel=\"y\", width=600, height=600, title=title, titlealign=:left)\n    ax3d = Axis3(fig[2, i], xlabel=\"x\", ylabel=\"y\", width=600, height=600, title=title, titlealign=:left)\n    ax3d.zlabeloffset[] = 125\n    xlims!(ax2d, -4, 6)\n    ylims!(ax2d, -4, 4)\n    xlims!(ax3d, -4, 6)\n    ylims!(ax3d, -4, 4)\n    if vals ≠ pde_vals\n        contourf!(ax2d, _x, _y, vals, color=vals, colormap=:matter, levels=0:0.001:0.1, extendlow=:auto, extendhigh=:auto)\n        vals = copy(vals)\n        vals[(_x.<-4).|(_x.>6)] .= NaN\n        vals[(_y.<-4).|(_y.>4)] .= NaN # This is the only way to fix the weird issues with Axis3 when changing the (x/y/z)lims...\n        surface!(ax3d, _x, _y, vals, color=vals, colormap=:matter, colorrange=(0, 0.1), extendlow=:auto, extendhigh=:auto)\n    else\n        tricontourf!(ax2d, tri, vals, color=vals, colormap=:matter, levels=0:0.001:0.1, extendlow=:auto, extendhigh=:auto)\n        triangles = [T[j] for T in each_solid_triangle(tri), j in 1:3]\n        x = getx.(get_points(tri))\n        y = gety.(get_points(tri))\n        vals = copy(vals)\n        vals[(x.<-4).|(x.>6)] .= NaN\n        vals[(y.<-4).|(y.>4)] .= NaN # This is the only way to fix the weird issues with Axis3 when changing the (x/y/z)lims...\n        mesh!(ax3d, hcat(x, y, vals), triangles, color=vals, colormap=:matter, colorrange=(0, 0.1))\n    end\nend\nfig","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"","category":"page"},{"location":"tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/","page":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"EditURL = \"https://github.com/DanielVandH/FiniteVolumeMethod.jl/tree/main/docs/src/literate_tutorials/diffusion_equation_on_a_square_plate.jl\"","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/#Diffusion-Equation-on-a-Square-Plate","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"","category":"section"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"This tutorial considers a diffusion equation on a square plate:","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"beginequation*\nbeginaligned\npdvu(vb x t)t = frac19grad^2 u(vb x t)   vb x in Omegat0 6pt\nu(vb x t)  =  0  vb x in partialOmegat06pt\nu(vb x 0) = f(vb x)  vb x in Omega\nendaligned\nendequation*","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"where Omega = 0 2^2 and","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"f(x y) = begincases 50  y leq 1  0  y  1 endcases","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"To solve this problem, the first step is to define the mesh.","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"using FiniteVolumeMethod, DelaunayTriangulation\na, b, c, d = 0.0, 2.0, 0.0, 2.0\nnx, ny = 50, 50\ntri = triangulate_rectangle(a, b, c, d, nx, ny, single_boundary=true)\nmesh = FVMGeometry(tri)","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"This mesh is shown below.","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"using CairoMakie\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"We now need to define the boundary conditions. We have a homogeneous Dirichlet condition:","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"bc = (x, y, t, u, p) -> zero(u)\nBCs = BoundaryConditions(mesh, bc, Dirichlet)","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"We can now define the actual PDE. We start by defining the initial condition and the diffusion function.","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"f = (x, y) -> y ≤ 1.0 ? 50.0 : 0.0\ninitial_condition = [f(x, y) for (x, y) in each_point(tri)]\nD = (x, y, t, u, p) -> 1 / 9","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"We can now define the problem:","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"final_time = 0.5\nprob = FVMProblem(mesh, BCs; diffusion_function=D, initial_condition, final_time)","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"Note that in prob, it is not a diffusion function that is used but instead it is a flux function:","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"prob.flux_function","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"When providing diffusion_function, the flux is given by vb q(vb x t alphabetagamma) = (-alpha9 -beta9)^mkern-15mumathsfT, where (alpha beta gamma) defines the approximation to u via u(x y) = alpha x + beta y + gamma so that grad u(vb x t) = (alphabeta)^mkern-15mumathsfT.","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"To now solve the problem, we simply use solve. When no algorithm is provided, as long as DifferentialEquations is loaded (instead of e.g. OrdinaryDiffEq), the algorithm is chosen automatically. Moreover, note that, in the solve call below, multithreading is enabled by default.","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"using DifferentialEquations\nsol = solve(prob, saveat=0.05)","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"To visualise the solution, we can use tricontourf! from Makie.jl.","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"using CairoMakie\nfig = Figure(fontsize=38)\nfor (i, j) in zip(1:3, (1, 6, 11))\n    ax = Axis(fig[1, i], width=600, height=600,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[j])\",\n        titlealign=:left)\n    tricontourf!(ax, tri, sol.u[j], levels=0:5:50, colormap=:matter)\n    tightlimits!(ax)\nend\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/#Just-the-code","page":"Diffusion Equation on a Square Plate","title":"Just the code","text":"","category":"section"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"using FiniteVolumeMethod, DelaunayTriangulation\na, b, c, d = 0.0, 2.0, 0.0, 2.0\nnx, ny = 50, 50\ntri = triangulate_rectangle(a, b, c, d, nx, ny, single_boundary=true)\nmesh = FVMGeometry(tri)\n\nusing CairoMakie\nfig, ax, sc = triplot(tri)\nfig\n\nbc = (x, y, t, u, p) -> zero(u)\nBCs = BoundaryConditions(mesh, bc, Dirichlet)\n\nf = (x, y) -> y ≤ 1.0 ? 50.0 : 0.0\ninitial_condition = [f(x, y) for (x, y) in each_point(tri)]\nD = (x, y, t, u, p) -> 1 / 9\n\nfinal_time = 0.5\nprob = FVMProblem(mesh, BCs; diffusion_function=D, initial_condition, final_time)\n\nprob.flux_function\n\nusing DifferentialEquations\nsol = solve(prob, saveat=0.05)\n\nusing CairoMakie\nfig = Figure(fontsize=38)\nfor (i, j) in zip(1:3, (1, 6, 11))\n    ax = Axis(fig[1, i], width=600, height=600,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[j])\",\n        titlealign=:left)\n    tricontourf!(ax, tri, sol.u[j], levels=0:5:50, colormap=:matter)\n    tightlimits!(ax)\nend\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"","category":"page"},{"location":"tutorials/diffusion_equation_on_a_square_plate/","page":"Diffusion Equation on a Square Plate","title":"Diffusion Equation on a Square Plate","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/#Gray-Scott-Model:-Turing-Patterns-from-a-Coupled-Reaction-Diffusion-System","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"","category":"section"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"In this tutorial, we explore some pattern formation from the Gray-Scott model:","category":"page"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"beginequation\nbeginaligned\npdvut = varepsilon_1grad^2u+b(1-u)-uv^2 \npdvvt = varepsilon_2grad^2 v - dv+uv^2\nendaligned\nendequation","category":"page"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"where u and v are the concentrations of two chemical species. The initial conditions we use are:","category":"page"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"beginalign*\nu(x y 0) = 1 -expleft-80left(x^2 + y^2right)right \nv(x y 0) = expleft-80left(x^2+y^2right)right\nendalign*","category":"page"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"The domain we use is -1 1^2, and we use zero flux boundary conditions.","category":"page"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"using FiniteVolumeMethod, DelaunayTriangulation\ntri = triangulate_rectangle(-1, 1, -1, 1, 200, 200, single_boundary=true)\nmesh = FVMGeometry(tri)","category":"page"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"bc = (x, y, t, (u, v), p) -> zero(u) * zero(v)\nu_BCs = BoundaryConditions(mesh, bc, Neumann)\nv_BCs = BoundaryConditions(mesh, bc, Neumann)","category":"page"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"ε₁ = 0.00002\nε₂ = 0.00001\nb = 0.04\nd = 0.1\nu_q = (x, y, t, α, β, γ, _ε₁) -> (-α[1] * _ε₁, -β[1] * _ε₁)\nv_q = (x, y, t, α, β, γ, _ε₂) -> (-α[2] * _ε₂, -β[2] * _ε₂)\nu_S = (x, y, t, (u, v), _b) -> _b * (1 - u) - u * v^2\nv_S = (x, y, t, (u, v), _d) -> -_d * v + u * v^2\nu_qp = ε₁\nv_qp = ε₂\nu_Sp = b\nv_Sp = d\nu_icf = (x, y) -> 1 - exp(-80 * (x^2 + y .^ 2))\nv_icf = (x, y) -> exp(-80 * (x .^ 2 + y .^ 2))\nu_ic = [u_icf(x, y) for (x, y) in each_point(tri)]\nv_ic = [v_icf(x, y) for (x, y) in each_point(tri)]\nu_prob = FVMProblem(mesh, u_BCs;\n    flux_function=u_q, flux_parameters=u_qp,\n    source_function=u_S, source_parameters=u_Sp,\n    initial_condition=u_ic, final_time=6000.0)\nv_prob = FVMProblem(mesh, v_BCs;\n    flux_function=v_q, flux_parameters=v_qp,\n    source_function=v_S, source_parameters=v_Sp,\n    initial_condition=v_ic, final_time=6000.0)\nprob = FVMSystem(u_prob, v_prob)","category":"page"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"Now that we have our system, we can solve.","category":"page"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"using OrdinaryDiffEq, LinearSolve\nsol = solve(prob, FBDF(linsolve=KLUFactorization()), saveat=10.0) # quite slow due to how stiff the PDE is","category":"page"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"Here is an animation of the solution, looking only at the v variable.","category":"page"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"using CairoMakie\nfig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=L\"x\", ylabel=L\"y\")\ntightlimits!(ax)\ni = Observable(1)\nu = map(i -> reshape(sol.u[i][2, :], 200, 200), i)\nx = LinRange(-1, 1, 200)\ny = LinRange(-1, 1, 200)\nheatmap!(ax, x, y, u, colorrange=(0.0, 0.4))\nhidedecorations!(ax)\nrecord(fig, joinpath(@__DIR__, \"../figures\", \"gray_scott_patterns.mp4\"), eachindex(sol);\n    framerate=60) do _i\n    i[] = _i\nend","category":"page"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"(Image: Animation of the Gray-Scott model)","category":"page"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/#Just-the-code","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Just the code","text":"","category":"section"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"An uncommented version of this example is given below.","category":"page"},{"location":"tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/","page":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"using FiniteVolumeMethod, DelaunayTriangulation\ntri = triangulate_rectangle(-1, 1, -1, 1, 200, 200, single_boundary=true)\nmesh = FVMGeometry(tri)\n\nbc = (x, y, t, (u, v), p) -> zero(u) * zero(v)\nu_BCs = BoundaryConditions(mesh, bc, Neumann)\nv_BCs = BoundaryConditions(mesh, bc, Neumann)\n\nε₁ = 0.00002\nε₂ = 0.00001\nb = 0.04\nd = 0.1\nu_q = (x, y, t, α, β, γ, _ε₁) -> (-α[1] * _ε₁, -β[1] * _ε₁)\nv_q = (x, y, t, α, β, γ, _ε₂) -> (-α[2] * _ε₂, -β[2] * _ε₂)\nu_S = (x, y, t, (u, v), _b) -> _b * (1 - u) - u * v^2\nv_S = (x, y, t, (u, v), _d) -> -_d * v + u * v^2\nu_qp = ε₁\nv_qp = ε₂\nu_Sp = b\nv_Sp = d\nu_icf = (x, y) -> 1 - exp(-80 * (x^2 + y .^ 2))\nv_icf = (x, y) -> exp(-80 * (x .^ 2 + y .^ 2))\nu_ic = [u_icf(x, y) for (x, y) in each_point(tri)]\nv_ic = [v_icf(x, y) for (x, y) in each_point(tri)]\nu_prob = FVMProblem(mesh, u_BCs;\n    flux_function=u_q, flux_parameters=u_qp,\n    source_function=u_S, source_parameters=u_Sp,\n    initial_condition=u_ic, final_time=6000.0)\nv_prob = FVMProblem(mesh, v_BCs;\n    flux_function=v_q, flux_parameters=v_qp,\n    source_function=v_S, source_parameters=v_Sp,\n    initial_condition=v_ic, final_time=6000.0)\nprob = FVMSystem(u_prob, v_prob)\n\nusing OrdinaryDiffEq, LinearSolve\nsol = solve(prob, FBDF(linsolve=KLUFactorization()), saveat=10.0) # quite slow due to how stiff the PDE is\n\nusing CairoMakie\nfig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=L\"x\", ylabel=L\"y\")\ntightlimits!(ax)\ni = Observable(1)\nu = map(i -> reshape(sol.u[i][2, :], 200, 200), i)\nx = LinRange(-1, 1, 200)\ny = LinRange(-1, 1, 200)\nheatmap!(ax, x, y, u, colorrange=(0.0, 0.4))\nhidedecorations!(ax)\nrecord(fig, joinpath(@__DIR__, \"../figures\", \"gray_scott_patterns.mp4\"), eachindex(sol);\n    framerate=60) do _i\n    i[] = _i\nend;","category":"page"},{"location":"tutorials/overview/#Section-Overview","page":"Section Overview","title":"Section Overview","text":"","category":"section"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"Pages = [\"overview.md\"]","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"We provide many tutorials in this section. Each tutorial is self-contained, although  more detail will be offered in the earlier examples. At the end of each tutorial we show the uncommented code, but if you want to see the actual script itself that generates these tutorials, then click on the Edit on GitHub section on the top right of the respective tutorial.","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"We list all the examples below, but the tutorials can be accessed in their respective sections of the sidebar.","category":"page"},{"location":"tutorials/overview/#Diffusion-Equation-on-a-Square-Plate","page":"Section Overview","title":"Diffusion Equation on a Square Plate","text":"","category":"section"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"This tutorial considers a diffusion equation problem on a square plate:","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"beginequation*\nbeginaligned\npdvu(vb x t)t = frac19grad^2 u(vb x t)   vb x in Omegat0 6pt\nu(vb x t)  =  0  vb x in partialOmegat06pt\nu(vb x 0) = f(vb x)  vb x in Omega\nendaligned\nendequation*","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"where Omega = 0 2^2 and","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"f(x y) = begincases 50  y leq 1  0  y  1 endcases","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"This problem actually has an exact solution, given by[1]","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"u(vb x t) = frac200pi^2sum_m=1^inftysum_n=1^infty fracleft1 + (-1)^m+1rightleft1-cosleft(fracnpi2right)rightmnsinleft(fracmpi x2right)sinleft(fracnpi y2right)mathrme^-frac136pi^2(m^2+n^2)t","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"although we do not refer to this in the tutorial (only in the tests).","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"[1]: See here for a derivation.","category":"page"},{"location":"tutorials/overview/#Diffusion-Equation-in-a-Wedge-with-Mixed-Boundary-Conditions","page":"Section Overview","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"","category":"section"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"This tutorial considers a similar example as in the first example, except now the diffusion is in a wedge, has mixed boundary conditions, and is also now in polar coordinates:","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"beginequation*\nbeginaligned\npdvu(r theta t)t = grad^2u(rthetat)  0r10thetaalphat06pt\npdvu(r 0 t)theta  = 0  0r1t06pt\nu(1 theta t) = 0  0thetaalphat06pt\npdvu(ralphat)theta  = 0  0thetaalphat06pt\nu(r theta 0) = f(rtheta)  0r10thetaalpha\nendaligned\nendequation*","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"where we take f(rtheta) = 1-r and alpha=pi4. This problem also has an exact solution:[2]","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"u(r theta t) = frac12sum_m=1^infty A_0 mmathrme^-zeta_0 m^2tJ_0(zeta_0 mr) + sum_n=1^inftysum_m=1^infty A_n mmathrme^-zeta_nm^2tJ_npialphaleft(zeta_npialphamrright)cosleft(fracnpithetaalpharight)","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"where","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"A_n m = frac4alpha J_npialpha+1^2left(zeta_npialphamright)int_0^1int_0^alpha f(r theta)J_npialphaleft(zeta_npialphamrright)cosleft(fracnpithetaalpharight) rddrddtheta","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"for n=012ldots and m=123ldots, and where we write the roots of J_mu, the muth order Bessel function of the first kind, as 0  zeta_mu 1  zeta_mu 2  cdots with zeta_mu m to infty as m to infty. We don't discuss this in the tutorial, but it is used in the tests.","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"[2]: To derive this, use u(r theta t) = mathrme^-lambda tv(r theta) and use separation of variables.","category":"page"},{"location":"tutorials/overview/#Reaction-Diffusion-Equation-with-a-Time-dependent-Dirichlet-Boundary-Condition-on-a-Disk","page":"Section Overview","title":"Reaction Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk","text":"","category":"section"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"This tutorial considers a reaction-diffusion problem with a mathrm dumathrm dt condition on a disk in polar coordinates:","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"beginequation*\nbeginaligned\npdvu(r theta t)t = divugrad u + u(1-u)  0r1theta2pi6pt\ndvu(1 theta t)t = u(1thetat)  0theta2pit06pt\nu(rtheta0) = sqrtI_0(sqrt2r)  0r10theta2pi\nendaligned\nendequation*","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"where I_0 is the modified Bessel function of the first kind of order zero. This problem also has an exact solution,[3]","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"u(r theta t) = mathrme^tsqrtI_0(sqrt2r)","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"that we use in the tests.","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"[3]: See Bokhari et al. (2008) for a derivation.","category":"page"},{"location":"tutorials/overview/#Porous-Medium-Equation","page":"Section Overview","title":"Porous-Medium Equation","text":"","category":"section"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"This tutorial considers the porous-medium equation, given by ","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"beginequationlabeleqporousmedium\npdvut = Ddiv u^m-1grad u\nendequation","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"with initial condition u(vb x 0) = Mdelta(vb x) where delta(vb x) is the Dirac delta function and M = iint_mathbb R^2 u(vb x t)ddA. This problem also has an exact solution that we use for defining an approximation to mathbb R^2 when solving this numerically:[4]","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"beginequationlabeleqporousmediumexact\nu(vb x t) = begincases (Dt)^-1mleftleft(fracM4piright)^(m-1)m-fracm-14mleft(x^2+y^2right)(Dt)^-1mright^1(m-1)  x^2+y^2  R_m M(Dt) \n0  x^2+y^2 geq R_m M(Dt) endcases\nendequation","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"where R_m M = 4m(m-1)M(4pi)^(m-1)m.","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"[4]: This exact solution is derived in Section 17.5 of the book The porous medium equation: Mathematical theory by J. L. Vázquez (2007).","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"We also consider a similar problem to \\eqref{eq:porousmedium}, where now the problem has a linear source:","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"pdvut = Ddiv u^m-1grad u + lambda u quad lambda  0","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"which has an exact solution given by","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"u(vb x t) = mathrme^lambda tvleft(vb x fracDlambda(m-1)leftmathrme^lambda(m-1)t-1rightright)","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"where v is the exact solution from \\eqref{eq:porousmediumexact} except with D=1.","category":"page"},{"location":"tutorials/overview/#Porous-Fisher-Equation-and-Travelling-Waves","page":"Section Overview","title":"Porous-Fisher Equation and Travelling Waves","text":"","category":"section"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"This tutorial looks at the Porous-Fisher equation,","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"beginequation*\nbeginaligned\npdvu(vb x t)t = D divugrad u + lambda u(1-u)  0xa0ybt06pt\nu(x 0 t)  =  1  0xat06pt\nu(x b t)  =  0  0xat06pt\npdvu(0 y t)x = 0  0ybt06pt\npdvu(a y t)x = 0  0  y  bt06pt\nu(vb x 0)  = f(y)  0 leq x leq a 0 leq  yleq b\nendaligned\nendequation*","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"We solve this problem and also compare it to known travelling wave solutions.","category":"page"},{"location":"tutorials/overview/#Piecewise-Linear-and-Natural-Neighbour-Interpolation-for-an-Advection-Diffusion-Equation","page":"Section Overview","title":"Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation","text":"","category":"section"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"This tutorial looks at how we can apply interpolation to solutions from the PDEs discussed, making use of NaturalNeighbours.jl for this purpose. To demonstrate this, we use a two-dimensional advection equation of the form","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"pdvut = Dpdv2ux + Dpdv2uy - nupdvux","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"defined for vb x in mathbb R^2 and u(vb x 0) = delta(vb x), where delta is the Dirac delta function, and with homogeneous  Dirichlet conditions. This problem has an exact solution, given by[5]","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"u(vb x t) = frac14Dpi texpleft(frac-(x-nu t)^2-y^24Dtright)","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"[5]: A derivation is given here.","category":"page"},{"location":"tutorials/overview/#Helmholtz-Equation-with-Inhomogeneous-Boundary-Conditions","page":"Section Overview","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"","category":"section"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"This tutorial considers the Helmholtz equation with inhomogeneous boundary conditions:","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"beginequation\nbeginaligned\ngrad^2 u(vb x) + u(vb x) = 0  vb x in -1 1^2 \npdvuvb n = 1  vb x inpartial-11^2\nendaligned\nendequation","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"This is different to the other problems considered thus far as the problem is now a steady state problem. The exact solution is","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"u(x y) = -fraccos(x+1)+cos(1-x)+cos(y+1)+cos(1-y)sin(2)","category":"page"},{"location":"tutorials/overview/#Laplace's-Equation-with-Internal-Dirichlet-Conditions","page":"Section Overview","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"","category":"section"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"This tutorial considers Laplace's equation with internal Dirichlet conditions:","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"beginequation\nbeginaligned\ngrad^2 u = 0  vb x in 0 1^2  \nu(0 y) = 100y  0 leq y leq 1 \nu(1 y) = 100y  0 leq y leq 1 \nu(x 0) = 0  0 leq x leq 1 \nu(x 1) = 100  0 leq x leq 1 \nu(12 y) = 0  0 leq y leq 25\nendaligned\nendequation","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"This last condition u(12 y) = 0 is the internal condition that needs to be dealt with.","category":"page"},{"location":"tutorials/overview/#Equilibrium-Temperature-Distribution-with-Mixed-Boundary-Conditions-and-using-EnsembleProblems","page":"Section Overview","title":"Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems","text":"","category":"section"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"This tutorial considers the equilibrium temperature distribution in a square plate with mixed boundary conditions:","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"beginequation\nbeginaligned\ngrad^2 T = 0  vb x in Omega \ngrad T vdot vu n = 0  vb x in Gamma_1 \nT = 40  vb x in Gamma_2 \nkgrad T vdot vu n = h(T_infty - T)  vb x in Gamma_3 \nT = 70  vb x in Gamma_4 \nendaligned\nendequation","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"This domain Omega with boundary partialOmega=Gamma_1cupGamma_2cupGamma_3cupGamma_4 is shown below. For this tutorial, we also consider how varying T_infty affects the results, using interpolation and EnsembleProblems to study this efficiently.","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"using CairoMakie\nA = (0.0, 0.06)\nB = (0.03, 0.06)\nF = (0.03, 0.05)\nG = (0.05, 0.03)\nC = (0.06, 0.03)\nD = (0.06, 0.0)\nE = (0.0, 0.0)\nfig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=\"x\", ylabel=\"y\")\nlines!(ax, [A, E, D], color=:red, linewidth=5)\nlines!(ax, [B, F, G, C], color=:blue, linewidth=5)\nlines!(ax, [C, D], color=:black, linewidth=5)\nlines!(ax, [A, B], color=:magenta, linewidth=5)\ntext!(ax, [(0.03, 0.001)], text=L\"\\Gamma_1\", fontsize=44)\ntext!(ax, [(0.055, 0.01)], text=L\"\\Gamma_2\", fontsize=44)\ntext!(ax, [(0.04, 0.04)], text=L\"\\Gamma_3\", fontsize=44)\ntext!(ax, [(0.015, 0.053)], text=L\"\\Gamma_4\", fontsize=44)\ntext!(ax, [(0.001, 0.03)], text=L\"\\Gamma_1\", fontsize=44)","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"fig #hide","category":"page"},{"location":"tutorials/overview/#A-Reaction-Diffusion-Brusselator-System-of-PDEs","page":"Section Overview","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"","category":"section"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"In this tutorial we consider the following system:","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"beginequation\nbeginaligned\npdvPhit = frac14grad^2 Phi + Phi^2Psi - 2Phi \npdvPsit = frac14grad^2 Psi - Phi^2Psi + Phi\nendaligned quad vb x in 0 1^2\nendequation","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"which has a solution[6]","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"beginequationlabeleqbrusleexct\nbeginaligned\nPhi(x y t) =exp(-x-y-t2) \nPsi(x y t) = exp(x+y+t2)\nendaligned\nendequation","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"We use this exact solution to define the initial condition and Neumann boundary conditions.","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"[6]: See Islam, Ali, and Haq (2010).","category":"page"},{"location":"tutorials/overview/#Gray-Scott-Model:-Turing-Patterns-from-a-Coupled-Reaction-Diffusion-System","page":"Section Overview","title":"Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System","text":"","category":"section"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"In this tutorial we consider the Gray-Scott model, given by","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"beginequation\nbeginaligned\npdvut = varepsilon_1grad^2u+b(1-u)-uv^2 \npdvvt = varepsilon_2grad^2 v - dv+uv^2\nendaligned\nendequation","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"with zero flux boundary conditions. We use this example to explore how changing parameters slightly leads to some amazing patterns, known as Turing patterns.[7]","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"[7]: There are many papers discussing this. See, e.g., Gandy and Nelson (2022) for a recent paper. The parameter values we use come from this Chebfun example.","category":"page"},{"location":"tutorials/overview/#Diffusion-Equation-on-an-Annulus","page":"Section Overview","title":"Diffusion Equation on an Annulus","text":"","category":"section"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"In this tutorial we consider the diffusion equation on an annulus:[8]","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"beginequation\nbeginaligned\npdvu(vb x t)t = grad^2 u(vb x t)  vb x in Omega \ngrad u(vb x t) vdot vu n(vb x) = 0  vb x in mathcal D(0 1) \nu(vb x t) = c(t)  vb x in mathcal D(002) \nu(vb x t) = u_0(vb x)\nendaligned\nendequation","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"demonstrating how we can solve PDEs over multiply-connected domains. Here, mathcal D(0 r) is a circle of radius r centred at the origin,  Omega is the annulus between mathcal D(002) and mathcal D(0 1), c(t) = 501-mathrme^-t2, and ","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"u_0(x) = 10mathrme^-25leftleft(x+frac12right)^2+left(y+frac12right)^2right - 10mathrme^-45leftleft(x-frac12right)^2+left(y-frac12right)^2right - 5mathrme^-50leftleft(x+frac310right)^2+left(y+frac12right)^2right","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"We also use this tutorial as an opportunity to give an example of  performing natural neighbour interpolation on a multiply-connected domain.","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"[8]: This example comes from here.","category":"page"},{"location":"tutorials/overview/#Mean-Exit-Time","page":"Section Overview","title":"Mean Exit Time","text":"","category":"section"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"In this tutorial, we consider mean time problems. The main problem we consider is that of mean exit time on a compound disk:[9]","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"beginequation\nbeginaligned\nD_1grad^2 T^(1)(vb x) = -1  0  r  mathcal R_1(theta) \nD_2grad^2 T^(2)(vb x) = -1  mathcal R_1(theta)  r  R_2(theta) \nT^(1)(mathcal R_1(theta)theta) = T^(2)(mathcal R_1(theta)theta) \nD_1grad T^(1)(mathcal R_1(theta) theta) vdot vu n(theta) = D_2grad T^(2)(mathcal R_1(theta) theta) vdot vu n(theta) \nT^(2)(R_2 theta) = 0 \nendaligned\nendequation","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"with a perturbed interface mathcal R_1(theta) = R_1(1+varepsilon g(theta)), g(theta)=sin(3theta)+cos(5theta). The conditions at the interface are needed to enforce continuity. The variable T^(1) is the mean exit time in 0  r  mathcal R_1(theta), and T^(2) is the mean exit time in mathcal R_1(theta)  r  R_2(theta). The end of this tutorial also considers mean exit time with obstacles and internal conditions.","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"[9]: This problem comes from Carr et al. (2022).","category":"page"},{"location":"tutorials/overview/#Solving-Mazes-with-Laplace's-Equation","page":"Section Overview","title":"Solving Mazes with Laplace's Equation","text":"","category":"section"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"In this tutorial, we consider solving mazes using Laplace's equation, applying the result of Conolly, Burns, and Weis (1990). In particular, given a maze mathcal M, represented as a collection of edges together with some starting point mathcal S_1 and an endpoint mathcal S_2, Laplace's equation can be used to find the solution:","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"beginequation\nbeginaligned\ngrad^2 phi = 0  vb x in mathcal M \nphi = 0  vb x in mathcal S_1 \nphi = 1  vb x in mathcal S_2 \ngradphivdotvu n = 0  vb x in partial M setminus (mathcal S_1 cup mathcal S_2)\nendaligned\nendequation","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"The solution can then be found by looking at the potential gradphi.","category":"page"},{"location":"tutorials/overview/#Keller-Segel-Model-of-Chemotaxis","page":"Section Overview","title":"Keller-Segel Model of Chemotaxis","text":"","category":"section"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"In this tutorial, we consider the following Keller-Segel model of chemotaxis:[10]","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"beginequation*\nbeginaligned\npdvut = grad^2u - div left(fraccu1+u^2grad vright) + u(1-u) \npdvvt = Dgrad^2 v + u - av\nendaligned\nendequation*","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"inside the square 0 100^2 with homogeneous Neumann boundary conditions.","category":"page"},{"location":"tutorials/overview/","page":"Section Overview","title":"Section Overview","text":"[10]: This example comes from VisualPDE.","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"EditURL = \"https://github.com/DanielVandH/FiniteVolumeMethod.jl/tree/main/docs/src/literate_tutorials/porous_medium_equation.jl\"","category":"page"},{"location":"tutorials/porous_medium_equation/#Porous-Medium-Equation","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"","category":"section"},{"location":"tutorials/porous_medium_equation/#No-source","page":"Porous-Medium Equation","title":"No source","text":"","category":"section"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"In this tutorial, we consider the porous-medium equation, given by","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"pdvut = Ddivu^m-1grad u","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"with initial condition u(vb x 0) = Mdelta(vb x) where delta(vb x) is the Dirac delta function and M = iint_mathbb R^2 u(vb x t) ddA. The diffusion function for this problem is D(vb x t u) = Du^m-1. To approximate delta(vb x), we use","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"delta(vb x) approx g(vb x) = frac1varepsilon^2piexpleft-frac1varepsilon^2left(x^2 + y^2right)right","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"taking varepsilon = 01. It can be shown[1] that u(vb x t) is zero for x^2 + y^2 geq R_m M(Dt)^1m, where","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"R_m M = left(frac4mm-1right)leftfracM4piright^(m-1)m","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"so we can replace the domain mathbb R^2 with the domain Omega = -L L^2 where L = R_m M^12(DT)^12m and T is the time that we solve up. We use a Dirichlet boundary condition on partialOmega.","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"[1]: This comes from the exact solution that we define in the overview.","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"Let us now solve this problem, taking m = 2, M = 037, D = 253, and T = 12.","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"using DelaunayTriangulation, FiniteVolumeMethod\n\n# Step 0: Define all the parameters\nm = 2\nM = 0.37\nD = 2.53\nfinal_time = 12.0\nε = 0.1\n# Step 1: Define the mesh\nRmM = 4m / (m - 1) * (M / (4π))^((m - 1) / m)\nL = sqrt(RmM) * (D * final_time)^(1 / (2m))\ntri = triangulate_rectangle(-L, L, -L, L, 125, 125, single_boundary=true)\nmesh = FVMGeometry(tri)","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"# Step 2: Define the boundary conditions\nBCs = BoundaryConditions(mesh, (x, y, t, u, p) -> zero(u), Dirichlet)","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"# Step 3: Define the actual PDE\nf = (x, y) -> M * 1 / (ε^2 * π) * exp(-1 / (ε^2) * (x^2 + y^2))\ndiffusion_function = (x, y, t, u, p) -> p[1] * u^(p[2] - 1)\ndiffusion_parameters = (D, m)\ninitial_condition = [f(x, y) for (x, y) in each_point(tri)]\nprob = FVMProblem(mesh, BCs;\n    diffusion_function,\n    diffusion_parameters,\n    initial_condition,\n    final_time)","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"# Step 4: Solve\nusing LinearSolve, OrdinaryDiffEq\nsol = solve(prob, TRBDF2(linsolve=KLUFactorization()); saveat=3.0)","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"# Step 5: Visualise\nusing CairoMakie\nfig = Figure(fontsize=38)\nfor (i, j) in zip(1:3, (1, 3, 5))\n    ax = Axis(fig[1, i], width=600, height=600,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[j])\",\n        titlealign=:left)\n    tricontourf!(ax, tri, sol.u[j], levels=0:0.005:0.05, colormap=:matter, extendhigh=:auto)\n    tightlimits!(ax)\nend\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/porous_medium_equation/#Linear-source","page":"Porous-Medium Equation","title":"Linear source","text":"","category":"section"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"Let us now extend the problem above so that a linear source is now included:","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"pdvut = Ddiv u^m-1grad u + lambda u quad lambda  0","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"We again let the initial condition be u(vb x 0) = Mdelta(vb x). For the domain, we use","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"Omega = left-R_m M^12tau(T)^12m R_mM^12tau(T)^12mright^2","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"where","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"tau(T) = fracDlambda(m-1)leftmathrme^lambda(m-1)T-1right","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"The code below solves this problem.","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"# Step 0: Define all the parameters\nm = 3.4\nM = 2.3\nD = 0.581\nλ = 0.2\nfinal_time = 10.0\nε = 0.1\n# Step 1: Define the mesh\nRmM = 4m / (m - 1) * (M / (4π))^((m - 1) / m)\nL = sqrt(RmM) * (D / (λ * (m - 1)) * (exp(λ * (m - 1) * final_time) - 1))^(1 / (2m))\ntri = triangulate_rectangle(-L, L, -L, L, 125, 125, single_boundary=true)\nmesh = FVMGeometry(tri)","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"# Step 2: Define the boundary conditions\nbc = (x, y, t, u, p) -> zero(u)\ntype = Dirichlet\nBCs = BoundaryConditions(mesh, bc, type)","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"# Step 3: Define the actual PDE\nf = (x, y) -> M * 1 / (ε^2 * π) * exp(-1 / (ε^2) * (x^2 + y^2))\ndiffusion_function = (x, y, t, u, p) -> p.D * abs(u)^(p.m - 1)\nsource_function = (x, y, t, u, λ) -> λ * u\ndiffusion_parameters = (D=D, m=m)\nsource_parameters = λ\ninitial_condition = [f(x, y) for (x, y) in each_point(tri)]\nprob = FVMProblem(mesh, BCs;\n    diffusion_function,\n    diffusion_parameters,\n    source_function,\n    source_parameters,\n    initial_condition,\n    final_time)","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"# Step 4: Solve\nsol = solve(prob, TRBDF2(linsolve=KLUFactorization()); saveat=2.5)","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"# Step 5: Visualise\nfig = Figure(fontsize=38)\nfor (i, j) in zip(1:3, (1, 3, 5))\n    ax = Axis(fig[1, i], width=600, height=600,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[j])\",\n        titlealign=:left)\n    tricontourf!(ax, tri, sol.u[j], levels=0:0.05:1, extendlow=:auto, colormap=:matter, extendhigh=:auto)\n    tightlimits!(ax)\nend\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/porous_medium_equation/#Just-the-code","page":"Porous-Medium Equation","title":"Just the code","text":"","category":"section"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"using DelaunayTriangulation, FiniteVolumeMethod\n\n# Step 0: Define all the parameters\nm = 2\nM = 0.37\nD = 2.53\nfinal_time = 12.0\nε = 0.1\n# Step 1: Define the mesh\nRmM = 4m / (m - 1) * (M / (4π))^((m - 1) / m)\nL = sqrt(RmM) * (D * final_time)^(1 / (2m))\ntri = triangulate_rectangle(-L, L, -L, L, 125, 125, single_boundary=true)\nmesh = FVMGeometry(tri)\n\n# Step 2: Define the boundary conditions\nBCs = BoundaryConditions(mesh, (x, y, t, u, p) -> zero(u), Dirichlet)\n\n# Step 3: Define the actual PDE\nf = (x, y) -> M * 1 / (ε^2 * π) * exp(-1 / (ε^2) * (x^2 + y^2))\ndiffusion_function = (x, y, t, u, p) -> p[1] * u^(p[2] - 1)\ndiffusion_parameters = (D, m)\ninitial_condition = [f(x, y) for (x, y) in each_point(tri)]\nprob = FVMProblem(mesh, BCs;\n    diffusion_function,\n    diffusion_parameters,\n    initial_condition,\n    final_time)\n\n# Step 4: Solve\nusing LinearSolve, OrdinaryDiffEq\nsol = solve(prob, TRBDF2(linsolve=KLUFactorization()); saveat=3.0)\n\n# Step 5: Visualise\nusing CairoMakie\nfig = Figure(fontsize=38)\nfor (i, j) in zip(1:3, (1, 3, 5))\n    ax = Axis(fig[1, i], width=600, height=600,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[j])\",\n        titlealign=:left)\n    tricontourf!(ax, tri, sol.u[j], levels=0:0.005:0.05, colormap=:matter, extendhigh=:auto)\n    tightlimits!(ax)\nend\nresize_to_layout!(fig)\nfig\n\n# Step 0: Define all the parameters\nm = 3.4\nM = 2.3\nD = 0.581\nλ = 0.2\nfinal_time = 10.0\nε = 0.1\n# Step 1: Define the mesh\nRmM = 4m / (m - 1) * (M / (4π))^((m - 1) / m)\nL = sqrt(RmM) * (D / (λ * (m - 1)) * (exp(λ * (m - 1) * final_time) - 1))^(1 / (2m))\ntri = triangulate_rectangle(-L, L, -L, L, 125, 125, single_boundary=true)\nmesh = FVMGeometry(tri)\n\n# Step 2: Define the boundary conditions\nbc = (x, y, t, u, p) -> zero(u)\ntype = Dirichlet\nBCs = BoundaryConditions(mesh, bc, type)\n\n# Step 3: Define the actual PDE\nf = (x, y) -> M * 1 / (ε^2 * π) * exp(-1 / (ε^2) * (x^2 + y^2))\ndiffusion_function = (x, y, t, u, p) -> p.D * abs(u)^(p.m - 1)\nsource_function = (x, y, t, u, λ) -> λ * u\ndiffusion_parameters = (D=D, m=m)\nsource_parameters = λ\ninitial_condition = [f(x, y) for (x, y) in each_point(tri)]\nprob = FVMProblem(mesh, BCs;\n    diffusion_function,\n    diffusion_parameters,\n    source_function,\n    source_parameters,\n    initial_condition,\n    final_time)\n\n# Step 4: Solve\nsol = solve(prob, TRBDF2(linsolve=KLUFactorization()); saveat=2.5)\n\n# Step 5: Visualise\nfig = Figure(fontsize=38)\nfor (i, j) in zip(1:3, (1, 3, 5))\n    ax = Axis(fig[1, i], width=600, height=600,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[j])\",\n        titlealign=:left)\n    tricontourf!(ax, tri, sol.u[j], levels=0:0.05:1, extendlow=:auto, colormap=:matter, extendhigh=:auto)\n    tightlimits!(ax)\nend\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"","category":"page"},{"location":"tutorials/porous_medium_equation/","page":"Porous-Medium Equation","title":"Porous-Medium Equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"EditURL = \"https://github.com/DanielVandH/FiniteVolumeMethod.jl/tree/main/docs/src/literate_tutorials/porous_fisher_equation_and_travelling_waves.jl\"","category":"page"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/#Porous-Fisher-Equation-and-Travelling-Waves","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"","category":"section"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"This tutorial considers a more involved example, where we discuss travelling wave solutions of a Porous-Fisher equation:","category":"page"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"beginequation*\nbeginaligned\npdvu(vb x t)t = D divugrad u + lambda u(1-u)  0xa0ybt06pt\nu(x 0 t)  =  1  0xat06pt\nu(x b t)  =  0  0xat06pt\npdvu(0 y t)x = 0  0ybt06pt\npdvu(a y t)x = 0  0  y  bt06pt\nu(vb x 0)  = f(y)  0 leq x leq a 0 leq  yleq b\nendaligned\nendequation*","category":"page"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"This problem is defined on the rectangle 0 a times 0 b and we assume that b gg a so that the rectangle is much taller than it is wide. This problem has u ranging from u=1 at the bottom of the rectangle down to u=0 at the top on the rectangle, and with zero flux conditions on the two vertical walls. We take the initial condition f to be independent of x. This setup implies that the solution along each constant line x=x_0 should be about the same, i.e. the problem is invariant in x. If indeed we have u(vb x t) = u(y t) then the PDE becomes","category":"page"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"beginequationlabeleqonedproblem\npdvu(y t)t = Dpdvyleft(updvuyright) + lambda u(1-u)\nendequation","category":"page"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"which has travelling wave solutions. Following the analysis given in Section 13.4 of the book Mathematical biology I: An introduction by J. D. Murray (2002), we can show that a travelling wave solution to the one-dimensional problem \\eqref{eq:onedproblem} is given by","category":"page"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"beginequationlabeleqonedproblemexact\nu(y t) = begincases 1-mathrme^c_minz  z leq 0  0  z  0 endcases\nendequation","category":"page"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"where c_min = sqrtlambda(2D), c = sqrtDlambda2, and z = x-ct is the travelling wave coordinates. This travelling wave would mathc our problem exactly if the rectangle were instead 0 a times mathbb R, but by choosing b large enough we can at least emulate the travelling wave behaviour closely; the homogeneous Neumann conditions are to ensure no energy is lost, thus allowing the travelling waves to exist. Moreover, note that the approximations of the solution with u(y t) in \\eqref{eq:onedproblemexact} will only be accurate for large time as it takes the solution some time to evolve towards the travelling wave solution.","category":"page"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"Now with this preamble out of the way, let us solve this problem.","category":"page"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"using DelaunayTriangulation, FiniteVolumeMethod, OrdinaryDiffEq, LinearSolve\na, b, c, d, nx, ny = 0.0, 3.0, 0.0, 40.0, 60, 80\ntri = triangulate_rectangle(a, b, c, d, nx, ny; single_boundary=false)\nmesh = FVMGeometry(tri)\none_bc = (x, y, t, u, p) -> one(u)\nzero_bc = (x, y, t, u, p) -> zero(u)\nbc_fncs = (one_bc, zero_bc, zero_bc, zero_bc) # bottom, right, top, left\ntypes = (Dirichlet, Neumann, Dirichlet, Neumann)\nBCs = BoundaryConditions(mesh, bc_fncs, types)\nf = (x, y) -> zero(y)\ndiffusion_function = (x, y, t, u, D) -> D * u\nsource_function = (x, y, t, u, λ) -> λ * u * (1 - u)\nD, λ = 0.9, 0.99\ndiffusion_parameters = D\nsource_parameters = λ\nfinal_time = 50.0\ninitial_condition = [f(x, y) for (x, y) in each_point(tri)]\nprob = FVMProblem(mesh, BCs;\n    diffusion_function, diffusion_parameters,\n    source_function, source_parameters,\n    initial_condition, final_time)\nsol = solve(prob, TRBDF2(linsolve=KLUFactorization()); saveat=0.5)","category":"page"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"Let us now look at the travelling wave behaviour. We will plot the evolution over time, and also the travelling wave view of the solution. First, let us get these travelling wave values.","category":"page"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"large_time_idx = findfirst(≥(10.0), sol.t)\nc = sqrt(λ / (2D))\ncₘᵢₙ = sqrt(λ * D / 2)\nzᶜ = 0.0\nexact_solution(z) = ifelse(z ≤ zᶜ, 1 - exp(cₘᵢₙ * z), zero(z))\ntravelling_wave_values = zeros(ny, length(sol) - large_time_idx + 1)\nz_vals = zero(travelling_wave_values)\nu_mat = [reshape(u, (nx, ny)) for u in sol.u]\nfor (i, t_idx) in pairs(large_time_idx:lastindex(sol))\n    u = u_mat[t_idx]\n    τ = sol.t[t_idx]\n    for k in 1:ny\n        y = c + (k - 1) * (d - c) / (ny - 1)\n        z = y - c * τ\n        z_vals[k, i] = z\n        travelling_wave_values[k, i] = u[nx÷2, k]\n    end\nend","category":"page"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"Now we are in a position to plot.","category":"page"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"using CairoMakie\nfig = Figure(resolution=(3200.72f0, 800.64f0), fontsize=38)\nfor (i, j) in zip(1:3, (1, 51, 101))\n    ax = Axis(fig[1, i], width=600, height=600,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[j])\",\n        titlealign=:left)\n    tricontourf!(ax, tri, sol.u[j], levels=0:0.05:1, colormap=:matter)\n    tightlimits!(ax)\nend\nax = Axis(fig[1, 4], width=900, height=600)\ncolors = cgrad(:matter, length(sol) - large_time_idx + 1; categorical=false)\n[lines!(ax, z_vals[:, i], travelling_wave_values[:, i], color=colors[i], linewidth=2) for i in 1:(length(sol)-large_time_idx+1)]\nexact_z_vals = collect(LinRange(extrema(z_vals)..., 500))\nexact_travelling_wave_values = exact_solution.(exact_z_vals)\nlines!(ax, exact_z_vals, exact_travelling_wave_values, color=:red, linewidth=4, linestyle=:dash)\nfig","category":"page"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/#Just-the-code","page":"Porous-Fisher Equation and Travelling Waves","title":"Just the code","text":"","category":"section"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"using DelaunayTriangulation, FiniteVolumeMethod, OrdinaryDiffEq, LinearSolve\na, b, c, d, nx, ny = 0.0, 3.0, 0.0, 40.0, 60, 80\ntri = triangulate_rectangle(a, b, c, d, nx, ny; single_boundary=false)\nmesh = FVMGeometry(tri)\none_bc = (x, y, t, u, p) -> one(u)\nzero_bc = (x, y, t, u, p) -> zero(u)\nbc_fncs = (one_bc, zero_bc, zero_bc, zero_bc) # bottom, right, top, left\ntypes = (Dirichlet, Neumann, Dirichlet, Neumann)\nBCs = BoundaryConditions(mesh, bc_fncs, types)\nf = (x, y) -> zero(y)\ndiffusion_function = (x, y, t, u, D) -> D * u\nsource_function = (x, y, t, u, λ) -> λ * u * (1 - u)\nD, λ = 0.9, 0.99\ndiffusion_parameters = D\nsource_parameters = λ\nfinal_time = 50.0\ninitial_condition = [f(x, y) for (x, y) in each_point(tri)]\nprob = FVMProblem(mesh, BCs;\n    diffusion_function, diffusion_parameters,\n    source_function, source_parameters,\n    initial_condition, final_time)\nsol = solve(prob, TRBDF2(linsolve=KLUFactorization()); saveat=0.5)\n\nlarge_time_idx = findfirst(≥(10.0), sol.t)\nc = sqrt(λ / (2D))\ncₘᵢₙ = sqrt(λ * D / 2)\nzᶜ = 0.0\nexact_solution(z) = ifelse(z ≤ zᶜ, 1 - exp(cₘᵢₙ * z), zero(z))\ntravelling_wave_values = zeros(ny, length(sol) - large_time_idx + 1)\nz_vals = zero(travelling_wave_values)\nu_mat = [reshape(u, (nx, ny)) for u in sol.u]\nfor (i, t_idx) in pairs(large_time_idx:lastindex(sol))\n    u = u_mat[t_idx]\n    τ = sol.t[t_idx]\n    for k in 1:ny\n        y = c + (k - 1) * (d - c) / (ny - 1)\n        z = y - c * τ\n        z_vals[k, i] = z\n        travelling_wave_values[k, i] = u[nx÷2, k]\n    end\nend\n\nusing CairoMakie\nfig = Figure(resolution=(3200.72f0, 800.64f0), fontsize=38)\nfor (i, j) in zip(1:3, (1, 51, 101))\n    ax = Axis(fig[1, i], width=600, height=600,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[j])\",\n        titlealign=:left)\n    tricontourf!(ax, tri, sol.u[j], levels=0:0.05:1, colormap=:matter)\n    tightlimits!(ax)\nend\nax = Axis(fig[1, 4], width=900, height=600)\ncolors = cgrad(:matter, length(sol) - large_time_idx + 1; categorical=false)\n[lines!(ax, z_vals[:, i], travelling_wave_values[:, i], color=colors[i], linewidth=2) for i in 1:(length(sol)-large_time_idx+1)]\nexact_z_vals = collect(LinRange(extrema(z_vals)..., 500))\nexact_travelling_wave_values = exact_solution.(exact_z_vals)\nlines!(ax, exact_z_vals, exact_travelling_wave_values, color=:red, linewidth=4, linestyle=:dash)\nfig","category":"page"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"","category":"page"},{"location":"tutorials/porous_fisher_equation_and_travelling_waves/","page":"Porous-Fisher Equation and Travelling Waves","title":"Porous-Fisher Equation and Travelling Waves","text":"This page was generated using Literate.jl.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"CurrentModule = FiniteVolumeMethod","category":"page"},{"location":"interface/#Interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Pages = [\"interface.md\"]","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"In this section, we describe the basic interface for defining and solving PDEs using this package. This interface will also be made clearer in the tutorials. The basic summary of the discussion below is as follows:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Use FVMGeometry to define the problem's mesh.\nProvide boundary conditions using BoundaryConditions.\n(Optional) Provide internal conditions using InternalConditions.\nConvert the problem into an FVMProblem.\nIf you want to make the problem steady, use SteadyFVMProblem on the FVMProblem.\nIf you want a system of equations, construct an FVMSystem from multiple FVMProblems; if you want this problem to be steady, skip step 5 and only now apply SteadyFVMProblem.\nSolve the problem using solve.\nFor a discussion of custom constraints, see the tutorials.\nFor interpolation, we provide pl_interpolate (but you might prefer NaturalNeighbours.jl - see this tutorial for an example).","category":"page"},{"location":"interface/#FVMGeometry:-Defining-the-mesh","page":"Interface","title":"FVMGeometry: Defining the mesh","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"The finite volume method (FVM) requires an underlying triangular mesh, as outlined in the mathematical details section. This triangular mesh is to be defined from DelaunayTriangulation.jl. The FVMGeometry type wraps the resulting Triangulation and computes information about the geometry required for solving the PDEs. The docstring for FVMGeometry is below; the fields of FVMGeometry are public API. ","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"FVMGeometry","category":"page"},{"location":"interface/#FiniteVolumeMethod.FVMGeometry","page":"Interface","title":"FiniteVolumeMethod.FVMGeometry","text":"FVMGeometry(tri::Triangulation)\n\nThis is a constructor for the FVMGeometry struct, which holds the mesh and associated data for the PDE.\n\nnote: Note\nIt is assumed that all vertices in tri are in the triangulation, meaning v is in tri for each v in each_point_index(tri).\n\nFields\n\ntriangulation: The underlying Triangulation from DelaunayTriangulation.jl.\ntriangulation_statistics: The statistics of the triangulation. \ncv_volumes::Vector{Float64}: A Vector of the volumes of each control volume.\ntriangle_props::Dict{NTuple{3,Int},TriangleProperties}: A Dict mapping the indices of each triangle to its [TriangleProperties].\n\n\n\n\n\n","category":"type"},{"location":"interface/","page":"Interface","title":"Interface","text":"The FVMGeometry struct uses TriangleProperties for storing properties of a control volume that intersects a given triangle, defined below. This struct is  public API, although it is unlikely you would ever need it. ","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"TriangleProperties","category":"page"},{"location":"interface/#FiniteVolumeMethod.TriangleProperties","page":"Interface","title":"FiniteVolumeMethod.TriangleProperties","text":"TriangleProperties(shape_function_coefficients, cv_edge_midpoints, cv_edge_normals, cv_edge_lengths)\n\nThis is a struct for holding the properties of a control volume's intersection with a triangle.\n\nFields\n\nshape_function_coefficients::NTuple{9,Float64}: The shape function coefficients for the triangle.\ncv_edge_midpoints::NTuple{3,NTuple{2,Float64}}: The midpoints of the control volume edges. If the triangle is (i, j, k), then the edges are given in the order (i, j), (j, k), and (k, i), where 'edge' refers to the edge joining e.g. the midpoint of the edge (i, j) to the centroid of the triangle. \ncv_edge_normals::NTuple{3,NTuple{2,Float64}}: The normal vectors to the control volume edges, in the same order as in cv_edge_midpoints.\ncv_edge_lengths::NTuple{3,Float64}: The lengths of the control volume edges, in the same order as in cv_edge_midpoints.\n\n\n\n\n\n","category":"type"},{"location":"interface/#BoundaryConditions:-Defining-boundary-conditions","page":"Interface","title":"BoundaryConditions: Defining boundary conditions","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Once a mesh is defined, you need to associate each part of the boundary with a set of boundary nodes. Since you have a Triangulation, the boundary of the mesh already meets the necessary assumptions made by this package about the boundary; these assumptions are simply that they match the specification of a boundary here in DelaunayTriangulation.jl's docs (for example, the boundary points connect, the boundary is positively oriented, etc.).","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"You can specify boundary condtiions using BoundaryConditions, whose docstring is below; the fields of BoundaryConditions are not public API, only this wrapper is.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"BoundaryConditions","category":"page"},{"location":"interface/#FiniteVolumeMethod.BoundaryConditions","page":"Interface","title":"FiniteVolumeMethod.BoundaryConditions","text":"BoundaryConditions(mesh::FVMGeometry, functions, conditions; parameters=nothing)\n\nThis is a constructor for the BoundaryConditions struct, which holds the boundary conditions for the PDE.  See also Conditions (which FVMProblem wraps this into), ConditionType, and InternalConditions.\n\nArguments\n\nmesh::FVMGeometry\n\nThe mesh on which the PDE is defined.\n\nfunctions::Union{<:Tuple,<:Function}\n\nThe functions that define the boundary conditions. The ith function should correspond to the part of the boundary of  the mesh corresponding to the ith boundary index, as defined in DelaunayTriangulation.jl. \n\nconditions::Union{<:Tuple,<:ConditionType}\n\nThe classification for the boundary condition type corresponding to each boundary index as above. See  ConditionType for possible conditions - should be one of Neumann, Dudt, Dirichlet, or Constrained.\n\nKeyword Arguments\n\nparameters=ntuple(_ -> nothing, length(functions))\n\nThe parameters for the functions, with parameters[i] giving the argument p in functions[i].\n\nOutputs\n\nThe returned value is the corresponding BoundaryConditions struct.\n\n\n\n\n\n","category":"type"},{"location":"interface/","page":"Interface","title":"Interface","text":"There are four types of boundary conditions: Neumann, Dudt, Dirichlet, and Constrained. These types are defined below.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"ConditionType \nNeumann \nDudt\nDirichlet \nConstrained","category":"page"},{"location":"interface/#FiniteVolumeMethod.ConditionType","page":"Interface","title":"FiniteVolumeMethod.ConditionType","text":"ConditionType\n\nThis is an Enum-type, with four instances:\n\nNeumann\nDudt\nDirichlet\nConstrained\n\nThis is used for declaring conditions in the PDEs. See  the associated docstrings, and also BoundaryConditions and InternalConditions.\n\n\n\n\n\n","category":"type"},{"location":"interface/#FiniteVolumeMethod.Neumann","page":"Interface","title":"FiniteVolumeMethod.Neumann","text":"Neumann\n\nInstance of a ConditionType used for declaring that an edge  has a Neumann condition. Neumann conditions  take the form \n\nvb q(x y t) vdot vu n_sigma = a(x y t u)\n\nwhere vb q is the flux function and vu n_sigma is the  outward unit normal vector field on the associated edge (meaning, for example,  the normal vector to an edge pq would point to the right of pq).\n\nWhen providing a Neumann condition, the function you provide  takes the form\n\na(x, y, t, u, p)\n\nwhere (x, y) is the point, t is the current time, and u is the  solution at the point (x, y) at time t, as above, with an extra  argument p for additional parameters. \n\n\n\n\n\n","category":"constant"},{"location":"interface/#FiniteVolumeMethod.Dudt","page":"Interface","title":"FiniteVolumeMethod.Dudt","text":"Dudt\n\nInstance of a ConditionType used for declaring that an edge,  or a point, has a Dudt-type boundary condition. Dudt-type  conditions take the form\n\ndvu(x y t)t = a(x y t u)\n\nWhen providing a Dudt condition, the function you provide takes the form\n\na(x, y, t, u, p)\n\nwhere (x, y) is the point, t is the current time, and u is the solution at the point (x, y) at time t, as above, with an extra  argument p for additional parameters.\n\n\n\n\n\n","category":"constant"},{"location":"interface/#FiniteVolumeMethod.Dirichlet","page":"Interface","title":"FiniteVolumeMethod.Dirichlet","text":"Dirichlet\n\nInstance of a ConditionType used for declaring that an edge, or a point, has a Dirichlet boundary condition. Dirichlet conditions take the form\n\nu(x y t) = a(x y t u)\n\nWhen providing a Dirichlet condition, the function you provide takes the form\n\na(x, y, t, u, p)\n\nwhere (x, y) is the point, t is the current time, and u is the solution at the point (x, y) at time t, as above, with an extra  argument p for additional parameters.\n\n\n\n\n\n","category":"constant"},{"location":"interface/#FiniteVolumeMethod.Constrained","page":"Interface","title":"FiniteVolumeMethod.Constrained","text":"Constrained\n\nInstance of a ConditionType used for declaring that an edge has a Constrained condition. When an edge has this condition associated with it,  it will be treated as any normal edge and no boundary condition will be applied. With this condition, it is assumed that you will later setup your problem as a  differential-algebraic equation (DAE) and provide the appropriate constraints. See the docs for some examples.\n\nWhen you provide a Constrained condition, for certain technical reasons  you do still need to provide a function that corresponds to it in the function list  provided to BoundaryConditions. For this function, any function will work,  e.g. sin - it will not be called. The proper constraint function is to be provided after-the-fact,  as explained in the docs.\n\n\n\n\n\n","category":"constant"},{"location":"interface/#InternalConditions:-Defining-internal-conditions","page":"Interface","title":"InternalConditions: Defining internal conditions","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"If you like, you can also put some constraints for nodes away from the boundary. In this case, only Dudt and Dirichlet conditions can be imposed; for Neumann or Constrained conditions, you need to consider differential-algebraic problems as considered in the tutorials. The docstring for InternalConditions is below; the fields of InternalConditions are not public API, only this wrapper is.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"InternalConditions","category":"page"},{"location":"interface/#FiniteVolumeMethod.InternalConditions","page":"Interface","title":"FiniteVolumeMethod.InternalConditions","text":"InternalConditions(functions=();\n    dirichlet_nodes::Dict{Int,Int}=Dict{Int,Int}(),\n    dudt_nodes::Dict{Int,Int}=Dict{Int,Int}(),\n    parameters::Tuple=ntuple(_ -> nothing, length(functions)))\n\nThis is a constructor for the InternalConditions struct, which holds the internal conditions for the PDE. See also Conditions (which FVMProblem wraps this into), ConditionType, and BoundaryConditions.\n\nArguments\n\nfunctions::Union{<:Tuple,<:Function}=()\n\nThe functions that define the internal conditions. These are the functions refereed to in edge_conditions and point_conditions.\n\nKeyword Arguments\n\ndirichlet_nodes::Dict{Int,Int}=Dict{Int,Int}()\n\nA Dict that stores all Dirichlet points u as keys, with keys mapping to indices idx that refer to the corresponding condition function and parameters in functions and parameters.\n\ndudt_nodes::Dict{Int,Int}=Dict{Int,Int}()\n\nA Dict that stores all Dudt points u as keys, with keys mapping to indices idx that refer to the corresponding condition function and parameters in functions and parameters.\n\nparameters::Tuple=ntuple(_ -> nothing, length(functions))\n\nThe parameters for the functions, with parameters[i] giving the argument p in functions[i].\n\nOutputs\n\nThe returned value is the corresponding InternalConditions struct.\n\nnote: Note\nWhen the internal conditions get merged with the boundary conditions,  any internal conditions that are placed onto the boundary will  be replaced with the boundary condition at that point on the boundary.\n\n\n\n\n\n","category":"type"},{"location":"interface/#FVMProblem:-Defining-the-PDE","page":"Interface","title":"FVMProblem: Defining the PDE","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Once you have defined the mesh, the boundary conditions, and possibly the internal conditions, you can now construct the PDE itself. This is done using FVMProblem, whose docstring is below; the fields of FVMProblem are public API.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"FVMProblem ","category":"page"},{"location":"interface/#FiniteVolumeMethod.FVMProblem","page":"Interface","title":"FiniteVolumeMethod.FVMProblem","text":"FVMProblem(mesh, boundary_conditions[, internal_conditions];\n    diffusion_function=nothing,\n    diffusion_parameters=nothing,\n    source_function=nothing,\n    source_parameters=nothing,\n    flux_function=nothing,\n    flux_parameters=nothing,\n    initial_condition,\n    initial_time=0.0,\n    final_time)\n\nConstructs an FVMProblem. See also FVMSystem and SteadyFVMProblem.\n\nArguments\n\nmesh::FVMGeometry\n\nThe mesh on which the PDE is defined, given as a FVMGeometry.\n\nboundary_conditions::BoundaryConditions\n\nThe boundary conditions for the PDE, given as a BoundaryConditions.\n\ninternal_conditions::InternalConditions=InternalConditions()\n\nThe internal conditions for the PDE, given as an InternalConditions. This argument  is optional.\n\nKeyword Arguments\n\ndiffusion_function=nothing\n\nIf isnothing(flux_function), then this can be provided to give the diffusion-source formulation. See also construct_flux_function. Should be of the form D(x, y, t, u, p).\n\ndiffusion_parameters=nothing\n\nThe argument p for diffusion_function.\n\nsource_function=(x, y, t, u, p) -> zero(u)\n\nThe source term, given in the form S(x, y, t, u, p).\n\nsource_parameters=nothing\n\nThe argument p for source_function.\n\nflux_function=nothing\n\nThe flux function, given in the form q(x, y, t, α, β, γ, p) ↦ (qx, qy), where (qx, qy) is the flux vector, (α, β, γ) are the shape function coefficients for estimating u ≈ αx+βy+γ. If isnothing(flux_function), then diffusion_function is used instead to construct the function.\n\nflux_parameters=nothing\n\nThe argument p for flux_function.\n\ninitial_condition\n\nThe initial condition, with initial_condition[i] the initial value at the ith node of the mesh.\n\ninitial_time=0.0\n\nThe initial time.\n\nfinal_time\n\nThe final time.\n\nOutputs\n\nThe returned value is the corresponding FVMProblem struct. You can then solve the problem using solve(::Union{FVMProblem,FVMSystem}, ::Any; kwargs...) from DifferentialEquations.jl.\n\n\n\n\n\n","category":"type"},{"location":"interface/","page":"Interface","title":"Interface","text":"For this problem, you can provide either a diffusion_function or a flux_function. In the former case, the flux_function is constructed from diffusion_function using construct_flux_function, whose docstring is shown below; construct_flux_function is not public API.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"construct_flux_function","category":"page"},{"location":"interface/#FiniteVolumeMethod.construct_flux_function","page":"Interface","title":"FiniteVolumeMethod.construct_flux_function","text":"construct_flux_function(q, D, Dp)\n\nIf isnothing(q), then this returns the flux function based on the diffusion function D and  diffusion parameters Dp, so that the new function is \n\n(x, y, t, α, β, γ, _) -> -D(x, y, t, α*x + β*y + γ, Dp)[α, β]\n\nOtherwise, just returns q again.\n\n\n\n\n\n","category":"function"},{"location":"interface/","page":"Interface","title":"Interface","text":"Additionally, FVMProblem merges the provided boundary conditions and internal conditions into a Conditions type, defined below; the documented fields of Conditions are public API.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Conditions","category":"page"},{"location":"interface/#FiniteVolumeMethod.Conditions","page":"Interface","title":"FiniteVolumeMethod.Conditions","text":"Conditions{F}\n\nThis is a struct that holds the boundary and internal conditions for the PDE.\n\nFields\n\nneumann_conditions::Dict{NTuple{2,Int},Int}\n\nA Dict that stores all Neumann edges (u, v) as keys, with keys mapping to indices  idx that refer to the corresponding condition function and parameters in functions.\n\nconstrained_conditions::Dict{NTuple{2,Int},Int}\n\nA Dict that stores all Constrained edges (u, v) as keys, with keys mapping to indices idx that refer to the corresponding condition function and parameters in functions.\n\ndirichlet_conditions::Dict{Int,Int}\n\nA Dict that stores all Dirichlet points u as keys, with keys mapping to indices idx that refer to the corresponding condition function and parameters in functions.\n\ndudt_conditions::Dict{Int,Int}\n\nA Dict that stores all Dudt points u as keys, with keys mapping to indices idx that refer to the corresponding condition function and parameters in functions.\n\nfunctions::F\n\nA Tuple of functions that correspond to the condition function. Can also be a single function.\n\n\n\n\n\n","category":"type"},{"location":"interface/#SteadyFVMProblem:-Making-the-problem-a-steady-state-problem","page":"Interface","title":"SteadyFVMProblem: Making the problem a steady-state problem","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"To make an FVMProblem a steady-state problem, meaning that you are solving","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"div vb q(vb x t u) = S(vb x t u)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"rather than","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"pdvu(vb x t)t + div vb q(vb x t u) = S(vb x t u)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"than you need to wrap the FVMProblem inside a SteadyFVMProblem, defined below; the fields of SteadyFVMProblem are public API.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"SteadyFVMProblem","category":"page"},{"location":"interface/#FiniteVolumeMethod.SteadyFVMProblem","page":"Interface","title":"FiniteVolumeMethod.SteadyFVMProblem","text":"SteadyFVMProblem(prob::AbstractFVMProblem)\n\nThis is a wrapper for an AbstractFVMProblem that indicates that the problem is to be solved as a steady-state problem.  You can then solve the problem using solve(::SteadyFVMProblem, ::Any; kwargs...) from NonlinearSolve.jl. Note that you  need to have set the final time to Inf if you want a steady state out at infinity rather than some finite actual time.\n\nSee also FVMProblem and FVMSystem.\n\n\n\n\n\n","category":"type"},{"location":"interface/#FVMSystem:-Defining-a-system-of-PDEs","page":"Interface","title":"FVMSystem: Defining a system of PDEs","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"We also allow for systems of PDEs to be defined, where this system should take the form","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"beginequation*\nbeginaligned\npdvu_1(vb x t)t + div vb q_1(vb x t u_1 ldots u_n) = S_1(vb x t u_1 ldots u_n) \npdvu_2(vb x t)t + div vb q_2(vb x t u_1 ldots u_n) = S_2(vb x t u_1 ldots u_n) \nvdots \npdvu_n(vb x t)t + div vb q_n(vb x t u_1 ldots u_n) = S_n(vb x t u_1 ldots u_n)\nendaligned\nendequation*","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"To define this system, you need to provide an FVMProblem for each equation, and then construct an FVMSystem from these problems. The docstring for FVMSystem is below; the fields of FVMSystem are public API.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"FVMSystem","category":"page"},{"location":"interface/#FiniteVolumeMethod.FVMSystem","page":"Interface","title":"FiniteVolumeMethod.FVMSystem","text":"FVMSystem(prob1, prob2, ..., probN)\n\nConstructs a representation for a system of PDEs, where each probi is  a FVMProblem for the ith component of the system.\n\nFor these FVMProblems, the functions involved, such as the condition functions, should  all be defined so that the u argument assumes the form u = (u₁, u₂, ..., uN) (both Tuples and Vectors will be passed),  where uᵢ is the solution for the ith component of the system. For the flux functions,  which for a FVMProblem takes the form\n\nq(x, y, t, α, β, γ, p) ↦ (qx, qy),\n\nthe same form is used, except α, β, γ are all Tuples so that α[i]*x + β[i]*y + γ[i] is the  approximation to uᵢ. \n\nwarning: Providing default flux functions\nDue to this difference in flux functions, and the need to provide  α, β, and γ to the flux function, for FVMSystems you need to  provide a flux function rather than a diffusion function. If you do provide a diffusion function, it will error when you try to solve  the problem.\n\nThis problem is solved in the same way as a FVMProblem, except the problem is defined such that  the solution returns a matrix at each time, where the (j, i)th component corresponds to the solution at the ith  node for the jth component.\n\nSee also FVMProblem and SteadyFVMProblem.\n\nnote: Note\nTo construct a steady-state problem for an FVMSystem, you need to apply  SteadyFVMProblem to the system rather than first applying it to each individual FVMProblem in the system.\n\n\n\n\n\n","category":"type"},{"location":"interface/","page":"Interface","title":"Interface","text":"If you want to make a steady-state problem for an FVMSystem, you should apply SteadyFVMProblem to FVMSystem rather than to each FVMProblem individually.","category":"page"},{"location":"interface/#solve:-Solving-the-PDE","page":"Interface","title":"solve: Solving the PDE","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"You can use solve from the SciMLBase ecosystem to solve these PDEs. This allows you to use any of the available algorithms from DifferentialEquations.jl for solving these problems. For non-steady problems, the relevant function is (which is public API)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"solve(::Union{FVMProblem,FVMSystem}, ::Any; kwargs...)","category":"page"},{"location":"interface/#CommonSolve.solve-Tuple{Union{FVMProblem, FVMSystem}, Any}","page":"Interface","title":"CommonSolve.solve","text":"solve(prob::Union{FVMProblem,FVMSystem}, alg; \n    specialization=SciMLBase.AutoSpecialize, \n    jac_prototype=jacobian_sparsity(prob), \n    parallel::Val{<:Bool}=Val(true),\n    mass_matrix=I,\n    f=fvm_eqs!,\n    kwargs...)\n\nSolves the given FVMProblem or FVMSystem prob with the algorithm alg.\n\nArguments\n\nprob: The problem to be solved.\nalg: The algorithm to be used to solve the problem. This can be any of the algorithms in DifferentialEquations.jl.\n\nKeyword Arguments\n\nspecialization=SciMLBase.AutoSpecialize: The type of specialization to be used. See https://docs.sciml.ai/DiffEqDocs/stable/features/low_dep/#Controlling-Function-Specialization-and-Precompilation.\njac_prototype=jacobian_sparsity(prob): The prototype for the Jacobian matrix, constructed by default from jacobian_sparsity. Ignored if the mass matrix is not I.\nparallel::Val{<:Bool}=Val(true): Whether to use multithreading. Use Val(false) to disable multithreading. \nmass_matrix=I: The mass matrix to be used in the problem. This argument can be useful for defining differential-algebraic equations.\nf=fvm_eqs!: The function defining the PDEs. You should only need to change this if you need a differential-algebraic equation. See the maze tutorial in the docs.\nkwargs...: Any other keyword arguments to be passed to the solver.\n\nOutputs\n\nThe returned value sol depends on the type of the problem.\n\nFVMProblem\n\nIn this case, sol::ODESolution is such that the ith component of sol refers to the ith node of the underlying mesh.\n\nFVMSystem\n\nIn this case, the (j, i)th component of sol::ODESolution refers to the ith node of the underlying mesh for the jth component of the system.\n\n\n\n\n\n","category":"method"},{"location":"interface/","page":"Interface","title":"Interface","text":"For steady-state problems, the algorithms to use are those from NonlinearSolve.jl. The relevant function is still solve and is public API:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"solve(::SteadyFVMProblem, ::Any; kwargs...)","category":"page"},{"location":"interface/#CommonSolve.solve-Tuple{SteadyFVMProblem, Any}","page":"Interface","title":"CommonSolve.solve","text":"solve(prob::SteadyFVMProblem, alg; \n    specialization=SciMLBase.AutoSpecialize, \n    jac_prototype=jacobian_sparsity(prob),\n    parallel::Val{<:Bool}=Val(true),\n    mass_matrix=I,\n    f = fvm_eqs!,\n    kwargs...)\n\nSolves the given FVMProblem or FVMSystem prob with the algorithm alg.\n\nArguments\n\nprob: The problem to be solved.\nalg: The algorithm to be used to solve the problem. This can be any of the algorithms in NonlinearSolve.jl.\n\nKeyword Arguments\n\nspecialization=SciMLBase.AutoSpecialize: The type of specialization to be used. See https://docs.sciml.ai/DiffEqDocs/stable/features/low_dep/#Controlling-Function-Specialization-and-Precompilation.\njac_prototype=jacobian_sparsity(prob): The prototype for the Jacobian matrix, constructed by default from jacobian_sparsity. Ignored if the mass matrix is not I.\nparallel::Val{<:Bool}=Val(true): Whether to use multithreading. Use Val(false) to disable multithreading.\nmass_matrix=I: The mass matrix to be used in the problem. This argument can be useful for defining differential-algebraic equations.\nf=fvm_eqs!: The function defining the PDEs. You should only need to change this if you need a differential-algebraic equation. See the maze tutorial in the docs.\nkwargs...: Any other keyword arguments to be passed to the solver.\n\nOutputs\n\nThe returned value sol depends on whether the underlying problem is a FVMProblem or an FVMSystem, but in  each case it is an ODESolution type that can be accessed like the solutions in DifferentialEquations.jl:\n\nFVMProblem\n\nIn this case, sol is such that the ith component of sol refers to the ith node of the underlying mesh.\n\nFVMSystem\n\nIn this case, the (j, i)th component of sol refers to the ith node of the underlying mesh for the jth component of the system.\n\n\n\n\n\n","category":"method"},{"location":"interface/","page":"Interface","title":"Interface","text":"These solve functions rely on fvm_eqs! for evaluating the equations. You should never need to use fvm_eqs! directly, unless you are using a differential-algebraic equation. The docstring for fvm_eqs! is below; this function is public API.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"fvm_eqs!","category":"page"},{"location":"interface/#FiniteVolumeMethod.fvm_eqs!","page":"Interface","title":"FiniteVolumeMethod.fvm_eqs!","text":"fvm_eqs!(du, u, p, t)\n\nComputes the finite volume method equations for the current time t  and solution u. This function is public API.\n\nThe argument p depends on whether the problem is being solved  in parallel or not. If it is solved serially, than the fields are:\n\np.prob: The prob <: AbstractFVMProblem.\np.parallel: Val(false).\n\nIf the problem is solved in parallel, then the fields are:\n\np.prob: The prob <: AbstractFVMProblem.\np.parallel: Val(true).   \np.duplicated_du: A Matrix of the same size as du that is used to store the contributions to du from each thread. \np.solid_triangles: A Vector of the solid triangles in the triangulation.\np.solid_vertices: A Vector of the solid vertices in the triangulation.\np.chunked_solid_triangles: A Vector of tuples of the form (range, chunk_idx) where range is a range of indices into p.solid_triangles and chunk_idx is the index of the chunk.\np.boundary_edges: A Vector of the boundary edges in the triangulation.\np.chunked_boundary_edges: A Vector of tuples of the form (range, chunk_idx) where range is a range of indices into p.boundary_edges and chunk_idx is the index of the chunk.\n\nThese fields are public API, although note that they are not intended to be modified by the user, and we may freely  add in new fields over new versions.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Custom-constraints","page":"Interface","title":"Custom constraints","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"You can also provide custom constraints. Rather than outlining this precisely here, it is best explained in the tutorials, namely this tutorial. We note that one useful function for this is compute_flux, which allows you to compute the flux across a given edge. The docstring for compute_flux is below, and this function is public API.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"compute_flux","category":"page"},{"location":"interface/#FiniteVolumeMethod.compute_flux","page":"Interface","title":"FiniteVolumeMethod.compute_flux","text":"compute_flux(prob::AbstractFVMProblem, i, j, u, t)\n\nGiven an edge with indices (i, j), a solution vector u, a current time t,  and a problem prob, computes the flux ∇⋅q(x, y, t, α, β, γ, p) ⋅ n,  where n is the normal vector to the edge, q is the flux function from prob, (x, y) is the midpoint of the edge, (α, β, γ) are the shape function coefficients,  and p are the flux parameters from prob. If prob is an FVMSystem, the returned  value is a Tuple for each individual flux. The normal vector n is a clockwise rotation of  the edge, meaning pointing right of the edge (i, j).\n\n\n\n\n\n","category":"function"},{"location":"interface/#Piecewise-linear-interpolation","page":"Interface","title":"Piecewise linear interpolation","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"You can evaluate the piecewise linear interpolation corresponding to a solution using pl_interpolate, defined below; this function is public API.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"pl_interpolate","category":"page"},{"location":"interface/#FiniteVolumeMethod.pl_interpolate","page":"Interface","title":"FiniteVolumeMethod.pl_interpolate","text":"pl_interpolate(prob, T, u, x, y)\n\nGiven a prob <: AbstractFVMProblem, a triangle T containing a point (x, y),  and a set of function values u at the corresponding nodes of prob, interpolates  the solution at the point (x, y) using piecewise linear interpolation.\n\n\n\n\n\n","category":"function"},{"location":"interface/","page":"Interface","title":"Interface","text":"Better interpolants are available from NaturalNeighbours.jl - see the this tutorial for some examples.","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"EditURL = \"https://github.com/DanielVandH/FiniteVolumeMethod.jl/tree/main/docs/src/literate_tutorials/laplaces_equation_with_internal_dirichlet_conditions.jl\"","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/#Laplace's-Equation-with-Internal-Dirichlet-Conditions","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"","category":"section"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"In this tutorial, we consider Laplace's equation with some additional complexity put into the problem via internal Dirichlet conditions:","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"beginequation\nbeginaligned\ngrad^2 u = 0  vb x in 0 1^2 \nu(0 y) = 100y  0 leq y leq 1 \nu(1 y) = 100y  0 leq y leq 1 \nu(x 0) = 0  0 leq x leq 1 \nu(x 1) = 100  0 leq x leq 1 \nu(12 y) = 0  0 leq y leq 25\nendaligned\nendequation","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"To start with solving this problem, let us define an initial mesh.","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"using DelaunayTriangulation, FiniteVolumeMethod\ntri = triangulate_rectangle(0, 1, 0, 1, 50, 50, single_boundary=false)","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"In this mesh, we don't have any points that lie exactly on the line x = 12 0 leq y leq 25, so we cannot enforce this constraint exactly.[1] Instead, we need to add these points into tri. We do not need to add any constrained edges in this case, since these internal conditions are enforced only at points.","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"[1]: Of course, by defining the grid spacing appropriately we could have such points, but we just want to show here how we can add these points in if needed.","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"Let us now add in the points.","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"using CairoMakie\nnew_points = LinRange(0, 2 / 5, 250)\nfor y in new_points\n    add_point!(tri, 1 / 2, y)\nend\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"It may also help to refine the mesh slightly.","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"refine!(tri, max_area=1e-4)\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"mesh = FVMGeometry(tri)","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"Now that we have the mesh, we can define the boundary conditions. Remember that the order of the boundary indices is the bottom wall, right wall, top wall, and then the left wall.","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"bc_bot = (x, y, t, u, p) -> zero(u)\nbc_right = (x, y, t, u, p) -> oftype(u, 100y) # helpful to have each bc return the same type\nbc_top = (x, y, t, u, p) -> oftype(u, 100)\nbc_left = (x, y, t, u, p) -> oftype(u, 100y)\nbcs = (bc_bot, bc_right, bc_top, bc_left)\ntypes = (Dirichlet, Dirichlet, Dirichlet, Dirichlet)\nBCs = BoundaryConditions(mesh, bcs, types)","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"We now need to define the internal conditions. This is done using InternalConditions. First, we need to find all the vertices that lie on the line x = 12 0 leq y leq 25. We could compute these manually, but let's find them programatically instead for the sake of demonstration.","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"function find_all_points_on_line(tri)\n    vertices = Int[]\n    for i in each_solid_vertex(tri)\n        x, y = get_point(tri, i)\n        if x == 1 / 2 && 0 ≤ y ≤ 2 / 5\n            push!(vertices, i)\n        end\n    end\n    return vertices\nend\nvertices = find_all_points_on_line(tri)\nfig, ax, sc = triplot(tri)\npoints = [get_point(tri, i) for i in vertices]\nscatter!(ax, points, color=:red, markersize=10)\nfig","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"Now that we have the vertices, we can define the internal conditions. We need to provide InternalConditions with a Dict that maps each vertex in vertices to a function index that corresponds to the condition for that vertex. In this case, that function index is 1 as we only have a single function.","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"ICs = InternalConditions((x, y, t, u, p) -> zero(u),\n    dirichlet_nodes=Dict(vertices .=> 1))","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"Now we can define the problem. As discussed in the Helmholtz tutorial, we are looking to define a steady state problem, and so the initial condition needs to be a suitable initial guess of what the solution could be. Looking to the boundary and internal conditions, one suitable guess is u(x y) = 100y with u(12 y) = 0 for 0 leq y leq 25; in fact, u(x y) = 100y is the solution of the problem without the internal condition. Let us now use this to define our initial condition.","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"initial_condition = zeros(num_points(tri))\nfor i in each_solid_vertex(tri)\n    x, y = get_point(tri, i)\n    initial_condition[i] = ifelse(x == 1 / 2 && 0 ≤ y ≤ 2 / 5, 0, 100y)\nend","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"Now let's define the problem. The internal conditions are provided as the third argument of FVMProblem.","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"diffusion_function = (x, y, t, u, p) -> one(u) # ∇²u = ∇⋅[D∇u], D = 1\nfinal_time = Inf\nprob = FVMProblem(mesh, BCs, ICs;\n    diffusion_function,\n    initial_condition,\n    final_time)","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"steady_prob = SteadyFVMProblem(prob)","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"Now let's solve the problem.","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"using SteadyStateDiffEq, LinearSolve, OrdinaryDiffEq\nsol = solve(steady_prob, DynamicSS(TRBDF2(linsolve=KLUFactorization())))","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"fig, ax, sc = tricontourf(tri, sol.u, levels=LinRange(0, 100, 28))\ntightlimits!(ax)\nfig","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/#Just-the-code","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Just the code","text":"","category":"section"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"using DelaunayTriangulation, FiniteVolumeMethod\ntri = triangulate_rectangle(0, 1, 0, 1, 50, 50, single_boundary=false)\n\nusing CairoMakie\nnew_points = LinRange(0, 2 / 5, 250)\nfor y in new_points\n    add_point!(tri, 1 / 2, y)\nend\nfig, ax, sc = triplot(tri)\nfig\n\nrefine!(tri, max_area=1e-4)\nfig, ax, sc = triplot(tri)\nfig\n\nmesh = FVMGeometry(tri)\n\nbc_bot = (x, y, t, u, p) -> zero(u)\nbc_right = (x, y, t, u, p) -> oftype(u, 100y) # helpful to have each bc return the same type\nbc_top = (x, y, t, u, p) -> oftype(u, 100)\nbc_left = (x, y, t, u, p) -> oftype(u, 100y)\nbcs = (bc_bot, bc_right, bc_top, bc_left)\ntypes = (Dirichlet, Dirichlet, Dirichlet, Dirichlet)\nBCs = BoundaryConditions(mesh, bcs, types)\n\nfunction find_all_points_on_line(tri)\n    vertices = Int[]\n    for i in each_solid_vertex(tri)\n        x, y = get_point(tri, i)\n        if x == 1 / 2 && 0 ≤ y ≤ 2 / 5\n            push!(vertices, i)\n        end\n    end\n    return vertices\nend\nvertices = find_all_points_on_line(tri)\nfig, ax, sc = triplot(tri)\npoints = [get_point(tri, i) for i in vertices]\nscatter!(ax, points, color=:red, markersize=10)\nfig\n\nICs = InternalConditions((x, y, t, u, p) -> zero(u),\n    dirichlet_nodes=Dict(vertices .=> 1))\n\ninitial_condition = zeros(num_points(tri))\nfor i in each_solid_vertex(tri)\n    x, y = get_point(tri, i)\n    initial_condition[i] = ifelse(x == 1 / 2 && 0 ≤ y ≤ 2 / 5, 0, 100y)\nend\n\ndiffusion_function = (x, y, t, u, p) -> one(u) # ∇²u = ∇⋅[D∇u], D = 1\nfinal_time = Inf\nprob = FVMProblem(mesh, BCs, ICs;\n    diffusion_function,\n    initial_condition,\n    final_time)\n\nsteady_prob = SteadyFVMProblem(prob)\n\nusing SteadyStateDiffEq, LinearSolve, OrdinaryDiffEq\nsol = solve(steady_prob, DynamicSS(TRBDF2(linsolve=KLUFactorization())))\n\nfig, ax, sc = tricontourf(tri, sol.u, levels=LinRange(0, 100, 28))\ntightlimits!(ax)\nfig","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"","category":"page"},{"location":"tutorials/laplaces_equation_with_internal_dirichlet_conditions/","page":"Laplace's Equation with Internal Dirichlet Conditions","title":"Laplace's Equation with Internal Dirichlet Conditions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"math/#Mathematical-and-Implementation-Details","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"","category":"section"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Pages = [\"math.md\"]","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Here we outline the mathematical and implementation details involved in implementing the finite volume method (FVM). We assume that our partial differential equation (PDE) is given by ","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequation\nlabeleqpde\npdvu(vb x t)t + div vb q(vb x t u) = S(vb x t u) quad vb x in Omega\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"together with some boundary conditions or internal conditions that we discuss later. We also discuss steady-state problems and systems of PDEs of the form \\eqref{eq:pde}.","category":"page"},{"location":"math/#Interior-Discretisation","page":"Mathematical and Implementation Details","title":"Interior Discretisation","text":"","category":"section"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Let us start by discretising \\eqref{eq:pde} inside Omega. The first step in this discretisation is to compute a triangulation of Omega, decomposing Omega into a collection of disjoint triangles T_k so that ","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Omega = bigcup_k T_k","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"This triangulation is typically a constrained Delaunay triangulation, denoted mathcal T(Omega), with appropriate care taken if Omega is multiply-connected; these triangulations can be computed using DelaunayTriangulation.jl. An example of such a domain Omega and its triangulation mathcal T(Omega) is shown below, where we use a multiply-connected domain to emphasise that these details are not necessarily restricted to simple domains.","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"using DelaunayTriangulation, CairoMakie\nθ = LinRange(0, 2π, 50)\nθ = collect(θ)\nθ[end] = θ[begin]\ng = θ -> cos(θ) - sin(3θ) + sin(5θ)\nε = 1 / 10\nx = @. (1 + g(θ) * ε) * cos(θ)\ny = @. (1 + g(θ) * ε) * sin(θ)\nh = θ -> cos(3θ) - sin(θ)\nε = 1 / 5\nx2 = @. 0.5(1 + h(θ) * ε) * cos(θ)\ny2 = @. 0.5(1 + h(θ) * ε) * sin(θ)\nreverse!(x2)\nreverse!(y2)\nboundary_nodes, points = convert_boundary_points_to_indices([[x], [x2]], [[y], [y2]])\ntri = triangulate(points; boundary_nodes, delete_ghosts=false)\nrefine!(tri)\nfig, ax, sc = triplot(tri,\n    show_convex_hull=false,\n    show_constrained_edges=false,\n    show_all_points=true,\n    point_color=:black)\nhidedecorations!(ax)","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"fig #hide","category":"page"},{"location":"math/#Control-volumes","page":"Mathematical and Implementation Details","title":"Control volumes","text":"","category":"section"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Key to the FVM are the control volumes, which are used to define volumes Omega_i around individual vertices vb x_i that we integrate the PDE over. To define these volumes, take vb x_i in Omega, which is a vertex of mathcal T(Omega), and take the set of triangles mathcal T_i = T_k that have vb x_i as a vertex. For each of these triangles T_k in mathcal T_i, connect its centroid to the midpoints of the triangle's edges. Once this procedure is complete, we obtain a closed polygon around vb x_i that we denote by partialOmega_i and whose interior defines the control volume Omega_i. We show the result of this procedure, applied to the above domain, below, where we show the centroids in red and the control volume boundaries in blue.","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"centroids = NTuple{2,Float64}[]\nlinesegments = NTuple{2,Float64}[]\nfor T in each_solid_triangle(tri)\n    i, j, k = indices(T)\n    p, q, r = get_point(tri, i, j, k)\n    cent = DelaunayTriangulation.triangle_centroid(p, q, r)\n    push!(centroids, cent)\n    u, v, w = DelaunayTriangulation.triangle_edge_midpoints(p, q, r)\n    push!(linesegments, cent, u, cent, v, cent, w)\nend\nlinesegments!(ax, linesegments, color=:blue)\nscatter!(ax, centroids, color=:red, markersize=8)","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"fig #hide","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Let us now establish some notation for referring to these control volumes, using the figure below  as a reference.","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Symbol Description Example\nvb x_i A vertex of mathcal T(Omega) The blue point below\nOmega_i The control volume around vb x_i The green region below\npartialOmega_i The boundary of Omega_i The blue edges below\nV_i The volume of Omega_i The volume of the green region below\nmathcal E_i The set of edges of partialOmega_i The blue edges below\nsigma An edge sigma in mathcal E_i The magenta edge below. Note that bigcup_sigma in mathcal E_i sigma = partialOmega_i\nvb x_sigma The midpoint of sigma in mathcal E_i The blue point below on sigma\nhatvb n_sigma The outward unit normal vector to sigma in mathcal E_i The black arrow below\nmathcal T_i The set of triangles that have vb x_i as a vertex The black triangles surrounding vb x_i below\nL_sigma The length of sigma in mathcal E_i The length of the magenta edge below","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"using DelaunayTriangulation, CairoMakie, LinearAlgebra\na, b, c, d, e, f = (0.0, 0.0),\n(2.0, 3.0),\n(4.0, -1.0),\n(1.0, -4.0),\n(-4.0, -2.0),\n(-4.0, 2.0)\npoints = [a, b, c, d, e, f]\ntri = triangulate(points)\n\ncentroids = NTuple{2,Float64}[]\nlinesegments = NTuple{2,Float64}[]\nother_linesegments = NTuple{2,Float64}[]\nnon_cv_midpoints = collect.([\n    (f .+ b) ./ 2,\n    (b .+ c) ./ 2,\n    (c .+ d) ./ 2,\n    (d .+ e) ./ 2,\n    (e .+ f) ./ 2\n])\nfor T in each_solid_triangle(tri)\n    i, j, k = indices(T)\n    p, q, r = get_point(tri, i, j, k)\n    cent = DelaunayTriangulation.triangle_centroid(p, q, r)\n    push!(centroids, cent)\n    u, v, w = DelaunayTriangulation.triangle_edge_midpoints(p, q, r)\n    any(≈(collect(u)), non_cv_midpoints) ? push!(other_linesegments, cent, u) : push!(linesegments, cent, u)\n    any(≈(collect(v)), non_cv_midpoints) ? push!(other_linesegments, cent, v) : push!(linesegments, cent, v)\n    any(≈(collect(w)), non_cv_midpoints) ? push!(other_linesegments, cent, w) : push!(linesegments, cent, w)\nend\n\ncontrol_volume_verts = vcat(linesegments, centroids)\ncv_idx = collect(eachindex(control_volume_verts))\nDelaunayTriangulation.sort_convex_polygon!(cv_idx, control_volume_verts)\nfig, ax, sc = poly(control_volume_verts[cv_idx],\n    color=:lightgreen,\n    axis=(width=400, height=400))\ntriplot!(tri,\n    show_convex_hull=false,\n    show_constrained_edges=false,\n    show_all_points=true,\n    point_color=:black,\n    markersize=11)\nscatter!(ax, [a, b, c], color=:cyan, markersize=11, strokecolor=:black, strokewidth=1)\nlinesegments!(ax, linesegments, color=:blue, linewidth=3)\nlinesegments!(ax, other_linesegments, color=(:grey, 0.5))\n\ncidx = findfirst(≈(collect((f .+ a .+ b) ./ 3)), collect.(centroids))\nlidx = findfirst(≈(collect((f .+ a) ./ 2)), collect.(linesegments))\nu, v = centroids[cidx], linesegments[lidx]\nrot90_uv = [0 -1; 1 0] * collect(u .- v)\nrot90_uv = 0.8rot90_uv ./ norm(rot90_uv)\nm = (u .+ v) ./ 2\np = scatter!(ax, [m], color=:blue, markersize=11, strokecolor=:black, strokewidth=1)\narrows!(ax, [m[1]], [m[2]], [rot90_uv[1]], [rot90_uv[2]], color=:black)\nlines!(ax, [u, v], color=:magenta, linewidth=3)\ntranslate!(p, 0, 0, 1)\n\nscatter!(ax, centroids, color=:red, markersize=11, strokecolor=:black, strokewidth=1)\ntext!(ax, -0.8, -1.7, text=L\"\\Omega_i\", fontsize=24)\ntext!(ax, -3.2, -1.0, text=L\"\\partial\\Omega_i\", fontsize=24)\ntext!(ax, -2.0, 1.1, text=L\"\\sigma\", fontsize=24)\ntext!(ax, -2.4, 1.6, text=L\"\\hat{\\mathbf{n}}_{\\sigma}\", fontsize=24)\ntext!(ax, -1.4, 0.8, text=L\"\\mathbf{x}_{\\sigma}\", fontsize=24)\ntext!(ax, 0.2, 0.0, text=L\"\\mathbf{x}_{i}\", fontsize=24)\ntext!(ax, 0.2, -0.5, text=L\"v_{k1}\", fontsize=24)\ntext!(ax, 3.1, -1.3, text=L\"v_{k2}\", fontsize=24)\ntext!(ax, 2.1, 2.9, text=L\"v_{k3}\", fontsize=24)\ntext!(ax, 1.7, 1.5, text=L\"T_k\", fontsize=24)\n\nhidedecorations!(ax)\nresize_to_layout!(fig)","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"fig #hide","category":"page"},{"location":"math/#Discretising-the-PDE","page":"Mathematical and Implementation Details","title":"Discretising the PDE","text":"","category":"section"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Now that we have our concept of control volumes, we can discretise the PDE \\eqref{eq:pde}. We do this  by considering each PDE inside each Omega_i and integrating. For a given control volume Omega_i, we can integrate the PDE to give","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqintegratedi\ndvtiint_Omega_i uddV + iint_Omega_i divvb q ddV = iint_Omega_i S ddV\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Using the divergence theorem, the second integral in \\eqref{eq:integratedi} becomes","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqapplieddthm\niint_Omega_i divvb q = oint_partialOmega_i vb q vdot vu n_sigma dds = sum_sigma in mathcal E_i int_sigma vb q vdot vu n_sigma dds\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"where the last equality in \\eqref{eq:applieddthm} follows from integrating over each individual line segment that defines partialOmega_i, which is simply mathcal E_i. We then define the control volume averages,","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqaverages\nbar u_i = frac1V_iiint_Omega_i uddVquad bar S_i = frac1V_iiint_Omega_i SddV\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"so that our integral formulation \\eqref{eq:integratedi} becomes","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqintform\ndvbar u_it + frac1V_isum_sigmainmathcal E_iint_sigma vb q vdot vu n_sigma dds = bar S_i\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Note that \\eqref{eq:intform} is still an exact expression.","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"To proceed, we need to approximate the integrals int_sigma vb q vdot vu n_sigmadds. To accomplish this, we use a midpoint rule, writing","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqmidpt_rule\nint_sigma vb q vdot vu n_sigma dds approx leftvb q(vb x_sigma t u(vb x_sigma t))vdot vu n_sigmarightL_sigma\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Then, replacing the control volume averages with their value at vb x_i, we obtain the following approximation:","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqnextapprox\ndvu_it + frac1V_isum_sigmainmathcal E_i leftvb q(vb x_sigma t u(vb x_sigma t)) vdot vu n_sigmarightL_sigma = S_i\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"where u_i = u(vb x_i t) and S_i = S(vb x_i t). ","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"The final step in this part of the approximation is the evaluation of vb q(vb x_sigma t u(vb x_sigma t)). To deal with this function, consider some T_k in mathcal T_i so that vb x_sigma is inside T_k. We use a linear shape function inside T_k to approximate u, writing","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqshape\nu(vb x t) = alpha_kx + beta_ky + gamma_k quad vb x in T_k\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"where we have suppressed the dependence of the coefficients (alpha_k beta_kgamma_k) on t. The vertices of T_k are given by v_k1 v_k2 v_k3 with corresponding coordinates vb x_k1 vb x_k2 vb x_k3, respectively. We can then solve for the coefficients in \\eqref{eq:shape} by requiring that u is equal to the values at the vertices of T_k, giving the system of equations","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqnear_cramer\nbeginaligned\nu(vb x_k1 t) = alpha_kx_k1 + beta_ky_k1 + gamma_k \nu(vb x_k2 t) = alpha_kx_k2 + beta_ky_k2 + gamma_k \nu(vb x_k3 t) = alpha_kx_k3 + beta_ky_k3 + gamma_k\nendaligned\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"where vb x_ki = (x_ki y_ki)^mkern-15mumathsfT. Note that the values on the left-hand side of \\eqref{eq:near_cramer} are all known from either the initial condition or the previous time-step. Using Cramer's rule, we define","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqshape_coeffs\nvb S_k = frac1Delta_kbeginbmatrix y_k2-y_k3  y_k3-y_k1  y_k1-y_k2  x_k3 - x_k2  x_k1-x_k3x_k2-x_k1  x_k2y_k3-x_k3y_k2  x_k3y_k1-x_k1y_k3x_k1y_k2-x_k2y_k1 endbmatrix\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"where","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqdeltak\nDelta_k = x_k1y_k2-x_k2y_k1-x_k1y_k3+x_k3y_k1+x_k2y_k3-x_k3y_k2\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"and thus we obtain","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqshapecoeffvals\nbeginaligned\nalpha_k = s_k11u_k1 + s_k12u_k2 + s_k13u_k3 \nbeta_k = s_k21u_k1 + s_k22u_k2 + s_k23u_k3 \ngamma_k = s_k31u_k1 + s_k32u_k2 + s_k33u_k3\nendaligned\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"where u_ki = u(vb x_ki t) and s_kij are the elements of vb S_k. With \\eqref{eq:shape} and \\eqref{eq:shapecoeffvals}, we can approximate vb q(vb x_sigma t u(vb x_sigma t)) and thus obtain the approximation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqinteriorapproximation\ndvu_it + frac1V_isum_sigmainmathcal E_i leftvb qleft(vb x_sigma t alpha_k(sigma)x_sigma + beta_k(sigma)y_sigma + gamma_kright)vdot vu n_sigmarightL_sigma = S_i\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"where k(sigma) is the index of the triangle that contains vb x_sigma. This linear shape function also allows us to compute gradients like grad u(vb x_sigma t), since grad u(vb x_sigma t) = (alpha_k(sigma) beta_k(sigma))^mkern-15mumathsfT.","category":"page"},{"location":"math/#Boundary-Conditions","page":"Mathematical and Implementation Details","title":"Boundary Conditions","text":"","category":"section"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Let us now discuss how boundary conditions (BCs) are handled. We assume that BCs take on any of the following forms:","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginalign\nvb q(vb x t u) vdot vu n_sigma = a(vb x t u)  vb x in mathcal B subseteq partialOmega labeleqneumann \ndvu(vb x t)t = a(vb x t u)  vb x in mathcal B subseteq partialOmega labeleqdudtdirichlet \nu(vb x t) = a(vb x t u)  vb x in mathcal B subseteq partialOmega labeleqdirichlet\nendalign","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"where the functions a are user-provided functions. The conditions \\eqref{eq:neumann}–\\eqref{eq:dirichlet} are called Neumann, time-dependent Dirichlet, and Dirichlet, respectively. We discuss how we handle incompatible BCs below, and then how each of these three types are implemented. ","category":"page"},{"location":"math/#Dirichlet-boundary-conditions","page":"Mathematical and Implementation Details","title":"Dirichlet boundary conditions","text":"","category":"section"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"When we have a Dirichlet BC of the form \\eqref{eq:dirichlet}, the implementation is simple: Rather than using \\eqref{eq:interiorapproximation}, we instead leave mathrm du_imathrm dt = 0 and update the value of u_i with a(vb x_i t u_i) at the end of the iteration using a callback; note that the expression u_i = a(vb x_i t u_i) is not an implicit equation for u_i, rather it is simply a reassignment of u_i to a(vb x_i t u_i), i.e. u_i leftarrow a(vb x_i t u_i).","category":"page"},{"location":"math/#Time-dependent-Dirichlet-boundary-conditions","page":"Mathematical and Implementation Details","title":"Time-dependent Dirichlet boundary conditions","text":"","category":"section"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"For a time-dependent Dirichlet BC of the form \\eqref{eq:dudtdirichlet}, the implementation is again simple: Rather than using \\eqref{eq:interiorapproximation}, simply compute mathrm du_imathrm dt = a(vb x_i t u_i) instead. ","category":"page"},{"location":"math/#Neumann-boundary-conditions","page":"Mathematical and Implementation Details","title":"Neumann boundary conditions","text":"","category":"section"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Neumann boundary conditions \\eqref{eq:neumann} are the most complex out of the three. Let us return to our integral formulation \\eqref{eq:intform}. Let mathcal E_i^n be the set of edges in mathcal E_i that have a Neumann BC associated with them, and mathcal E_i^c = mathcal E_i setminus mathcal E_i^n. Then, also using \\eqref{eq:interiorapproximation}, in the case of \\eqref{eq:neumann} we can write","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqneumanndecomp\ndvu_it + frac1V_isum_sigmain mathcal E_i^c leftvb q(vb x_sigma t alpha_k(sigma)x_sigma + beta_k(sigma)y_sigma + gamma_k) vdot vu n_sigmarightL_sigma + frac1V_isum_sigmainmathcal E_i^n int_sigma a_sigma(vb x t u)dds = S_i\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"where a_sigma is the BC function associated with sigma. This integral is then approximated using a midpoint rule as done previously, giving","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqneumanndecompapprox\ndvu_it + frac1V_isum_sigmain mathcal E_i^c leftvb q(vb x_sigma t u(vb x_sigma t)) vdot vu n_sigmarightL_sigma + frac1V_isum_sigmainmathcal E_i^n lefta_sigma(vb x_sigma t u(vb x_sigma t))rightL_sigma = S_i\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"where u(vb x_sigma t) = alpha_k(sigma)x_sigma + beta_k(sigma)y_sigma + gamma_k.","category":"page"},{"location":"math/#Internal-Conditions","page":"Mathematical and Implementation Details","title":"Internal Conditions","text":"","category":"section"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"We also allow for specifying internal conditions, meaning conditions of the form \\eqref{eq:neumann}–\\eqref{eq:dirichlet} that are applied away from the boundary. We do not currently allow for internal Neumann conditions directly.[1] These conditions are handled in the same way as BCs, except that the user is to provide them per-vertex rather than per-edge.","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"[1]: This is a technical limitation due to how the control volumes are defined. For vertices away from the boundary, the control volume edges do not lie along any of the triangle's edges, which is where we would like to impose Neumann conditions.","category":"page"},{"location":"math/#Putting-Everything-Together","page":"Mathematical and Implementation Details","title":"Putting Everything Together","text":"","category":"section"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"We have now specified how we discretise the PDE itself, and how we handle both boundary and internal conditions. The remaining task is to actually discuss how we compute mathrm du_imathrm dt. As written, \\eqref{eq:interiorapproximation} indicates that we loop over each vertex and, within each vertex, loop over each edge of its control volume. On average, mathcal E_i^c = 12 (since, on average, a point in a Delaunay triangulation has six neighbours), and so computing mathrm du_imathrm dt for each i requires mathcal O(12n) loop iterates and many repeated computations (since each control volume edge appears in another control volume), where n is the number of points in the mesh. An alternative approach is to instead loop over each triangle in mathcal T(Omega) and to then loop over each edge, adding the contributions from each to the associated vertices. This instead requires mathcal O(3mathcal T) loop iterates, where mathcal T is the number of triangles in mathcal T(Omega), and we instead only need to compute the relevant quantities for each control volume edge a single time; note that mathcal T = mathcal O(n) by Euler's formula. This is the approach we take in our implementation.","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Let us think about how we can instead loop over each triangle. Consider an interior control volume, shown below.","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"using DelaunayTriangulation, CairoMakie\nfunction get_control_volume(tri, i)\n    is_bnd, bnd_idx = DelaunayTriangulation.is_boundary_node(tri, i)\n    cv = NTuple{2,Float64}[]\n    if is_bnd\n        j = DelaunayTriangulation.get_right_boundary_node(tri, i, bnd_idx)\n        k = get_adjacent(tri, i, j)\n        p = get_point(tri, i)\n        push!(cv, p)\n        while !DelaunayTriangulation.is_boundary_index(k)\n            q, r = get_point(tri, j, k)\n            c = (p .+ q .+ r) ./ 3\n            m = (p .+ q) ./ 2\n            push!(cv, m, c)\n            j = k\n            k = get_adjacent(tri, i, j)\n            DelaunayTriangulation.is_boundary_index(k) && push!(cv, (p .+ r) ./ 2)\n        end\n        push!(cv, p)\n    else\n        S = DelaunayTriangulation.get_surrounding_polygon(tri, i)\n        push!(S, S[begin])\n        j = S[begin]\n        p = get_point(tri, i)\n        q = get_point(tri, j)\n        push!(cv, (p .+ q) ./ 2)\n        for k in S[2:end]\n            r = get_point(tri, k)\n            push!(cv, (p .+ q .+ r) ./ 3)\n            push!(cv, (p .+ r) ./ 2)\n            q = r\n        end\n    end\n    return cv\nend\na, b, c, d, e, f, g, h, i, j, k, ℓ = (0.0, 0.0),\n(2.0, 3.0),\n(4.0, -1.0),\n(1.0, -4.0),\n(-4.0, -2.0),\n(-4.0, 2.0),\n(-1.0, 5.0),\n(6.0, 3.0),\n(7.0, -2.0),\n(4.0, -5.0),\n(-3.0, -4.0),\n(-6.0, 0.0)\npoints = [a, b, c, d, e, f, g, h, i, j, k, ℓ]\ntri = triangulate(points)\n\nfig = Figure()\nax = Axis(fig[1, 1], width=400, height=400)\nfor i in 1:3\n    cv = get_control_volume(tri, i)\n    L = lines!(ax, cv, color=:blue, linewidth=3)\n    translate!(L, 0, 0, 1)\nend\npoly!(ax, [a, c, b],\n    color=:lightblue)\ntriplot!(tri,\n    show_convex_hull=false,\n    show_constrained_edges=false)\nscatter!(ax, [a, c, b], color=[:blue, :red, :darkgreen], strokecolor=:black, strokewidth=1)\ntext!(ax, 2.1, -0.3, text=L\"\\sigma_{br}\", fontsize=24)\ntext!(ax, 2.1, 1.0, text=L\"\\sigma_{rg}\", fontsize=24)\ntext!(ax, 1.0, 0.6, text=L\"\\sigma_{gb}\", fontsize=24)\nbr = lines!(ax, [(a .+ c) ./ 2, (a .+ b .+ c) ./ 3], color=:purple, linewidth=3)\ntranslate!(br, 0, 0, 1)\nbg = lines!(ax, [(a .+ b) ./ 2, (a .+ b .+ c) ./ 3], color=:teal, linewidth=3)\ntranslate!(bg, 0, 0, 1)\nrg = lines!(ax, [(b .+ c) ./ 2, (a .+ b .+ c) ./ 3], color=:yellow, linewidth=3)\ntranslate!(rg, 0, 0, 1)\nxlims!(ax, -3, 5.9)\nylims!(ax, -3.5, 4.5)\nhidedecorations!(ax)\nresize_to_layout!(fig)","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"fig #hide","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"We denote the triangle in blue by T, and refer to the blue, red, and green vertices by v_b, v_r, and v_g, respectively. The relevant edges that contribute to mathrm du_bmathrm dt, mathrm du_rmathrm dt, and mathrm du_gmathrm dt are sigma_br, sigma_rg, and sigma_gb, as annotated above. In particular, sigma_br contributes to both mathrm du_bmathrm dt and mathrm du_rmathrm dt, sigma_rg contributes to both mathrm du_rmathrm dt and mathrm du_gmathrm dt, and sigma_gb contributes to both mathrm du_gmathrm dt and mathrm du_bmathrm dt. ","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Let us focus on u_b and u_r. The contribution from e_br to mathrm du_bmathrm dt and mathrm du_rmathrm dt is given by:","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqtriangleupdate\nbeginaligned\ndvu_bt leftarrow dvu_bt - Q \ndvu_rt  leftarrow dvu_rt + Q \nendaligned\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"where ","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Q = leftvb qleft(vb x_br t alpha x_br + beta y_br + gammaright) vdot vu n_brrightL_br","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"and vb x_br is the midpoint of e_br; vu n_br is the unit normal vector to the edge sigma_br = overrightarrowvb x_brvb x_T, where vb x_T is the centroid of T which should only be computed once for the current T, which should point away from vb x_b but towards vb x_r; L_br = vb x_T - vb x_br, and alphabetagamma are computed from \\eqref{eq:shapecoeffvals} using the vertices of T. Notice that \\eqref{eq:triangleupdate} uses a minus sign for mathrm du_bmathrm dt and a plus sign for mathrm du_rmathrm dt, because we have brought the sum in \\eqref{eq:interiorapproximation} to the right-hand side of the equation. ","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"When we apply the procedure above to each triangle, we will have computed the contribution from each edge to each vertex - almost. The only issue is with boundary triangles, where the edges that lie on the boundary will not be iterated over as they not of the form overrightarrowvb x_brvb x_T (i.e., they are not connected to a centroid). There are two ways to handle this:","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"For each triangle looped over, also check if it is a boundary triangle and then consider its boundary edges.\nAfter looping over all triangles, loop over all boundary edges to pick up the missing contributions.","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"The second approach is preferable, as we don't need to worry about needless checks for boundary triangles, the number of boundary edges it has, etc. ","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"To understand how to pick up contributions from a single edge, consider the figure below which shows some control volumes in the corner of a domain:","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"tri = triangulate_rectangle(0, 1, 0, 1, 10, 10, single_boundary = false)\nadd_ghost_triangles!(tri)\nlinesegs = NTuple{2, Float64}[]\nfig = Figure()\nax = Axis(fig[1, 1], width=400, height=400)\ntriplot!(tri,\n    show_convex_hull=false,\n    show_constrained_edges=false)\nfor i in each_solid_vertex(tri)\n    cv = get_control_volume(tri, i)\n    L = lines!(ax, cv, color=:blue, linewidth=3)\n    translate!(L, 0, 0, 1)\nend\nxlims!(ax, -0.05, 0.2)\nylims!(ax, -0.05, 0.2)\nlin = lines!(ax, [get_point(tri, 1, 2)...], color=:red, linewidth=6)\ntranslate!(lin, 0, 0, 2)\nsc = scatter!(ax, [get_point(tri, 1, 2)...], color=:red, markersize=12)\ntranslate!(sc, 0, 0, 2)\ntext!(ax, (get_point(tri, 1) .- (0, 0.015))..., text = L\"v_i\", fontsize=24)\ntext!(ax, (get_point(tri, 2) .- (0, 0.015))..., text = L\"v_j\", fontsize=24)\nfig\nhidedecorations!(ax)\nresize_to_layout!(fig)","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"fig #hide","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Consider the edge e_ij shown in red. There two control volumes that lie on e_ij, the one for v_i and the other for v_j. We denote the midpoint of e_ij by vb x_ij = (vb x_i + vb x_j)2, so that the two control volume edges are overrightarrowvb x_ivb x_ij and overrightarrowvb x_ijvb x_j for v_i and v_j, respectively. The contributions from the flux over each edge gives","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqbndedgecontrbi\nbeginaligned\ndvu_it leftarrow dvu_it - Q_i 6pt\ndvu_jt leftarrow dvu_jt - Q_j 6pt\nendaligned\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"where ","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqbndedgecontrbiflux\nbeginaligned\nQ_i = leftvb qleft(vb m_i t alpha_ij m_ix + beta_ij m_iy + gamma_ijright) vdot vu n_ijrightL_i \nQ_j = leftvb qleft(vb m_j t alpha_ij m_jx + beta_ij m_jy + gamma_ijright) vdot vu n_ijrightL_j\nendaligned\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"where vb m_i = (vb x_i + vb x_ij)2 = (m_ix m_iy)^mkern-15mumathsfT, vb m_j = (vb x_ij + vb x_j)2 = (m_jx m_jy)^mkern-15mumathsfT, vb n_ij is the outward unit normal vector to e_ij, L_i = vb x_ij - vb x_i, L_j = vb x_j - vb x_ij, and alpha_ij beta_ij gamma_ij are computed from \\eqref{eq:shapecoeffvals} using the vertices of the triangle that contains e_ij. If there is a Neumann boundary condition on e_ij, \\eqref{eq:bndedgecontrbiflux} uses the boundary condition functions for computing the vb q vdot vu n terms.","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Now that we have looped over all triangles and also over all boundary edges, the final values for each mathrm du_imathrm dt is given by ","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"dvu_it leftarrow frac1V_idvu_it + S(vb x_i t u_i)","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"Of course, if there is a Dirichlet boundary condition at u_i we set mathrm du_imathrm dt = 0, and if there is a boundary condition on mathrm du_imathrm dt we use that boundary condition instead.","category":"page"},{"location":"math/#Systems-of-Equations","page":"Mathematical and Implementation Details","title":"Systems of Equations","text":"","category":"section"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"We also provide support for systems of PDEs that take the form","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqsystem\nbeginaligned\npdvu_1(vb x t)t + div vb q_1(vb x t u_1 ldots u_n) = S_1(vb x t u_1 ldots u_n) \npdvu_2(vb x t)t + div vb q_2(vb x t u_1 ldots u_n) = S_2(vb x t u_1 ldots u_n) \nvdots \npdvu_n(vb x t)t + div vb q_n(vb x t u_1 ldots u_n) = S_n(vb x t u_1 ldots u_n)\nendaligned\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"where any of the divergences and source terms may also depend on the other variables u_1ldotsu_n. We can write this as,","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqsystemsim\npdvvb u(vb x t)t + div vb Q(vb x t vb u) = vb S(vb x t vb u)\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"where","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqsysdef\nbeginaligned\nvb u(vb x t) = beginbmatrix u_1(vb x t)  u_2(vb x t)  vdots  u_n(vb x t) endbmatrix in mathbb R^n times 1 vb Q(vb x t vb u) = beginbmatrix vb q_1(vb x t vb u)  vb q_2(vb x t vb u)  cdots  vb q_n(vb x t vb u) endbmatrix in mathbb R^2 times n vb S(vb x t vb u) = beginbmatrix S_1(vb x t vb u)  S_2(vb x t vb u)  vdots  S_n(vb x t vb u) endbmatrix in mathbb R^n times 1\nendaligned\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"and the divergence div vb Q is defined as","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqdivdef\ndiv vb Q(vb x t vb u) = beginbmatrix div vb q_1(vb x t vb u)  div vb q_2(vb x t vb u)  vdots  divvb q_n(vb x t vb u) endbmatrix in mathbb R^n times 1\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"The method we use for solving these equations is basically the same as what we do for a single PDE. Letting vb u_i = vb u(vb x_i t) and vb S_i = vb S(vb x_i t), the analogous approximation to \\eqref{eq:interiorapproximation} is","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequationlabeleqsysapproxint\ndvu_it + frac1V_isum_sigmainmathcal E_i leftvb Qleft(vb x_sigma t t boldsymbolalpha_k(sigma)x_sigma + boldsymbolbeta_k(sigma)y_sigma + boldsymbolgamma_kright)^mkern-15mumathsfTvun_sigmarightL_sigma = vb S_i\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"where boldsymbolalpha_k(sigma), boldsymbolbeta_k(sigma), and boldsymbolgamma_k are the vectors of coefficients from \\eqref{eq:shapecoeffvals}, e.g.","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"boldsymbolalpha_k(sigma) = s_k(sigma)11vb u_k1 + s_k(sigma)12vb u_k2 + s_k(sigma)13vb u_k3","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"where vb u_ki = vb u(vb x_ki t) and s_k(sigma)ij are the elements of vb S_k(sigma). The only difference between \\eqref{eq:sysapproxint} and \\eqref{eq:interiorapproximation} is that we now have a vector of PDEs rather than a single PDE. The procedure for computing the contribution from each edge is the same as before, except that we now have to loop over each PDE in the system. In the code, we use a FVMSystem type to represent a system of PDEs, constructed by providing a vector of FVMProblems. The FVMSystem replaces the initial conditions with a matrix initial condition, where the ith column refers to the ith component of the system.","category":"page"},{"location":"math/#Steady-State-Problems","page":"Mathematical and Implementation Details","title":"Steady-State Problems","text":"","category":"section"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"We provide support for steady-state problems, in which case \\eqref{eq:pde} (and similarly for \\eqref{eq:system}) becomes","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"beginequation\ndiv vb q(vb x t u) = S(vb x t vb u)\nendequation","category":"page"},{"location":"math/","page":"Mathematical and Implementation Details","title":"Mathematical and Implementation Details","text":"This is solved in exactly the same way, except rootfinding is used and there is no timestepping.","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"EditURL = \"https://github.com/DanielVandH/FiniteVolumeMethod.jl/tree/main/docs/src/literate_tutorials/diffusion_equation_on_an_annulus.jl\"","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/#Diffusion-Equation-on-an-Annulus","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"","category":"section"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"In this tutorial, we consider a diffusion equation on an annulus:","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"beginequation\nbeginaligned\npdvu(vb x t)t = grad^2 u(vb x t)  vb x in Omega \ngrad u(vb x t) vdot vu n(vb x) = 0  vb x in mathcal D(0 1) \nu(vb x t) = c(t)  vb x in mathcal D(002) \nu(vb x t) = u_0(vb x)\nendaligned\nendequation","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"demonstrating how we can solve PDEs over multiply-connected domains. Here, mathcal D(0 r) is a circle of radius r centred at the origin, Omega is the annulus between mathcal D(002) and mathcal D(0 1), c(t) = 501-mathrme^-t2, and","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"u_0(x) = 10mathrme^-25leftleft(x+frac12right)^2+left(y+frac12right)^2right - 10mathrme^-45leftleft(x-frac12right)^2+left(y-frac12right)^2right - 5mathrme^-50leftleft(x+frac310right)^2+left(y+frac12right)^2right","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"The complicated task for this problem is the definition of the mesh of the annulus. We need to follow the boundary specification from DelaunayTriangulation.jl, discussed here. In particular, the outer boundary must be counter-clockwise, the inner boundary be clockwise, and we need to provide the nodes as a Vector{Vector{Vector{Int}}}. We define this mesh below.","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"using DelaunayTriangulation, FiniteVolumeMethod, CairoMakie\nR₁ = 0.2\nR₂ = 1.0\nθ = collect(LinRange(0, 2π, 100))\nθ[end] = 0.0 # get the endpoints to match\nx = [\n    [R₂ .* cos.(θ)], # outer first\n    [reverse(R₁ .* cos.(θ))] # then inner - reverse to get clockwise orientation\n]\ny = [\n    [R₂ .* sin.(θ)], #\n    [reverse(R₁ .* sin.(θ))]\n]\nboundary_nodes, points = convert_boundary_points_to_indices(x, y)\ntri = triangulate(points; boundary_nodes)\nA = get_total_area(tri)\nrefine!(tri; max_area=1e-4A)\ntriplot(tri)","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"mesh = FVMGeometry(tri)","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"Now let us define the boundary conditions. Remember, the order of the boundary conditions follows the order of the boundaries in the mesh. The outer boundary came first, and then came the inner boundary. We can verify that this is the order of the boundary indices as follows:","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"fig = Figure()\nax = Axis(fig[1, 1])\nouter = [get_point(tri, i) for i in get_neighbours(tri, -1)]\ninner = [get_point(tri, i) for i in get_neighbours(tri, -2)]\ntriplot!(ax, tri)\nscatter!(ax, outer, color=:red)\nscatter!(ax, inner, color=:blue)\nfig","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"So, the boundary conditions are:","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"outer_bc = (x, y, t, u, p) -> zero(u)\ninner_bc = (x, y, t, u, p) -> oftype(u, 50(1 - exp(-t / 2)))\ntypes = (Neumann, Dirichlet)\nBCs = BoundaryConditions(mesh, (outer_bc, inner_bc), types)","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"Finally, let's define the problem and solve it.","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"initial_condition_f = (x, y) -> begin\n    10 * exp(-25 * ((x + 0.5) * (x + 0.5) + (y + 0.5) * (y + 0.5))) - 5 * exp(-50 * ((x + 0.3) * (x + 0.3) + (y + 0.5) * (y + 0.5))) - 10 * exp(-45 * ((x - 0.5) * (x - 0.5) + (y - 0.5) * (y - 0.5)))\nend\ndiffusion_function = (x, y, t, u, p) -> one(u)\ninitial_condition = [initial_condition_f(x, y) for (x, y) in each_point(tri)]\nfinal_time = 2.0\nprob = FVMProblem(mesh, BCs;\n    diffusion_function,\n    final_time,\n    initial_condition)","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"using OrdinaryDiffEq, LinearSolve\nsol = solve(prob, TRBDF2(linsolve=KLUFactorization()), saveat=0.2)","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"fig = Figure(fontsize=38)\nfor (i, j) in zip(1:3, (1, 6, 11))\n    ax = Axis(fig[1, i], width=600, height=600,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[j])\",\n        titlealign=:left)\n    tricontourf!(ax, tri, sol.u[j], levels=-10:2:40, colormap=:matter)\n    tightlimits!(ax)\nend\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"To finish this example, let us consider how natural neighbour interpolation can be applied here. The application is more complicated for this problem since the mesh has holes. Before we do that, though, let us show how we could use pl_interpolate, which could be useful if we did not need a higher quality interpolant. Let us interpolate the solution at t = 1, which is sol.t[6]. For this, we need to put the ghost triangles back into tri so that we can safely apply jump_and_march. This is done with add_ghost_triangles!.","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"add_ghost_triangles!(tri)","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"Now let's interpolate.","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"x = LinRange(-R₂, R₂, 400)\ny = LinRange(-R₂, R₂, 400)\ninterp_vals = zeros(length(x), length(y))\nu = sol.u[6]\nlast_triangle = Ref((1, 1, 1))\nfor (j, _y) in enumerate(y)\n    for (i, _x) in enumerate(x)\n        T = jump_and_march(tri, (_x, _y), try_points=last_triangle[])\n        last_triangle[] = indices(T) # used to accelerate jump_and_march, since the points we're looking for are close to each other\n        if DelaunayTriangulation.is_ghost_triangle(T) # don't extrapolate\n            interp_vals[i, j] = NaN\n        else\n            interp_vals[i, j] = pl_interpolate(prob, T, sol.u[6], _x, _y)\n        end\n    end\nend\nfig, ax, sc = contourf(x, y, interp_vals, levels=-10:2:40, colormap=:matter)\nfig","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"Let's now consider applying NaturalNeighbours.jl. We apply it naively first to highlight some complications.","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"using NaturalNeighbours\n_x = vec([x for x in x, y in y]) # NaturalNeighbours.jl needs vector data\n_y = vec([y for x in x, y in y])\nitp = interpolate(tri, u, derivatives=true)","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"itp_vals = itp(_x, _y; method=Farin())","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"fig, ax, sc = contourf(x, y, reshape(itp_vals, length(x), length(y)), colormap=:matter, levels=-10:2:40)\nfig","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"The issue here is that the interpolant is trying to extrapolate inside the hole and outside of the annulus. To avoid this, you need to pass project=false.","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"itp_vals = itp(_x, _y; method=Farin(), project=false)","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"fig, ax, sc = contourf(x, y, reshape(itp_vals, length(x), length(y)), colormap=:matter, levels=-10:2:40)\nfig","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/#Just-the-code","page":"Diffusion Equation on an Annulus","title":"Just the code","text":"","category":"section"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"using DelaunayTriangulation, FiniteVolumeMethod, CairoMakie\nR₁ = 0.2\nR₂ = 1.0\nθ = collect(LinRange(0, 2π, 100))\nθ[end] = 0.0 # get the endpoints to match\nx = [\n    [R₂ .* cos.(θ)], # outer first\n    [reverse(R₁ .* cos.(θ))] # then inner - reverse to get clockwise orientation\n]\ny = [\n    [R₂ .* sin.(θ)], #\n    [reverse(R₁ .* sin.(θ))]\n]\nboundary_nodes, points = convert_boundary_points_to_indices(x, y)\ntri = triangulate(points; boundary_nodes)\nA = get_total_area(tri)\nrefine!(tri; max_area=1e-4A)\ntriplot(tri)\n\nmesh = FVMGeometry(tri)\n\nfig = Figure()\nax = Axis(fig[1, 1])\nouter = [get_point(tri, i) for i in get_neighbours(tri, -1)]\ninner = [get_point(tri, i) for i in get_neighbours(tri, -2)]\ntriplot!(ax, tri)\nscatter!(ax, outer, color=:red)\nscatter!(ax, inner, color=:blue)\nfig\n\nouter_bc = (x, y, t, u, p) -> zero(u)\ninner_bc = (x, y, t, u, p) -> oftype(u, 50(1 - exp(-t / 2)))\ntypes = (Neumann, Dirichlet)\nBCs = BoundaryConditions(mesh, (outer_bc, inner_bc), types)\n\ninitial_condition_f = (x, y) -> begin\n    10 * exp(-25 * ((x + 0.5) * (x + 0.5) + (y + 0.5) * (y + 0.5))) - 5 * exp(-50 * ((x + 0.3) * (x + 0.3) + (y + 0.5) * (y + 0.5))) - 10 * exp(-45 * ((x - 0.5) * (x - 0.5) + (y - 0.5) * (y - 0.5)))\nend\ndiffusion_function = (x, y, t, u, p) -> one(u)\ninitial_condition = [initial_condition_f(x, y) for (x, y) in each_point(tri)]\nfinal_time = 2.0\nprob = FVMProblem(mesh, BCs;\n    diffusion_function,\n    final_time,\n    initial_condition)\n\nusing OrdinaryDiffEq, LinearSolve\nsol = solve(prob, TRBDF2(linsolve=KLUFactorization()), saveat=0.2)\n\nfig = Figure(fontsize=38)\nfor (i, j) in zip(1:3, (1, 6, 11))\n    ax = Axis(fig[1, i], width=600, height=600,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[j])\",\n        titlealign=:left)\n    tricontourf!(ax, tri, sol.u[j], levels=-10:2:40, colormap=:matter)\n    tightlimits!(ax)\nend\nresize_to_layout!(fig)\nfig\n\nadd_ghost_triangles!(tri)\n\nx = LinRange(-R₂, R₂, 400)\ny = LinRange(-R₂, R₂, 400)\ninterp_vals = zeros(length(x), length(y))\nu = sol.u[6]\nlast_triangle = Ref((1, 1, 1))\nfor (j, _y) in enumerate(y)\n    for (i, _x) in enumerate(x)\n        T = jump_and_march(tri, (_x, _y), try_points=last_triangle[])\n        last_triangle[] = indices(T) # used to accelerate jump_and_march, since the points we're looking for are close to each other\n        if DelaunayTriangulation.is_ghost_triangle(T) # don't extrapolate\n            interp_vals[i, j] = NaN\n        else\n            interp_vals[i, j] = pl_interpolate(prob, T, sol.u[6], _x, _y)\n        end\n    end\nend\nfig, ax, sc = contourf(x, y, interp_vals, levels=-10:2:40, colormap=:matter)\nfig\n\nusing NaturalNeighbours\n_x = vec([x for x in x, y in y]) # NaturalNeighbours.jl needs vector data\n_y = vec([y for x in x, y in y])\nitp = interpolate(tri, u, derivatives=true)\n\nitp_vals = itp(_x, _y; method=Farin())\n\nfig, ax, sc = contourf(x, y, reshape(itp_vals, length(x), length(y)), colormap=:matter, levels=-10:2:40)\nfig\n\nitp_vals = itp(_x, _y; method=Farin(), project=false)\n\nfig, ax, sc = contourf(x, y, reshape(itp_vals, length(x), length(y)), colormap=:matter, levels=-10:2:40)\nfig","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"","category":"page"},{"location":"tutorials/diffusion_equation_on_an_annulus/","page":"Diffusion Equation on an Annulus","title":"Diffusion Equation on an Annulus","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"EditURL = \"https://github.com/DanielVandH/FiniteVolumeMethod.jl/tree/main/docs/src/literate_tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions.jl\"","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/#Helmholtz-Equation-with-Inhomogeneous-Boundary-Conditions","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"","category":"section"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"In this tutorial, we consider the following steady state problem:","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"beginequation\nbeginaligned\ngrad^2 u(vb x) + u(vb x) = 0  vb x in -1 1^2 \npdvuvb n = 1  vb x inpartial-11^2\nendaligned\nendequation","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"We can define this problem in the same way we have defined previous problems, except that the final FVMProblem must be wrapped in a SteadyFVMProblem. Let us start by defining the mesh and the boundary conditions.","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"using DelaunayTriangulation, FiniteVolumeMethod\ntri = triangulate_rectangle(-1, 1, -1, 1, 125, 125, single_boundary=true)\nmesh = FVMGeometry(tri)","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"For the boundary condition,","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"pdvuvb n = 1","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"which is the same as grad u vdot vu n = 1, this needs to be expressed in terms of vb q. Since vb q = -grad u for this problem, the boundary condition is vb q vdot vu n = -1.","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"BCs = BoundaryConditions(mesh, (x, y, t, u, p) -> -one(u), Neumann)","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"To now define the problem, we note that the initial_condition and final_time fields have different interpretations for steady state problems. The initial_condition now serves as an initial estimate for the steady state solution, which is needed for the nonlinear solver, and final_time should now be Inf. For the initial condition, let us simply let the initial estimate be all zeros. For the diffusion and source terms, note that previously we have been considered equations of the form","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"pdvut + divvb q = S quad textnormalor quad pdvut = divDgrad u + S","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"while steady state problems take the form","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"divvb q = S quad textnormalor quad divDgrad u + S = 0","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"So, for this problem, D = 1 and S = u.","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"diffusion_function = (x, y, t, u, p) -> one(u)\nsource_function = (x, y, t, u, p) -> u\ninitial_condition = zeros(num_points(tri))\nfinal_time = Inf\nprob = FVMProblem(mesh, BCs;\n    diffusion_function,\n    source_function,\n    initial_condition,\n    final_time)","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"steady_prob = SteadyFVMProblem(prob)","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"To now solve this problem, we use a Newton-Raphson solver. Alternative solvers, such as DynamicSS(TRBDF2(linsolve=KLUFactorization()), reltol=1e-4) from SteadyStateDiffEq can also be used. A good method could be to use a simple solver, like NewtonRaphson(), and then use that solution as the initial guess in a finer algorithm like the DynamicSS algorithm above.","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"using NonlinearSolve\nsol = solve(steady_prob, NewtonRaphson())\ncopyto!(prob.initial_condition, sol.u) # this also changes steady_prob's initial condition\nusing SteadyStateDiffEq, LinearSolve, OrdinaryDiffEq\nsol = solve(steady_prob, DynamicSS(TRBDF2(linsolve=KLUFactorization())))","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"For this problem, this correction by DynamicSS doesn't seem to actually be needed. Now let's visualise.","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"using CairoMakie\nfig, ax, sc = tricontourf(tri, sol.u, levels=-2.5:0.15:-1.0, colormap=:matter)\nfig","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/#Just-the-code","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Just the code","text":"","category":"section"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"using DelaunayTriangulation, FiniteVolumeMethod\ntri = triangulate_rectangle(-1, 1, -1, 1, 125, 125, single_boundary=true)\nmesh = FVMGeometry(tri)\n\nBCs = BoundaryConditions(mesh, (x, y, t, u, p) -> -one(u), Neumann)\n\ndiffusion_function = (x, y, t, u, p) -> one(u)\nsource_function = (x, y, t, u, p) -> u\ninitial_condition = zeros(num_points(tri))\nfinal_time = Inf\nprob = FVMProblem(mesh, BCs;\n    diffusion_function,\n    source_function,\n    initial_condition,\n    final_time)\n\nsteady_prob = SteadyFVMProblem(prob)\n\nusing NonlinearSolve\nsol = solve(steady_prob, NewtonRaphson())\ncopyto!(prob.initial_condition, sol.u) # this also changes steady_prob's initial condition\nusing SteadyStateDiffEq, LinearSolve, OrdinaryDiffEq\nsol = solve(steady_prob, DynamicSS(TRBDF2(linsolve=KLUFactorization())))\n\nusing CairoMakie\nfig, ax, sc = tricontourf(tri, sol.u, levels=-2.5:0.15:-1.0, colormap=:matter)\nfig","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"","category":"page"},{"location":"tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/","page":"Helmholtz Equation with Inhomogeneous Boundary Conditions","title":"Helmholtz Equation with Inhomogeneous Boundary Conditions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"EditURL = \"https://github.com/DanielVandH/FiniteVolumeMethod.jl/tree/main/docs/src/literate_tutorials/solving_mazes_with_laplaces_equation.jl\"","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/#Solving-Mazes-with-Laplace's-Equation","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"","category":"section"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"In this tutorial, we consider solving mazes using Laplace's equation, applying the result of Conolly, Burns, and Weis (1990). In particular, given a maze mathcal M, represented as a collection of edges together with some starting point mathcal S_1 and an endpoint mathcal S_2, Laplace's equation can be used to find the solution:","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"beginequation\nbeginaligned\ngrad^2 phi = 0  vb x in mathcal M \nphi = 0  vb x in mathcal S_1 \nphi = 1  vb x in mathcal S_2 \ngradphivdotvu n = 0  vb x in partial M setminus (mathcal S_1 cup mathcal S_2)\nendaligned\nendequation","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"The gradient gradphi will reveal the solution to the maze.  We just look at gradphi for revealing this solution, although other methods could e.g. use gradphi to follow the associated streamlines.","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"Here is what the maze looks like, where the start is in blue and the end is in red.","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"using DelaunayTriangulation, CairoMakie, DelimitedFiles\nA = readdlm(joinpath(@__DIR__, \"../tutorials/maze.txt\"))\nA = unique(A, dims=1)\nx = A[1:10:end, 2] # downsample to make the problem faster\ny = A[1:10:end, 1]\nstart = findall(y .== 648)\nfinish = findall(y .== 5)\nstart_idx_init, start_idx_end = extrema(start)\nfinish_idx_init, finish_idx_end = extrema(finish)\nx_start = x[start]\ny_start = y[start]\nx_start_to_finish = [x[start_idx_end:end]; x[begin:finish_idx_init]]\ny_start_to_finish = [y[start_idx_end:end]; y[begin:finish_idx_init]]\nx_finish = x[finish]\ny_finish = y[finish]\nx_finish_to_start = x[finish_idx_end:start_idx_init]\ny_finish_to_start = y[finish_idx_end:start_idx_init]\nx_bnd = [x_start, x_start_to_finish, x_finish, x_finish_to_start]\ny_bnd = [y_start, y_start_to_finish, y_finish, y_finish_to_start]\nboundary_nodes, points = convert_boundary_points_to_indices(x_bnd, y_bnd)\ntri = triangulate(points; boundary_nodes, recompute_representative_point=false) # takes a while because maze.txt contains so many points\nrefine!(tri)\n\nfig, ax, sc, = triplot(tri,\n    show_convex_hull=false,\n    show_constrained_edges=false)\nlines!(ax, [get_point(tri, get_boundary_nodes(tri, 1)...)...], color=:blue, linewidth=6)\nlines!(ax, [get_point(tri, get_boundary_nodes(tri, 3)...)...], color=:red, linewidth=6)\nfig","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"Now we can solve the problem.","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"using FiniteVolumeMethod, StableRNGs\nmesh = FVMGeometry(tri)\nstart_bc = (x, y, t, u, p) -> zero(u)\nstart_to_finish_bc = (x, y, t, u, p) -> zero(u)\nfinish_bc = (x, y, t, u, p) -> one(u)\nfinish_to_start_bc = (x, y, t, u, p) -> zero(u)\nfncs = (start_bc, start_to_finish_bc, finish_bc, finish_to_start_bc)\ntypes = (Dirichlet, Neumann, Dirichlet, Neumann)\nBCs = BoundaryConditions(mesh, fncs, types)\ndiffusion_function = (x, y, t, u, p) -> one(u)\ninitial_condition = 0.05randn(StableRNG(123), num_points(tri)) # random initial condition - this is the initial guess for the solution\nfinal_time = Inf\nprob = FVMProblem(mesh, BCs;\n    diffusion_function=diffusion_function,\n    initial_condition=initial_condition,\n    final_time=final_time)\nsteady_prob = SteadyFVMProblem(prob)","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"using SteadyStateDiffEq, LinearSolve, OrdinaryDiffEq\nsol = solve(steady_prob, DynamicSS(TRBDF2(linsolve=KLUFactorization()), abstol=1e-14, reltol=1e-14))","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"We now have our solution.","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"tricontourf(tri, sol.u, colormap=:matter)","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"This is not what we use to compute the solution to the maze, instead we need gradphi. We compute the gradient at each point using NaturalNeighbours.jl.","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"using NaturalNeighbours, LinearAlgebra\nitp = interpolate(tri, sol.u; derivatives=true)\n∇ = NaturalNeighbours.get_gradient(itp)\n∇norms = norm.(∇)\ntricontourf(tri, ∇norms, colormap=:matter)","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"The solution to the maze is now extremely clear from this plot!","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"An alternative way to look at this solution is to consider the transient problem, where we do not solve the steady state problem and instead view the solution over time.","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"using Accessors\nprob = @set prob.final_time = 1e8\nLogRange(a, b, n) = exp10.(LinRange(log10(a), log10(b), n))\nsol = solve(prob, TRBDF2(linsolve=KLUFactorization()), saveat=LogRange(1e2, prob.final_time, 24 * 10))\nall_∇norms = map(sol.u) do u\n    itp = interpolate(tri, u; derivatives=true)\n    ∇ = NaturalNeighbours.get_gradient(itp)\n    norm.(∇)\nend\ni = Observable(1)\n∇norms = map(i -> all_∇norms[i], i)\nfig, ax, sc = tricontourf(tri, ∇norms, colormap=:matter, levels=LinRange(0, 0.0035, 25), extendlow=:auto, extendhigh=:auto)\nhidedecorations!(ax)\ntightlimits!(ax)\nrecord(fig, joinpath(@__DIR__, \"../figures\", \"maze_solution_1.mp4\"), eachindex(sol);\n    framerate=24) do _i\n    i[] = _i\nend;\nnothing #hide","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"(Image: Animation of the solution of the maze)","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/#Just-the-code","page":"Solving Mazes with Laplace's Equation","title":"Just the code","text":"","category":"section"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"using DelaunayTriangulation, CairoMakie, DelimitedFiles\nA = readdlm(joinpath(@__DIR__, \"../tutorials/maze.txt\"))\nA = unique(A, dims=1)\nx = A[1:10:end, 2] # downsample to make the problem faster\ny = A[1:10:end, 1]\nstart = findall(y .== 648)\nfinish = findall(y .== 5)\nstart_idx_init, start_idx_end = extrema(start)\nfinish_idx_init, finish_idx_end = extrema(finish)\nx_start = x[start]\ny_start = y[start]\nx_start_to_finish = [x[start_idx_end:end]; x[begin:finish_idx_init]]\ny_start_to_finish = [y[start_idx_end:end]; y[begin:finish_idx_init]]\nx_finish = x[finish]\ny_finish = y[finish]\nx_finish_to_start = x[finish_idx_end:start_idx_init]\ny_finish_to_start = y[finish_idx_end:start_idx_init]\nx_bnd = [x_start, x_start_to_finish, x_finish, x_finish_to_start]\ny_bnd = [y_start, y_start_to_finish, y_finish, y_finish_to_start]\nboundary_nodes, points = convert_boundary_points_to_indices(x_bnd, y_bnd)\ntri = triangulate(points; boundary_nodes, recompute_representative_point=false) # takes a while because maze.txt contains so many points\nrefine!(tri)\n\nfig, ax, sc, = triplot(tri,\n    show_convex_hull=false,\n    show_constrained_edges=false)\nlines!(ax, [get_point(tri, get_boundary_nodes(tri, 1)...)...], color=:blue, linewidth=6)\nlines!(ax, [get_point(tri, get_boundary_nodes(tri, 3)...)...], color=:red, linewidth=6)\nfig\n\nusing FiniteVolumeMethod, StableRNGs\nmesh = FVMGeometry(tri)\nstart_bc = (x, y, t, u, p) -> zero(u)\nstart_to_finish_bc = (x, y, t, u, p) -> zero(u)\nfinish_bc = (x, y, t, u, p) -> one(u)\nfinish_to_start_bc = (x, y, t, u, p) -> zero(u)\nfncs = (start_bc, start_to_finish_bc, finish_bc, finish_to_start_bc)\ntypes = (Dirichlet, Neumann, Dirichlet, Neumann)\nBCs = BoundaryConditions(mesh, fncs, types)\ndiffusion_function = (x, y, t, u, p) -> one(u)\ninitial_condition = 0.05randn(StableRNG(123), num_points(tri)) # random initial condition - this is the initial guess for the solution\nfinal_time = Inf\nprob = FVMProblem(mesh, BCs;\n    diffusion_function=diffusion_function,\n    initial_condition=initial_condition,\n    final_time=final_time)\nsteady_prob = SteadyFVMProblem(prob)\n\nusing SteadyStateDiffEq, LinearSolve, OrdinaryDiffEq\nsol = solve(steady_prob, DynamicSS(TRBDF2(linsolve=KLUFactorization()), abstol=1e-14, reltol=1e-14))\n\ntricontourf(tri, sol.u, colormap=:matter)\n\nusing NaturalNeighbours, LinearAlgebra\nitp = interpolate(tri, sol.u; derivatives=true)\n∇ = NaturalNeighbours.get_gradient(itp)\n∇norms = norm.(∇)\ntricontourf(tri, ∇norms, colormap=:matter)\n\nusing Accessors\nprob = @set prob.final_time = 1e8\nLogRange(a, b, n) = exp10.(LinRange(log10(a), log10(b), n))\nsol = solve(prob, TRBDF2(linsolve=KLUFactorization()), saveat=LogRange(1e2, prob.final_time, 24 * 10))\nall_∇norms = map(sol.u) do u\n    itp = interpolate(tri, u; derivatives=true)\n    ∇ = NaturalNeighbours.get_gradient(itp)\n    norm.(∇)\nend\ni = Observable(1)\n∇norms = map(i -> all_∇norms[i], i)\nfig, ax, sc = tricontourf(tri, ∇norms, colormap=:matter, levels=LinRange(0, 0.0035, 25), extendlow=:auto, extendhigh=:auto)\nhidedecorations!(ax)\ntightlimits!(ax)\nrecord(fig, joinpath(@__DIR__, \"../figures\", \"maze_solution_1.mp4\"), eachindex(sol);\n    framerate=24) do _i\n    i[] = _i\nend;","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"","category":"page"},{"location":"tutorials/solving_mazes_with_laplaces_equation/","page":"Solving Mazes with Laplace's Equation","title":"Solving Mazes with Laplace's Equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"EditURL = \"https://github.com/DanielVandH/FiniteVolumeMethod.jl/tree/main/docs/src/literate_tutorials/reaction_diffusion_brusselator_system_of_pdes.jl\"","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/#A-Reaction-Diffusion-Brusselator-System-of-PDEs","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"","category":"section"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"In this tutorial, we show how we can solve systems of PDEs. We consider the reaction-diffusion Brusselator system:","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"beginequationlabeleqbrusleeq\nbeginaligned\npdvPhit = frac14grad^2 Phi + Phi^2Psi - 2Phi  vb x in 0 1^2 \npdvPsit = frac14grad^2 Psi - Phi^2Psi + Phi  vb x in 0 1^2\nendaligned\nendequation","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"Since this is a somewhat contrived example, we will be using the exact solution to define sensible initial and boundary conditions:[1]","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"beginequationlabeleqbrusleexct\nbeginaligned\nPhi(x y t) =exp(-x-y-t2) \nPsi(x y t) = exp(x+y+t2)\nendaligned\nendequation","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"[1]: See Islam, Ali, and Haq (2010).","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"We can use these exact solutions \\eqref{eq:brusleexct} to also show how we can mix boundary conditions. We use:","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"beginequation*\nbeginaligned\nPhi(x y 0) = exp(-x-y) \nPsi(x y 0) = exp(x + y) \npdvPhiy = -exp(-x-t2)  y = 0 6pt\nPsi = exp(x + t2)  y = 0 \npdvPhix = -exp(-1-y-t2)  x=1 6pt\npdvPsix = exp(1 + y+ t2)  x=1 6pt\nPhi = exp(-1-x-t2)  y=1 \npdvPsiy = exp(1 + x + t2)  y=1 6pt\npdvPhix = -exp(-y-t2)  x=0 6pt\nPsi = exp(y + t2)  x=0\nendaligned\nendequation*","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"For implementing these equations, we need to write the Neumann boundary conditions in the forms vb q_1 vdot vu n = f(vb x t) and vb q_2 vdot vu n = f(vb x t), where vb q_1 and vb q_2 are the fluxes for Phi and Psi, respectively. So, we need to rewrite \\eqref{eq:brusleeq} in the conservation form; previously, we've also allowed for reaction-diffusion formulations, but unfortunately we do not allow this specification for systems due to some technical limitations. We can write \\eqref{eq:brusleeq} in the conservation form as follows:","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"beginequation\nbeginaligned\npdvPhit + divvb q_1 = S_1 \npdvPsit + divvb q_2 = S_2\nendaligned\nendequation","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"where vb q_1 = -gradPhi4, S_1 = Phi^2Psi - 2Phi, vb q_2 = -gradPsi4, and S_2 = -Phi^2Psi + Phi. Now that we have these flux functions, let us rewrite our boundary conditions. Remember that vu n is the outward unit normal, so for example on the bottom boundary we have","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"vb q_1 vdot vu n = -frac14gradPhi vdot -vu j = frac14pdvPhiy","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"The normal vectors are -vu j, vu i, vu j, and -vu i for the bottom, right, top, and left sides of the square, respectively. So, our boundary become:","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"beginequation*\nbeginaligned\nPhi(x y 0) = exp(-x-y) \nPsi(x y 0) = exp(x + y) \nvb q_1 vdot vu n = -frac14exp(-x-t2)  y = 0 6pt\nPsi = exp(x + t2)  y = 0 \nvb q_1 vdot vu n = frac14exp(-1-y-t2)   x=1 6pt\nvb q_2 vdot vu n = -frac14exp(1 + y+ t2)  x=1 6pt\nPhi = exp(-1-x-t2)  y=1 \nvb q_2 vdot vu n = -frac14exp(1 + x + t2)  y=1 6pt\nvb q_1 vdot vu n = -frac14exp(-y-t2)  x=0 6pt\nPsi = exp(y + t2)  x=0\nendaligned\nendequation*","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"using FiniteVolumeMethod, DelaunayTriangulation\ntri = triangulate_rectangle(0, 1, 0, 1, 100, 100, single_boundary=false)\nmesh = FVMGeometry(tri)","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"Now we define the boundary conditions. When considering a system of PDEs, you need to define the boundary conditions for each variable separately. The signatures are the same, namely (x, y, t, u, p) -> Number, except now u is a vector (or Tuple) of the solution values for each variable instead of just a scalar. This last point is not relevant here, but you do need to know about it for other problems more generally. So, let us now define the boundary conditions. First, for Phi:","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"Φ_bot = (x, y, t, u, p) -> -1 / 4 * exp(-x - t / 2)\nΦ_right = (x, y, t, u, p) -> 1 / 4 * exp(-1 - y - t / 2)\nΦ_top = (x, y, t, u, p) -> exp(-1 - x - t / 2)\nΦ_left = (x, y, t, u, p) -> -1 / 4 * exp(-y - t / 2)\nΦ_bc_fncs = (Φ_bot, Φ_right, Φ_top, Φ_left)\nΦ_bc_types = (Neumann, Neumann, Dirichlet, Neumann)\nΦ_BCs = BoundaryConditions(mesh, Φ_bc_fncs, Φ_bc_types)","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"Now, for Psi:","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"Ψ_bot = (x, y, t, u, p) -> exp(x + t / 2)\nΨ_right = (x, y, t, u, p) -> -1 / 4 * exp(1 + y + t / 2)\nΨ_top = (x, y, t, u, p) -> -1 / 4 * exp(1 + x + t / 2)\nΨ_left = (x, y, t, u, p) -> exp(y + t / 2)\nΨ_bc_fncs = (Ψ_bot, Ψ_right, Ψ_top, Ψ_left)\nΨ_bc_types = (Dirichlet, Neumann, Neumann, Dirichlet)\nΨ_BCs = BoundaryConditions(mesh, Ψ_bc_fncs, Ψ_bc_types)","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"Now we need to define the actual problems. Let us first define the flux and source functions, remembering that the variables get replaced with linear approximants. The flux functions also now take Tuples for alpha, beta, and gamma, where the ith element of the Tuple refers to the ith variable. Similarly, the source function takes a Tuple of the variables in the u argument.","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"Φ_q = (x, y, t, α, β, γ, p) -> (-α[1] / 4, -β[1] / 4)\nΨ_q = (x, y, t, α, β, γ, p) -> (-α[2] / 4, -β[2] / 4)\nΦ_S = (x, y, t, (Φ, Ψ), p) -> Φ^2 * Ψ - 2Φ\nΨ_S = (x, y, t, (Φ, Ψ), p) -> -Φ^2 * Ψ + Φ","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"Now we define the initial conditions.","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"Φ_exact = (x, y, t) -> exp(-x - y - t / 2)\nΨ_exact = (x, y, t) -> exp(x + y + t / 2)\nΦ₀ = [Φ_exact(x, y, 0) for (x, y) in each_point(tri)]\nΨ₀ = [Ψ_exact(x, y, 0) for (x, y) in each_point(tri)]","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"Next, we can define the FVMProblems for each variable.","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"Φ_prob = FVMProblem(mesh, Φ_BCs; flux_function=Φ_q, source_function=Φ_S,\n    initial_condition=Φ₀, final_time=5.0)","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"Ψ_prob = FVMProblem(mesh, Ψ_BCs; flux_function=Ψ_q, source_function=Ψ_S,\n    initial_condition=Ψ₀, final_time=5.0)","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"Finally, the FVMSystem is constructed by these two problems:","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"system = FVMSystem(Φ_prob, Ψ_prob)","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"We can now solve the problem just as we've done previously.","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"using OrdinaryDiffEq, LinearSolve\nsol = solve(system, TRBDF2(linsolve=KLUFactorization()), saveat=1.0)","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"For this solution, note that the u values are matrices. For example:","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"sol.u[3]","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"The ith row is the ith variable, so","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"sol.u[3][1, :]","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"are the value of Phi at the third time, and similarly sol.u[3][2, :] are the values of Psi at the third time. We can visualise the solutions as follows:","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"using CairoMakie\nfig = Figure(fontsize=38)\nfor i in eachindex(sol)\n    ax1 = Axis(fig[1, i], xlabel=L\"x\", ylabel=L\"y\",\n        width=400, height=400,\n        title=L\"\\Phi: t = %$(sol.t[i])\", titlealign=:left)\n    ax2 = Axis(fig[2, i], xlabel=L\"x\", ylabel=L\"y\",\n        width=400, height=400,\n        title=L\"\\Psi: t = %$(sol.t[i])\", titlealign=:left)\n    tricontourf!(ax1, tri, sol[i][1, :], levels=0:0.1:1, colormap=:matter)\n    tricontourf!(ax2, tri, sol[i][2, :], levels=1:10:100, colormap=:matter)\nend\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/#Just-the-code","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"Just the code","text":"","category":"section"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"using FiniteVolumeMethod, DelaunayTriangulation\ntri = triangulate_rectangle(0, 1, 0, 1, 100, 100, single_boundary=false)\nmesh = FVMGeometry(tri)\n\nΦ_bot = (x, y, t, u, p) -> -1 / 4 * exp(-x - t / 2)\nΦ_right = (x, y, t, u, p) -> 1 / 4 * exp(-1 - y - t / 2)\nΦ_top = (x, y, t, u, p) -> exp(-1 - x - t / 2)\nΦ_left = (x, y, t, u, p) -> -1 / 4 * exp(-y - t / 2)\nΦ_bc_fncs = (Φ_bot, Φ_right, Φ_top, Φ_left)\nΦ_bc_types = (Neumann, Neumann, Dirichlet, Neumann)\nΦ_BCs = BoundaryConditions(mesh, Φ_bc_fncs, Φ_bc_types)\n\nΨ_bot = (x, y, t, u, p) -> exp(x + t / 2)\nΨ_right = (x, y, t, u, p) -> -1 / 4 * exp(1 + y + t / 2)\nΨ_top = (x, y, t, u, p) -> -1 / 4 * exp(1 + x + t / 2)\nΨ_left = (x, y, t, u, p) -> exp(y + t / 2)\nΨ_bc_fncs = (Ψ_bot, Ψ_right, Ψ_top, Ψ_left)\nΨ_bc_types = (Dirichlet, Neumann, Neumann, Dirichlet)\nΨ_BCs = BoundaryConditions(mesh, Ψ_bc_fncs, Ψ_bc_types)\n\nΦ_q = (x, y, t, α, β, γ, p) -> (-α[1] / 4, -β[1] / 4)\nΨ_q = (x, y, t, α, β, γ, p) -> (-α[2] / 4, -β[2] / 4)\nΦ_S = (x, y, t, (Φ, Ψ), p) -> Φ^2 * Ψ - 2Φ\nΨ_S = (x, y, t, (Φ, Ψ), p) -> -Φ^2 * Ψ + Φ\n\nΦ_exact = (x, y, t) -> exp(-x - y - t / 2)\nΨ_exact = (x, y, t) -> exp(x + y + t / 2)\nΦ₀ = [Φ_exact(x, y, 0) for (x, y) in each_point(tri)]\nΨ₀ = [Ψ_exact(x, y, 0) for (x, y) in each_point(tri)]\n\nΦ_prob = FVMProblem(mesh, Φ_BCs; flux_function=Φ_q, source_function=Φ_S,\n    initial_condition=Φ₀, final_time=5.0)\n\nΨ_prob = FVMProblem(mesh, Ψ_BCs; flux_function=Ψ_q, source_function=Ψ_S,\n    initial_condition=Ψ₀, final_time=5.0)\n\nsystem = FVMSystem(Φ_prob, Ψ_prob)\n\nusing OrdinaryDiffEq, LinearSolve\nsol = solve(system, TRBDF2(linsolve=KLUFactorization()), saveat=1.0)\n\nsol.u[3]\n\nsol.u[3][1, :]\n\nusing CairoMakie\nfig = Figure(fontsize=38)\nfor i in eachindex(sol)\n    ax1 = Axis(fig[1, i], xlabel=L\"x\", ylabel=L\"y\",\n        width=400, height=400,\n        title=L\"\\Phi: t = %$(sol.t[i])\", titlealign=:left)\n    ax2 = Axis(fig[2, i], xlabel=L\"x\", ylabel=L\"y\",\n        width=400, height=400,\n        title=L\"\\Psi: t = %$(sol.t[i])\", titlealign=:left)\n    tricontourf!(ax1, tri, sol[i][1, :], levels=0:0.1:1, colormap=:matter)\n    tricontourf!(ax2, tri, sol[i][2, :], levels=1:10:100, colormap=:matter)\nend\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"","category":"page"},{"location":"tutorials/reaction_diffusion_brusselator_system_of_pdes/","page":"A Reaction-Diffusion Brusselator System of PDEs","title":"A Reaction-Diffusion Brusselator System of PDEs","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"CurrentModule = FiniteVolumeMethod","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This is the documentation for FiniteVolumeMethod.jl. Click here to go back to the GitHub repository.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This is a Julia package for solving partial differential equations (PDEs) of the form","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pdvu(vb x t)t + div vb q(vb x t u) = S(vb x t u) quad (x y)^mkern-15mumathsfT in Omega subset mathbb R^2t0","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using the finite volume method, with additional support for steady-state problems and for systems of PDEs of the above form. We support Neumann, Dirichlet, and boundary conditions on mathrm dumathrm dt, as well as internal conditions and custom constraints. We also provide an interface for solving special cases of the above PDE, namely reaction-diffusion equations","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pdvu(vb x t)t = divleftD(vb x t u)grad u(vb x t)right + S(vb x t u)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The tutorials in the sidebar demonstrate the many possibilities of this package.","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"EditURL = \"https://github.com/DanielVandH/FiniteVolumeMethod.jl/tree/main/docs/src/literate_tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions.jl\"","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/#Diffusion-Equation-in-a-Wedge-with-Mixed-Boundary-Conditions","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"","category":"section"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"In this example, we consider a diffusion equation on a wedge with angle alpha and mixed boundary conditions:","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"beginequation*\nbeginaligned\npdvu(r theta t)t = grad^2u(rthetat)  0r10thetaalphat06pt\npdvu(r 0 t)theta  = 0  0r1t06pt\nu(1 theta t) = 0  0thetaalphat06pt\npdvu(ralphat)theta  = 0  0thetaalphat06pt\nu(r theta 0) = f(rtheta)  0r10thetaalpha\nendaligned\nendequation*","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"where we take f(rtheta) = 1-r and alpha=pi4.","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"Note that the PDE is provided in polar form, but Cartesian coordinates are assumed for the operators in our code. The conversion is easy, noting that the two Neumann conditions are just equations of the form grad u vdot vu n = 0. Moreover, although the right-hand side of the PDE is given as a Laplacian, recall that grad^2 = divgrad, so we can write the PDE as partial upartial t + div vb q = 0, where vb q = -grad u.","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"Let us now setup the problem. To define the geometry, we need to be careful that the Triangulation recognises that we need to split the boundary into three parts, one part for each boundary condition. This is accomplished by providing a single vector for each part of the boundary as follows (and as described in DelaunayTriangulation.jl's documentation), where we also refine! the mesh to get a better mesh.","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"using DelaunayTriangulation, FiniteVolumeMethod, ElasticArrays\nn = 50\nα = π / 4\n# The bottom edge\nx₁ = [0.0, 1.0]\ny₁ = [0.0, 0.0]\n# The arc\nr₂ = fill(1, n)\nθ₂ = LinRange(0, α, n)\nx₂ = @. r₂ * cos(θ₂)\ny₂ = @. r₂ * sin(θ₂)\n# The upper edge\nx₃ = [cos(α), 0.0]\ny₃ = [sin(α), 0.0]\n# Now combine and create the mesh\nx = [x₁, x₂, x₃]\ny = [y₁, y₂, y₃]\nboundary_nodes, points = convert_boundary_points_to_indices(x, y; existing_points=ElasticMatrix{Float64}(undef, 2, 0))\ntri = triangulate(points; boundary_nodes)\nA = get_total_area(tri)\nrefine!(tri; max_area=1e-4A)\nmesh = FVMGeometry(tri)","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"This is the mesh we've constructed.","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"fig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"To confirm that the boundary is now in three parts, see:","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"get_boundary_nodes(tri)","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"We now need to define the boundary conditions. For this, we need to provide Tuples, where the ith element of the Tuples refers to the ith part of the boundary. The boundary conditions are thus:","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"lower_bc = arc_bc = upper_bc = (x, y, t, u, p) -> zero(u)\ntypes = (Neumann, Dirichlet, Neumann)\nBCs = BoundaryConditions(mesh, (lower_bc, arc_bc, upper_bc), types)","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"Now we can define the PDE. We use the reaction-diffusion formulation, specifying the diffusion function as a constant.","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"f = (x, y) -> 1 - sqrt(x^2 + y^2)\nD = (x, y, t, u, p) -> one(u)\ninitial_condition = [f(x, y) for (x, y) in each_point(tri)]\nfinal_time = 0.1\nprob = FVMProblem(mesh, BCs; diffusion_function=D, initial_condition, final_time)","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"If you did want to use the flux formulation, you would need to provide","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"flux = (x, y, t, α, β, γ, p) -> (-α, -β)","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"which replaces u with αx + βy + γ so that we approximate grad u by (alphabeta)^mkern-15mumathsfT, and the negative is needed since vb q = -grad u.","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"We now solve the problem. We provide the solver for this problem. In my experience, I've found that TRBDF2(linsolve=KLUFactorization()) typically has the best performance for these problems.","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"using OrdinaryDiffEq, LinearSolve\nsol = solve(prob, TRBDF2(linsolve=KLUFactorization()), saveat=0.01, parallel=Val(false))","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"using CairoMakie\nfig = Figure(fontsize=38)\nfor (i, j) in zip(1:3, (1, 6, 11))\n    ax = Axis(fig[1, i], width=600, height=600,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[j])\",\n        titlealign=:left)\n    tricontourf!(ax, tri, sol.u[j], levels=0:0.01:1, colormap=:matter)\n    tightlimits!(ax)\nend\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/#Just-the-code","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Just the code","text":"","category":"section"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"using DelaunayTriangulation, FiniteVolumeMethod, ElasticArrays\nn = 50\nα = π / 4\n# The bottom edge\nx₁ = [0.0, 1.0]\ny₁ = [0.0, 0.0]\n# The arc\nr₂ = fill(1, n)\nθ₂ = LinRange(0, α, n)\nx₂ = @. r₂ * cos(θ₂)\ny₂ = @. r₂ * sin(θ₂)\n# The upper edge\nx₃ = [cos(α), 0.0]\ny₃ = [sin(α), 0.0]\n# Now combine and create the mesh\nx = [x₁, x₂, x₃]\ny = [y₁, y₂, y₃]\nboundary_nodes, points = convert_boundary_points_to_indices(x, y; existing_points=ElasticMatrix{Float64}(undef, 2, 0))\ntri = triangulate(points; boundary_nodes)\nA = get_total_area(tri)\nrefine!(tri; max_area=1e-4A)\nmesh = FVMGeometry(tri)\n\nfig, ax, sc = triplot(tri)\nfig\n\nget_boundary_nodes(tri)\n\nlower_bc = arc_bc = upper_bc = (x, y, t, u, p) -> zero(u)\ntypes = (Neumann, Dirichlet, Neumann)\nBCs = BoundaryConditions(mesh, (lower_bc, arc_bc, upper_bc), types)\n\nf = (x, y) -> 1 - sqrt(x^2 + y^2)\nD = (x, y, t, u, p) -> one(u)\ninitial_condition = [f(x, y) for (x, y) in each_point(tri)]\nfinal_time = 0.1\nprob = FVMProblem(mesh, BCs; diffusion_function=D, initial_condition, final_time)\n\nflux = (x, y, t, α, β, γ, p) -> (-α, -β)\n\nusing OrdinaryDiffEq, LinearSolve\nsol = solve(prob, TRBDF2(linsolve=KLUFactorization()), saveat=0.01, parallel=Val(false))\n\nusing CairoMakie\nfig = Figure(fontsize=38)\nfor (i, j) in zip(1:3, (1, 6, 11))\n    ax = Axis(fig[1, i], width=600, height=600,\n        xlabel=\"x\", ylabel=\"y\",\n        title=\"t = $(sol.t[j])\",\n        titlealign=:left)\n    tricontourf!(ax, tri, sol.u[j], levels=0:0.01:1, colormap=:matter)\n    tightlimits!(ax)\nend\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"","category":"page"},{"location":"tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/","page":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","title":"Diffusion Equation in a Wedge with Mixed Boundary Conditions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/keller_segel_chemotaxis/#Keller-Segel-Model-of-Chemotaxis","page":"Keller-Segel Model of Chemotaxis","title":"Keller-Segel Model of Chemotaxis","text":"","category":"section"},{"location":"tutorials/keller_segel_chemotaxis/","page":"Keller-Segel Model of Chemotaxis","title":"Keller-Segel Model of Chemotaxis","text":"In this tutorial, we consider the following Keller-Segel model of chemotaxis:","category":"page"},{"location":"tutorials/keller_segel_chemotaxis/","page":"Keller-Segel Model of Chemotaxis","title":"Keller-Segel Model of Chemotaxis","text":"beginequation*\nbeginaligned\npdvut = grad^2u - div left(fraccu1+u^2grad vright) + u(1-u) \npdvvt = Dgrad^2 v + u - av\nendaligned\nendequation*","category":"page"},{"location":"tutorials/keller_segel_chemotaxis/","page":"Keller-Segel Model of Chemotaxis","title":"Keller-Segel Model of Chemotaxis","text":"inside the square 0 100^2 with homogeneous Neumann boundary conditions. We  start by defining the problem, remembering that we need one problem for each variable u and v.","category":"page"},{"location":"tutorials/keller_segel_chemotaxis/","page":"Keller-Segel Model of Chemotaxis","title":"Keller-Segel Model of Chemotaxis","text":"using FiniteVolumeMethod, DelaunayTriangulation\ntri = triangulate_rectangle(0, 100, 0, 100, 250, 250, single_boundary=true)\nmesh = FVMGeometry(tri)\nbc_u = (x, y, t, (u, v), p) -> zero(u)\nbc_v = (x, y, t, (u, v), p) -> zero(v)\nBCs_u = BoundaryConditions(mesh, bc_u, Neumann)\nBCs_v = BoundaryConditions(mesh, bc_v, Neumann)\nq_u = (x, y, t, (αu, αv), (βu, βv), (γu, γv), p) -> begin\n    u = αu * x + βu * y + γu\n    ∇u = (αu, βu)\n    ∇v = (αv, βv)\n    χu = p.c * u / (1 + u^2)\n    _q = χu .* ∇v .- ∇u\n    return _q\nend\nq_v = (x, y, t, (αu, αv), (βu, βv), (γu, γv), p) -> begin\n    ∇v = (αv, βv)\n    _q = -p.D .* ∇v\n    return _q\nend\nS_u = (x, y, t, (u, v), p) -> begin\n    return u * (1 - u)\nend\nS_v = (x, y, t, (u, v), p) -> begin\n    return u - p.a * v\nend\nq_u_parameters = (c=4.0,)\nq_v_parameters = (D=1.0,)\nS_v_parameters = (a=0.1,)\nu_initial_condition = 0.01rand(num_points(tri))\nv_initial_condition = zeros(num_points(tri))\nfinal_time = 1000.0\nu_prob = FVMProblem(mesh, BCs_u;\n    flux_function=q_u, flux_parameters=q_u_parameters,\n    source_function=S_u,\n    initial_condition=u_initial_condition, final_time=final_time)\nv_prob = FVMProblem(mesh, BCs_v;\n    flux_function=q_v, flux_parameters=q_v_parameters,\n    source_function=S_v, source_parameters=S_v_parameters,\n    initial_condition=v_initial_condition, final_time=final_time)\nprob = FVMSystem(u_prob, v_prob);","category":"page"},{"location":"tutorials/keller_segel_chemotaxis/","page":"Keller-Segel Model of Chemotaxis","title":"Keller-Segel Model of Chemotaxis","text":"Now let's solve and animate the problem.","category":"page"},{"location":"tutorials/keller_segel_chemotaxis/","page":"Keller-Segel Model of Chemotaxis","title":"Keller-Segel Model of Chemotaxis","text":"using OrdinaryDiffEq, LinearSolve, CairoMakie\nsol = solve(prob, TRBDF2(linsolve=KLUFactorization()), saveat=1.0) # very slow\nfig = Figure(fontsize=44)\nx = LinRange(0, 100, 250)\ny = LinRange(0, 100, 250)\ni = Observable(1)\naxu = Axis(fig[1, 1], width=600, height=600,\n    title=map(i -> L\"u(x,~ y,~ %$(sol.t[i]))\", i), xlabel=L\"x\", ylabel=L\"y\")\naxv = Axis(fig[1, 2], width=600, height=600,\n    title=map(i -> L\"v(x,~ y,~ %$(sol.t[i]))\", i), xlabel=L\"x\", ylabel=L\"y\")\nu = map(i -> reshape(sol.u[i][1, :], 250, 250), i)\nv = map(i -> reshape(sol.u[i][2, :], 250, 250), i)\nheatmap!(axu, x, y, u, colorrange=(0.0, 2.5), colormap=:turbo)\nheatmap!(axv, x, y, v, colorrange=(0.0, 10.0), colormap=:turbo)\nresize_to_layout!(fig)\nrecord(fig, joinpath(@__DIR__, \"../figures\", \"keller_segel_chemotaxis.mp4\"), eachindex(sol);\n    framerate=60) do _i\n    i[] = _i\nend;","category":"page"},{"location":"tutorials/keller_segel_chemotaxis/","page":"Keller-Segel Model of Chemotaxis","title":"Keller-Segel Model of Chemotaxis","text":"(Image: Animation of the Gray-Scott model)","category":"page"},{"location":"tutorials/keller_segel_chemotaxis/","page":"Keller-Segel Model of Chemotaxis","title":"Keller-Segel Model of Chemotaxis","text":"Some pretty amazing patterns!","category":"page"},{"location":"tutorials/keller_segel_chemotaxis/#Just-the-code","page":"Keller-Segel Model of Chemotaxis","title":"Just the code","text":"","category":"section"},{"location":"tutorials/keller_segel_chemotaxis/","page":"Keller-Segel Model of Chemotaxis","title":"Keller-Segel Model of Chemotaxis","text":"An uncommented version of this example is given below.","category":"page"},{"location":"tutorials/keller_segel_chemotaxis/","page":"Keller-Segel Model of Chemotaxis","title":"Keller-Segel Model of Chemotaxis","text":"using FiniteVolumeMethod, DelaunayTriangulation\ntri = triangulate_rectangle(0, 100, 0, 100, 250, 250, single_boundary=true)\nmesh = FVMGeometry(tri)\nbc_u = (x, y, t, (u, v), p) -> zero(u)\nbc_v = (x, y, t, (u, v), p) -> zero(v)\nBCs_u = BoundaryConditions(mesh, bc_u, Neumann)\nBCs_v = BoundaryConditions(mesh, bc_v, Neumann)\nq_u = (x, y, t, (αu, αv), (βu, βv), (γu, γv), p) -> begin\n    u = αu * x + βu * y + γu\n    ∇u = (αu, βu)\n    ∇v = (αv, βv)\n    χu = p.c * u / (1 + u^2)\n    _q = χu .* ∇v .- ∇u\n    return _q\nend\nq_v = (x, y, t, (αu, αv), (βu, βv), (γu, γv), p) -> begin\n    ∇v = (αv, βv)\n    _q = -p.D .* ∇v\n    return _q\nend\nS_u = (x, y, t, (u, v), p) -> begin\n    return u * (1 - u)\nend\nS_v = (x, y, t, (u, v), p) -> begin\n    return u - p.a * v\nend\nq_u_parameters = (c=4.0,)\nq_v_parameters = (D=1.0,)\nS_v_parameters = (a=0.1,)\nu_initial_condition = 0.01rand(num_points(tri))\nv_initial_condition = zeros(num_points(tri))\nfinal_time = 1000.0\nu_prob = FVMProblem(mesh, BCs_u;\n    flux_function=q_u, flux_parameters=q_u_parameters,\n    source_function=S_u,\n    initial_condition=u_initial_condition, final_time=final_time)\nv_prob = FVMProblem(mesh, BCs_v;\n    flux_function=q_v, flux_parameters=q_v_parameters,\n    source_function=S_v, source_parameters=S_v_parameters,\n    initial_condition=v_initial_condition, final_time=final_time)\nprob = FVMSystem(u_prob, v_prob);\n\nusing OrdinaryDiffEq, LinearSolve, CairoMakie\nsol = solve(prob, TRBDF2(linsolve=KLUFactorization()), saveat=1.0) # very slow\nfig = Figure(fontsize=44)\nx = LinRange(0, 100, 250)\ny = LinRange(0, 100, 250)\ni = Observable(1)\naxu = Axis(fig[1, 1], width=600, height=600,\n    title=map(i -> L\"u(x,~ y,~ %$(sol.t[i]))\", i), xlabel=L\"x\", ylabel=L\"y\")\naxv = Axis(fig[1, 2], width=600, height=600,\n    title=map(i -> L\"v(x,~ y,~ %$(sol.t[i]))\", i), xlabel=L\"x\", ylabel=L\"y\")\nu = map(i -> reshape(sol.u[i][1, :], 250, 250), i)\nv = map(i -> reshape(sol.u[i][2, :], 250, 250), i)\nheatmap!(axu, x, y, u, colorrange=(0.0, 2.5), colormap=:turbo)\nheatmap!(axv, x, y, v, colorrange=(0.0, 10.0), colormap=:turbo)\nresize_to_layout!(fig)\nrecord(fig, joinpath(@__DIR__, \"../figures\", \"keller_segel_chemotaxis.mp4\"), eachindex(sol);\n    framerate=60) do _i\n    i[] = _i\nend;","category":"page"}]
}
