<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interface · FiniteVolumeMethod.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://DanielVandH.github.io/FiniteVolumeMethod.jl/interface/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FiniteVolumeMethod.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Interface</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#FVMGeometry:-Defining-the-mesh"><span><code>FVMGeometry</code>: Defining the mesh</span></a></li><li class="toplevel"><a class="tocitem" href="#BoundaryConditions:-Defining-boundary-conditions"><span><code>BoundaryConditions</code>: Defining boundary conditions</span></a></li><li class="toplevel"><a class="tocitem" href="#InternalConditions:-Defining-internal-conditions"><span><code>InternalConditions</code>: Defining internal conditions</span></a></li><li class="toplevel"><a class="tocitem" href="#FVMProblem:-Defining-the-PDE"><span><code>FVMProblem</code>: Defining the PDE</span></a></li><li class="toplevel"><a class="tocitem" href="#SteadyFVMProblem:-Making-the-problem-a-steady-state-problem"><span><code>SteadyFVMProblem</code>: Making the problem a steady-state problem</span></a></li><li class="toplevel"><a class="tocitem" href="#FVMSystem:-Defining-a-system-of-PDEs"><span><code>FVMSystem</code>: Defining a system of PDEs</span></a></li><li class="toplevel"><a class="tocitem" href="#solve:-Solving-the-PDE"><span><code>solve</code>: Solving the PDE</span></a></li><li class="toplevel"><a class="tocitem" href="#Custom-constraints"><span>Custom constraints</span></a></li><li class="toplevel"><a class="tocitem" href="#Piecewise-linear-interpolation"><span>Piecewise linear interpolation</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorials/overview/">Section Overview</a></li><li><a class="tocitem" href="../tutorials/diffusion_equation_on_a_square_plate/">Diffusion Equation on a Square Plate</a></li><li><a class="tocitem" href="../tutorials/diffusion_equation_in_a_wedge_with_mixed_boundary_conditions/">Diffusion Equation in a Wedge with Mixed Boundary Conditions</a></li><li><a class="tocitem" href="../tutorials/reaction_diffusion_equation_with_a_time_dependent_dirichlet_boundary_condition_on_a_disk/">Reaction-Diffusion Equation with a Time-dependent Dirichlet Boundary Condition on a Disk</a></li><li><a class="tocitem" href="../tutorials/porous_medium_equation/">Porous-Medium Equation</a></li><li><a class="tocitem" href="../tutorials/porous_fisher_equation_and_travelling_waves/">Porous-Fisher Equation and Travelling Waves</a></li><li><a class="tocitem" href="../tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/">Piecewise Linear and Natural Neighbour Interpolation for an Advection-Diffusion Equation</a></li><li><a class="tocitem" href="../tutorials/helmholtz_equation_with_inhomogeneous_boundary_conditions/">Helmholtz Equation with Inhomogeneous Boundary Conditions</a></li><li><a class="tocitem" href="../tutorials/laplaces_equation_with_internal_dirichlet_conditions/">Laplace&#39;s Equation with Internal Dirichlet Conditions</a></li><li><a class="tocitem" href="../tutorials/equilibrium_temperature_distribution_with_mixed_boundary_conditions_and_using_ensembleproblems/">Equilibrium Temperature Distribution with Mixed Boundary Conditions and using EnsembleProblems</a></li><li><a class="tocitem" href="../tutorials/reaction_diffusion_brusselator_system_of_pdes/">A Reaction-Diffusion Brusselator System of PDEs</a></li><li><a class="tocitem" href="../tutorials/gray_scott_model_turing_patterns_from_a_coupled_reaction_diffusion_system/">Gray-Scott Model: Turing Patterns from a Coupled Reaction-Diffusion System</a></li><li><a class="tocitem" href="../tutorials/diffusion_equation_on_an_annulus/">Diffusion Equation on an Annulus</a></li><li><a class="tocitem" href="../tutorials/mean_exit_time/">Mean Exit Time</a></li><li><a class="tocitem" href="../tutorials/solving_mazes_with_laplaces_equation/">Solving Mazes with Laplace&#39;s Equation</a></li><li><a class="tocitem" href="../tutorials/keller_segel_chemotaxis/">Keller-Segel Model of Chemotaxis</a></li></ul></li><li><a class="tocitem" href="../math/">Mathematical and Implementation Details</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Interface</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/main/docs/src/interface.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Interface"><a class="docs-heading-anchor" href="#Interface">Interface</a><a id="Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Interface" title="Permalink"></a></h1><ul><li><a href="#Interface">Interface</a></li><li><a href="#FVMGeometry:-Defining-the-mesh"><code>FVMGeometry</code>: Defining the mesh</a></li><li><a href="#BoundaryConditions:-Defining-boundary-conditions"><code>BoundaryConditions</code>: Defining boundary conditions</a></li><li><a href="#InternalConditions:-Defining-internal-conditions"><code>InternalConditions</code>: Defining internal conditions</a></li><li><a href="#FVMProblem:-Defining-the-PDE"><code>FVMProblem</code>: Defining the PDE</a></li><li><a href="#SteadyFVMProblem:-Making-the-problem-a-steady-state-problem"><code>SteadyFVMProblem</code>: Making the problem a steady-state problem</a></li><li><a href="#FVMSystem:-Defining-a-system-of-PDEs"><code>FVMSystem</code>: Defining a system of PDEs</a></li><li><a href="#solve:-Solving-the-PDE"><code>solve</code>: Solving the PDE</a></li><li><a href="#Custom-constraints">Custom constraints</a></li><li><a href="#Piecewise-linear-interpolation">Piecewise linear interpolation</a></li></ul><p>In this section, we describe the basic interface for defining and solving PDEs using this package. This interface will also be made clearer in the tutorials. The basic summary of the discussion below is as follows:</p><ol><li>Use <code>FVMGeometry</code> to define the problem&#39;s mesh.</li><li>Provide boundary conditions using <code>BoundaryConditions</code>.</li><li>(Optional) Provide internal conditions using <code>InternalConditions</code>.</li><li>Convert the problem into an <code>FVMProblem</code>.</li><li>If you want to make the problem steady, use <code>SteadyFVMProblem</code> on the <code>FVMProblem</code>.</li><li>If you want a system of equations, construct an <code>FVMSystem</code> from multiple <code>FVMProblem</code>s; if you want this problem to be steady, skip step 5 and only now apply <code>SteadyFVMProblem</code>.</li><li>Solve the problem using <code>solve</code>.</li><li>For a discussion of custom constraints, see the tutorials.</li><li>For interpolation, we provide <code>pl_interpolate</code> (but you might prefer <a href="https://github.com/DanielVandH/NaturalNeighbours.jl">NaturalNeighbours.jl</a> - see <a href="../tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/">this tutorial for an example</a>).</li></ol><h1 id="FVMGeometry:-Defining-the-mesh"><a class="docs-heading-anchor" href="#FVMGeometry:-Defining-the-mesh"><code>FVMGeometry</code>: Defining the mesh</a><a id="FVMGeometry:-Defining-the-mesh-1"></a><a class="docs-heading-anchor-permalink" href="#FVMGeometry:-Defining-the-mesh" title="Permalink"></a></h1><p>The finite volume method (FVM) requires an underlying triangular mesh, as outlined in the <a href="../math/">mathematical details section</a>. This triangular mesh is to be defined from <a href="https://github.com/DanielVandH/DelaunayTriangulation.jl">DelaunayTriangulation.jl</a>. The <code>FVMGeometry</code> type wraps the resulting <code>Triangulation</code> and computes information about the geometry required for solving the PDEs. The docstring for <code>FVMGeometry</code> is below; the fields of <code>FVMGeometry</code> are public API. </p><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.FVMGeometry" href="#FiniteVolumeMethod.FVMGeometry"><code>FiniteVolumeMethod.FVMGeometry</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FVMGeometry(tri::Triangulation)</code></pre><p>This is a constructor for the <a href="#FiniteVolumeMethod.FVMGeometry"><code>FVMGeometry</code></a> struct, which holds the mesh and associated data for the PDE.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is assumed that all vertices in <code>tri</code> are in the triangulation, meaning <code>v</code> is in <code>tri</code> for each <code>v</code> in <code>each_point_index(tri)</code>.</p></div></div><p><strong>Fields</strong></p><ul><li><code>triangulation</code>: The underlying <code>Triangulation</code> from DelaunayTriangulation.jl.</li><li><code>triangulation_statistics</code>: The statistics of the triangulation. </li><li><code>cv_volumes::Vector{Float64}</code>: A <code>Vector</code> of the volumes of each control volume.</li><li><code>triangle_props::Dict{NTuple{3,Int},TriangleProperties}</code>: A <code>Dict</code> mapping the indices of each triangle to its [<code>TriangleProperties</code>].</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/e0c41ee12ce75f31dd4f24fccfb8744ca8e51a27/src/geometry.jl#L20-L33">source</a></section></article><p>The <code>FVMGeometry</code> struct uses <code>TriangleProperties</code> for storing properties of a control volume that intersects a given triangle, defined below. This struct is  public API, although it is unlikely you would ever need it. </p><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.TriangleProperties" href="#FiniteVolumeMethod.TriangleProperties"><code>FiniteVolumeMethod.TriangleProperties</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TriangleProperties(shape_function_coefficients, cv_edge_midpoints, cv_edge_normals, cv_edge_lengths)</code></pre><p>This is a struct for holding the properties of a control volume&#39;s intersection with a triangle.</p><p><strong>Fields</strong></p><ul><li><code>shape_function_coefficients::NTuple{9,Float64}</code>: The shape function coefficients for the triangle.</li><li><code>cv_edge_midpoints::NTuple{3,NTuple{2,Float64}}</code>: The midpoints of the control volume edges. If the triangle is <code>(i, j, k)</code>, then the edges are given in the order <code>(i, j)</code>, <code>(j, k)</code>, and <code>(k, i)</code>, where &#39;edge&#39; refers to the edge joining e.g. the midpoint of the edge <code>(i, j)</code> to the centroid of the triangle. </li><li><code>cv_edge_normals::NTuple{3,NTuple{2,Float64}}</code>: The normal vectors to the control volume edges, in the same order as in <code>cv_edge_midpoints</code>.</li><li><code>cv_edge_lengths::NTuple{3,Float64}</code>: The lengths of the control volume edges, in the same order as in <code>cv_edge_midpoints</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/e0c41ee12ce75f31dd4f24fccfb8744ca8e51a27/src/geometry.jl#L2-L12">source</a></section></article><h1 id="BoundaryConditions:-Defining-boundary-conditions"><a class="docs-heading-anchor" href="#BoundaryConditions:-Defining-boundary-conditions"><code>BoundaryConditions</code>: Defining boundary conditions</a><a id="BoundaryConditions:-Defining-boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#BoundaryConditions:-Defining-boundary-conditions" title="Permalink"></a></h1><p>Once a mesh is defined, you need to associate each part of the boundary with a set of boundary nodes. Since you have a <code>Triangulation</code>, the boundary of the mesh already meets the necessary assumptions made by this package about the boundary; these assumptions are simply that they match the specification of a boundary <a href="https://danielvandh.github.io/DelaunayTriangulation.jl/dev/boundary_handling/#Boundary-Specification">here in DelaunayTriangulation.jl&#39;s docs</a> (for example, the boundary points connect, the boundary is positively oriented, etc.).</p><p>You can specify boundary condtiions using <code>BoundaryConditions</code>, whose docstring is below; the fields of <code>BoundaryConditions</code> are not public API, only this wrapper is.</p><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.BoundaryConditions" href="#FiniteVolumeMethod.BoundaryConditions"><code>FiniteVolumeMethod.BoundaryConditions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoundaryConditions(mesh::FVMGeometry, functions, conditions; parameters=nothing)</code></pre><p>This is a constructor for the <a href="#FiniteVolumeMethod.BoundaryConditions"><code>BoundaryConditions</code></a> struct, which holds the boundary conditions for the PDE.  See also <a href="#FiniteVolumeMethod.Conditions"><code>Conditions</code></a> (which <a href="#FiniteVolumeMethod.FVMProblem"><code>FVMProblem</code></a> wraps this into), <a href="#FiniteVolumeMethod.ConditionType"><code>ConditionType</code></a>, and <a href="#FiniteVolumeMethod.InternalConditions"><code>InternalConditions</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>mesh::FVMGeometry</code></li></ul><p>The mesh on which the PDE is defined.</p><ul><li><code>functions::Union{&lt;:Tuple,&lt;:Function}</code></li></ul><p>The functions that define the boundary conditions. The <code>i</code>th function should correspond to the part of the boundary of  the <code>mesh</code> corresponding to the <code>i</code>th boundary index, as defined in DelaunayTriangulation.jl. </p><ul><li><code>conditions::Union{&lt;:Tuple,&lt;:ConditionType}</code></li></ul><p>The classification for the boundary condition type corresponding to each boundary index as above. See  <a href="#FiniteVolumeMethod.ConditionType"><code>ConditionType</code></a> for possible conditions - should be one of <a href="#FiniteVolumeMethod.Neumann"><code>Neumann</code></a>, <a href="#FiniteVolumeMethod.Dudt"><code>Dudt</code></a>, <a href="#FiniteVolumeMethod.Dirichlet"><code>Dirichlet</code></a>, or <a href="#FiniteVolumeMethod.Constrained"><code>Constrained</code></a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters=ntuple(_ -&gt; nothing, length(functions))</code></li></ul><p>The parameters for the functions, with <code>parameters[i]</code> giving the argument <code>p</code> in <code>functions[i]</code>.</p><p><strong>Outputs</strong></p><p>The returned value is the corresponding <a href="#FiniteVolumeMethod.BoundaryConditions"><code>BoundaryConditions</code></a> struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/e0c41ee12ce75f31dd4f24fccfb8744ca8e51a27/src/conditions.jl#L117-L143">source</a></section></article><p>There are four types of boundary conditions: <code>Neumann</code>, <code>Dudt</code>, <code>Dirichlet</code>, and <code>Constrained</code>. These types are defined below.</p><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.ConditionType" href="#FiniteVolumeMethod.ConditionType"><code>FiniteVolumeMethod.ConditionType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConditionType</code></pre><p>This is an <code>Enum</code>-type, with four instances:</p><ul><li><a href="#FiniteVolumeMethod.Neumann"><code>Neumann</code></a></li><li><a href="#FiniteVolumeMethod.Dudt"><code>Dudt</code></a></li><li><a href="#FiniteVolumeMethod.Dirichlet"><code>Dirichlet</code></a></li><li><a href="#FiniteVolumeMethod.Constrained"><code>Constrained</code></a></li></ul><p>This is used for declaring conditions in the PDEs. See  the associated docstrings, and also <a href="#FiniteVolumeMethod.BoundaryConditions"><code>BoundaryConditions</code></a> and <a href="#FiniteVolumeMethod.InternalConditions"><code>InternalConditions</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/e0c41ee12ce75f31dd4f24fccfb8744ca8e51a27/src/conditions.jl#L7-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.Neumann" href="#FiniteVolumeMethod.Neumann"><code>FiniteVolumeMethod.Neumann</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">Neumann</code></pre><p>Instance of a <a href="#FiniteVolumeMethod.ConditionType"><code>ConditionType</code></a> used for declaring that an edge  has a <code>Neumann</code> condition. <code>Neumann</code> conditions  take the form </p><p class="math-container">\[\vb q(x, y, t) \vdot \vu n_\sigma = a(x, y, t, u)\]</p><p>where <span>$\vb q$</span> is the flux function and <span>$\vu n_\sigma$</span> is the  outward unit normal vector field on the associated edge (meaning, for example,  the normal vector to an edge <code>pq</code> would point to the right of <code>pq</code>).</p><p>When providing a <code>Neumann</code> condition, the function you provide  takes the form</p><pre><code class="nohighlight hljs">a(x, y, t, u, p)</code></pre><p>where <code>(x, y)</code> is the point, <code>t</code> is the current time, and <code>u</code> is the  solution at the point <code>(x, y)</code> at time <code>t</code>, as above, with an extra  argument <code>p</code> for additional parameters. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/e0c41ee12ce75f31dd4f24fccfb8744ca8e51a27/src/conditions.jl#L28-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.Dudt" href="#FiniteVolumeMethod.Dudt"><code>FiniteVolumeMethod.Dudt</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">Dudt</code></pre><p>Instance of a <a href="#FiniteVolumeMethod.ConditionType"><code>ConditionType</code></a> used for declaring that an edge,  or a point, has a <code>Dudt</code>-type boundary condition. <code>Dudt</code>-type  conditions take the form</p><p class="math-container">\[\dv{u(x, y, t)}{t} = a(x, y, t, u).\]</p><p>When providing a <code>Dudt</code> condition, the function you provide takes the form</p><pre><code class="nohighlight hljs">a(x, y, t, u, p)</code></pre><p>where <code>(x, y)</code> is the point, <code>t</code> is the current time, and <code>u</code> is the solution at the point <code>(x, y)</code> at time <code>t</code>, as above, with an extra  argument <code>p</code> for additional parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/e0c41ee12ce75f31dd4f24fccfb8744ca8e51a27/src/conditions.jl#L53-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.Dirichlet" href="#FiniteVolumeMethod.Dirichlet"><code>FiniteVolumeMethod.Dirichlet</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">Dirichlet</code></pre><p>Instance of a <a href="#FiniteVolumeMethod.ConditionType"><code>ConditionType</code></a> used for declaring that an edge, or a point, has a <code>Dirichlet</code> boundary condition. <code>Dirichlet</code> conditions take the form</p><p class="math-container">\[u(x, y, t) = a(x, y, t, u).\]</p><p>When providing a <code>Dirichlet</code> condition, the function you provide takes the form</p><pre><code class="nohighlight hljs">a(x, y, t, u, p)</code></pre><p>where <code>(x, y)</code> is the point, <code>t</code> is the current time, and <code>u</code> is the solution at the point <code>(x, y)</code> at time <code>t</code>, as above, with an extra  argument <code>p</code> for additional parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/e0c41ee12ce75f31dd4f24fccfb8744ca8e51a27/src/conditions.jl#L74-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.Constrained" href="#FiniteVolumeMethod.Constrained"><code>FiniteVolumeMethod.Constrained</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">Constrained</code></pre><p>Instance of a <a href="#FiniteVolumeMethod.ConditionType"><code>ConditionType</code></a> used for declaring that an edge has a <code>Constrained</code> condition. When an edge has this condition associated with it,  it will be treated as any normal edge and no boundary condition will be applied. With this condition, it is assumed that you will later setup your problem as a  differential-algebraic equation (DAE) and provide the appropriate constraints. See the docs for some examples.</p><p>When you provide a <code>Constrained</code> condition, for certain technical reasons  you do still need to provide a function that corresponds to it in the function list  provided to <a href="#FiniteVolumeMethod.BoundaryConditions"><code>BoundaryConditions</code></a>. For this function, any function will work,  e.g. <code>sin</code> - it will not be called. The proper constraint function is to be provided after-the-fact,  as explained in the docs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/e0c41ee12ce75f31dd4f24fccfb8744ca8e51a27/src/conditions.jl#L95-L110">source</a></section></article><h1 id="InternalConditions:-Defining-internal-conditions"><a class="docs-heading-anchor" href="#InternalConditions:-Defining-internal-conditions"><code>InternalConditions</code>: Defining internal conditions</a><a id="InternalConditions:-Defining-internal-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#InternalConditions:-Defining-internal-conditions" title="Permalink"></a></h1><p>If you like, you can also put some constraints for nodes away from the boundary. In this case, only <code>Dudt</code> and <code>Dirichlet</code> conditions can be imposed; for <code>Neumann</code> or <code>Constrained</code> conditions, you need to consider differential-algebraic problems as considered in the tutorials. The docstring for <code>InternalConditions</code> is below; the fields of <code>InternalConditions</code> are not public API, only this wrapper is.</p><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.InternalConditions" href="#FiniteVolumeMethod.InternalConditions"><code>FiniteVolumeMethod.InternalConditions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InternalConditions(functions=();
    dirichlet_nodes::Dict{Int,Int}=Dict{Int,Int}(),
    dudt_nodes::Dict{Int,Int}=Dict{Int,Int}(),
    parameters::Tuple=ntuple(_ -&gt; nothing, length(functions)))</code></pre><p>This is a constructor for the <a href="#FiniteVolumeMethod.InternalConditions"><code>InternalConditions</code></a> struct, which holds the internal conditions for the PDE. See also <a href="#FiniteVolumeMethod.Conditions"><code>Conditions</code></a> (which <a href="#FiniteVolumeMethod.FVMProblem"><code>FVMProblem</code></a> wraps this into), <a href="#FiniteVolumeMethod.ConditionType"><code>ConditionType</code></a>, and <a href="#FiniteVolumeMethod.BoundaryConditions"><code>BoundaryConditions</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>functions::Union{&lt;:Tuple,&lt;:Function}=()</code></li></ul><p>The functions that define the internal conditions. These are the functions refereed to in <code>edge_conditions</code> and <code>point_conditions</code>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>dirichlet_nodes::Dict{Int,Int}=Dict{Int,Int}()</code></li></ul><p>A <code>Dict</code> that stores all <a href="#FiniteVolumeMethod.Dirichlet"><code>Dirichlet</code></a> points <code>u</code> as keys, with keys mapping to indices <code>idx</code> that refer to the corresponding condition function and parameters in <code>functions</code> and <code>parameters</code>.</p><ul><li><code>dudt_nodes::Dict{Int,Int}=Dict{Int,Int}()</code></li></ul><p>A <code>Dict</code> that stores all <a href="#FiniteVolumeMethod.Dudt"><code>Dudt</code></a> points <code>u</code> as keys, with keys mapping to indices <code>idx</code> that refer to the corresponding condition function and parameters in <code>functions</code> and <code>parameters</code>.</p><ul><li><code>parameters::Tuple=ntuple(_ -&gt; nothing, length(functions))</code></li></ul><p>The parameters for the functions, with <code>parameters[i]</code> giving the argument <code>p</code> in <code>functions[i]</code>.</p><p><strong>Outputs</strong></p><p>The returned value is the corresponding <a href="#FiniteVolumeMethod.InternalConditions"><code>InternalConditions</code></a> struct.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>When the internal conditions get merged with the boundary conditions,  any internal conditions that are placed onto the boundary will  be replaced with the boundary condition at that point on the boundary.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/e0c41ee12ce75f31dd4f24fccfb8744ca8e51a27/src/conditions.jl#L162-L197">source</a></section></article><h1 id="FVMProblem:-Defining-the-PDE"><a class="docs-heading-anchor" href="#FVMProblem:-Defining-the-PDE"><code>FVMProblem</code>: Defining the PDE</a><a id="FVMProblem:-Defining-the-PDE-1"></a><a class="docs-heading-anchor-permalink" href="#FVMProblem:-Defining-the-PDE" title="Permalink"></a></h1><p>Once you have defined the mesh, the boundary conditions, and possibly the internal conditions, you can now construct the PDE itself. This is done using <code>FVMProblem</code>, whose docstring is below; the fields of <code>FVMProblem</code> are public API.</p><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.FVMProblem" href="#FiniteVolumeMethod.FVMProblem"><code>FiniteVolumeMethod.FVMProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FVMProblem(mesh, boundary_conditions[, internal_conditions];
    diffusion_function=nothing,
    diffusion_parameters=nothing,
    source_function=nothing,
    source_parameters=nothing,
    flux_function=nothing,
    flux_parameters=nothing,
    initial_condition,
    initial_time=0.0,
    final_time)</code></pre><p>Constructs an <code>FVMProblem</code>. See also <a href="#FiniteVolumeMethod.FVMSystem"><code>FVMSystem</code></a> and <a href="#FiniteVolumeMethod.SteadyFVMProblem"><code>SteadyFVMProblem</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>mesh::FVMGeometry</code></li></ul><p>The mesh on which the PDE is defined, given as a <a href="#FiniteVolumeMethod.FVMGeometry"><code>FVMGeometry</code></a>.</p><ul><li><code>boundary_conditions::BoundaryConditions</code></li></ul><p>The boundary conditions for the PDE, given as a <a href="#FiniteVolumeMethod.BoundaryConditions"><code>BoundaryConditions</code></a>.</p><ul><li><code>internal_conditions::InternalConditions=InternalConditions()</code></li></ul><p>The internal conditions for the PDE, given as an <a href="#FiniteVolumeMethod.InternalConditions"><code>InternalConditions</code></a>. This argument  is optional.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>diffusion_function=nothing</code></li></ul><p>If <code>isnothing(flux_function)</code>, then this can be provided to give the diffusion-source formulation. See also <a href="#FiniteVolumeMethod.construct_flux_function"><code>construct_flux_function</code></a>. Should be of the form <code>D(x, y, t, u, p)</code>.</p><ul><li><code>diffusion_parameters=nothing</code></li></ul><p>The argument <code>p</code> for <code>diffusion_function</code>.</p><ul><li><code>source_function=(x, y, t, u, p) -&gt; zero(u)</code></li></ul><p>The source term, given in the form <code>S(x, y, t, u, p)</code>.</p><ul><li><code>source_parameters=nothing</code></li></ul><p>The argument <code>p</code> for <code>source_function</code>.</p><ul><li><code>flux_function=nothing</code></li></ul><p>The flux function, given in the form <code>q(x, y, t, α, β, γ, p) ↦ (qx, qy)</code>, where <code>(qx, qy)</code> is the flux vector, <code>(α, β, γ)</code> are the shape function coefficients for estimating <code>u ≈ αx+βy+γ</code>. If <code>isnothing(flux_function)</code>, then <code>diffusion_function</code> is used instead to construct the function.</p><ul><li><code>flux_parameters=nothing</code></li></ul><p>The argument <code>p</code> for <code>flux_function</code>.</p><ul><li><code>initial_condition</code></li></ul><p>The initial condition, with <code>initial_condition[i]</code> the initial value at the <code>i</code>th node of the <code>mesh</code>.</p><ul><li><code>initial_time=0.0</code></li></ul><p>The initial time.</p><ul><li><code>final_time</code></li></ul><p>The final time.</p><p><strong>Outputs</strong></p><p>The returned value is the corresponding <a href="#FiniteVolumeMethod.FVMProblem"><code>FVMProblem</code></a> struct. You can then solve the problem using <a href="#CommonSolve.solve-Tuple{Union{FVMProblem, FVMSystem}, Any}"><code>solve(::Union{FVMProblem,FVMSystem}, ::Any; kwargs...)</code></a> from DifferentialEquations.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/e0c41ee12ce75f31dd4f24fccfb8744ca8e51a27/src/problem.jl#L19-L76">source</a></section></article><p>For this problem, you can provide either a <code>diffusion_function</code> or a <code>flux_function</code>. In the former case, the <code>flux_function</code> is constructed from <code>diffusion_function</code> using <code>construct_flux_function</code>, whose docstring is shown below; <code>construct_flux_function</code> is not public API.</p><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.construct_flux_function" href="#FiniteVolumeMethod.construct_flux_function"><code>FiniteVolumeMethod.construct_flux_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">construct_flux_function(q, D, Dp)</code></pre><p>If <code>isnothing(q)</code>, then this returns the flux function based on the diffusion function <code>D</code> and  diffusion parameters <code>Dp</code>, so that the new function is </p><pre><code class="nohighlight hljs">(x, y, t, α, β, γ, _) -&gt; -D(x, y, t, α*x + β*y + γ, Dp)[α, β]</code></pre><p>Otherwise, just returns <code>q</code> again.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/e0c41ee12ce75f31dd4f24fccfb8744ca8e51a27/src/problem.jl#L264-L273">source</a></section></article><p>Additionally, <code>FVMProblem</code> merges the provided boundary conditions and internal conditions into a <code>Conditions</code> type, defined below; the documented fields of <code>Conditions</code> are public API.</p><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.Conditions" href="#FiniteVolumeMethod.Conditions"><code>FiniteVolumeMethod.Conditions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Conditions{F}</code></pre><p>This is a <code>struct</code> that holds the boundary and internal conditions for the PDE.</p><p><strong>Fields</strong></p><ul><li><code>neumann_conditions::Dict{NTuple{2,Int},Int}</code></li></ul><p>A <code>Dict</code> that stores all <a href="#FiniteVolumeMethod.Neumann"><code>Neumann</code></a> edges <code>(u, v)</code> as keys, with keys mapping to indices  <code>idx</code> that refer to the corresponding condition function and parameters in <code>functions</code>.</p><ul><li><code>constrained_conditions::Dict{NTuple{2,Int},Int}</code></li></ul><p>A <code>Dict</code> that stores all <a href="#FiniteVolumeMethod.Constrained"><code>Constrained</code></a> edges <code>(u, v)</code> as keys, with keys mapping to indices <code>idx</code> that refer to the corresponding condition function and parameters in <code>functions</code>.</p><ul><li><code>dirichlet_conditions::Dict{Int,Int}</code></li></ul><p>A <code>Dict</code> that stores all <a href="#FiniteVolumeMethod.Dirichlet"><code>Dirichlet</code></a> points <code>u</code> as keys, with keys mapping to indices <code>idx</code> that refer to the corresponding condition function and parameters in <code>functions</code>.</p><ul><li><code>dudt_conditions::Dict{Int,Int}</code></li></ul><p>A <code>Dict</code> that stores all <a href="#FiniteVolumeMethod.Dudt"><code>Dudt</code></a> points <code>u</code> as keys, with keys mapping to indices <code>idx</code> that refer to the corresponding condition function and parameters in <code>functions</code>.</p><ul><li><code>functions::F</code></li></ul><p>A <code>Tuple</code> of functions that correspond to the condition function. Can also be a single function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/e0c41ee12ce75f31dd4f24fccfb8744ca8e51a27/src/conditions.jl#L238-L263">source</a></section></article><h1 id="SteadyFVMProblem:-Making-the-problem-a-steady-state-problem"><a class="docs-heading-anchor" href="#SteadyFVMProblem:-Making-the-problem-a-steady-state-problem"><code>SteadyFVMProblem</code>: Making the problem a steady-state problem</a><a id="SteadyFVMProblem:-Making-the-problem-a-steady-state-problem-1"></a><a class="docs-heading-anchor-permalink" href="#SteadyFVMProblem:-Making-the-problem-a-steady-state-problem" title="Permalink"></a></h1><p>To make an <code>FVMProblem</code> a steady-state problem, meaning that you are solving</p><p class="math-container">\[\div \vb q(\vb x, t, u) = S(\vb x, t, u)\]</p><p>rather than</p><p class="math-container">\[\pdv{u(\vb x, t)}{t} + \div \vb q(\vb x, t, u) = S(\vb x, t, u),\]</p><p>than you need to wrap the <code>FVMProblem</code> inside a <code>SteadyFVMProblem</code>, defined below; the fields of <code>SteadyFVMProblem</code> are public API.</p><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.SteadyFVMProblem" href="#FiniteVolumeMethod.SteadyFVMProblem"><code>FiniteVolumeMethod.SteadyFVMProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SteadyFVMProblem(prob::AbstractFVMProblem)</code></pre><p>This is a wrapper for an <code>AbstractFVMProblem</code> that indicates that the problem is to be solved as a steady-state problem.  You can then solve the problem using <a href="#CommonSolve.solve-Tuple{SteadyFVMProblem, Any}"><code>solve(::SteadyFVMProblem, ::Any; kwargs...)</code></a> from NonlinearSolve.jl. Note that you  need to have set the final time to <code>Inf</code> if you want a steady state out at infinity rather than some finite actual time.</p><p>See also <a href="#FiniteVolumeMethod.FVMProblem"><code>FVMProblem</code></a> and <a href="#FiniteVolumeMethod.FVMSystem"><code>FVMSystem</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/e0c41ee12ce75f31dd4f24fccfb8744ca8e51a27/src/problem.jl#L114-L122">source</a></section></article><h1 id="FVMSystem:-Defining-a-system-of-PDEs"><a class="docs-heading-anchor" href="#FVMSystem:-Defining-a-system-of-PDEs"><code>FVMSystem</code>: Defining a system of PDEs</a><a id="FVMSystem:-Defining-a-system-of-PDEs-1"></a><a class="docs-heading-anchor-permalink" href="#FVMSystem:-Defining-a-system-of-PDEs" title="Permalink"></a></h1><p>We also allow for systems of PDEs to be defined, where this system should take the form</p><p class="math-container">\[\begin{equation*}
\begin{aligned}
\pdv{u_1(\vb x, t)}{t} + \div \vb q_1(\vb x, t, u_1, \ldots, u_n) &amp;= S_1(\vb x, t, u_1, \ldots, u_n), \\
\pdv{u_2(\vb x, t)}{t} + \div \vb q_2(\vb x, t, u_1, \ldots, u_n) &amp;= S_2(\vb x, t, u_1, \ldots, u_n), \\
&amp;\vdots \\
\pdv{u_n(\vb x, t)}{t} + \div \vb q_n(\vb x, t, u_1, \ldots, u_n) &amp;= S_n(\vb x, t, u_1, \ldots, u_n).
\end{aligned}
\end{equation*}\]</p><p>To define this system, you need to provide an <code>FVMProblem</code> for each equation, and then construct an <code>FVMSystem</code> from these problems. The docstring for <code>FVMSystem</code> is below; the fields of <code>FVMSystem</code> are public API.</p><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.FVMSystem" href="#FiniteVolumeMethod.FVMSystem"><code>FiniteVolumeMethod.FVMSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FVMSystem(prob1, prob2, ..., probN)</code></pre><p>Constructs a representation for a system of PDEs, where each <code>probi</code> is  a <a href="#FiniteVolumeMethod.FVMProblem"><code>FVMProblem</code></a> for the <code>i</code>th component of the system.</p><p>For these <a href="#FiniteVolumeMethod.FVMProblem"><code>FVMProblem</code></a>s, the functions involved, such as the condition functions, should  all be defined so that the <code>u</code> argument assumes the form <code>u = (u₁, u₂, ..., uN)</code> (both <code>Tuple</code>s and <code>Vector</code>s will be passed),  where <code>uᵢ</code> is the solution for the <code>i</code>th component of the system. For the flux functions,  which for a <a href="#FiniteVolumeMethod.FVMProblem"><code>FVMProblem</code></a> takes the form</p><pre><code class="nohighlight hljs">q(x, y, t, α, β, γ, p) ↦ (qx, qy),</code></pre><p>the same form is used, except <code>α</code>, <code>β</code>, <code>γ</code> are all <code>Tuple</code>s so that <code>α[i]*x + β[i]*y + γ[i]</code> is the  approximation to <code>uᵢ</code>. </p><div class="admonition is-warning"><header class="admonition-header">Providing default flux functions</header><div class="admonition-body"><p>Due to this difference in flux functions, and the need to provide  <code>α</code>, <code>β</code>, and <code>γ</code> to the flux function, for <code>FVMSystem</code>s you need to  provide a flux function rather than a diffusion function. If you do provide a diffusion function, it will error when you try to solve  the problem.</p></div></div><p>This problem is solved in the same way as a <a href="#FiniteVolumeMethod.FVMProblem"><code>FVMProblem</code></a>, except the problem is defined such that  the solution returns a matrix at each time, where the <code>(j, i)</code>th component corresponds to the solution at the <code>i</code>th  node for the <code>j</code>th component.</p><p>See also <a href="#FiniteVolumeMethod.FVMProblem"><code>FVMProblem</code></a> and <a href="#FiniteVolumeMethod.SteadyFVMProblem"><code>SteadyFVMProblem</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To construct a steady-state problem for an <code>FVMSystem</code>, you need to apply  <a href="#FiniteVolumeMethod.SteadyFVMProblem"><code>SteadyFVMProblem</code></a> to the system rather than first applying it to each individual <a href="#FiniteVolumeMethod.FVMProblem"><code>FVMProblem</code></a> in the system.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/e0c41ee12ce75f31dd4f24fccfb8744ca8e51a27/src/problem.jl#L142-L176">source</a></section></article><p>If you want to make a steady-state problem for an <code>FVMSystem</code>, you should apply <code>SteadyFVMProblem</code> to <code>FVMSystem</code> rather than to each <code>FVMProblem</code> individually.</p><h1 id="solve:-Solving-the-PDE"><a class="docs-heading-anchor" href="#solve:-Solving-the-PDE"><code>solve</code>: Solving the PDE</a><a id="solve:-Solving-the-PDE-1"></a><a class="docs-heading-anchor-permalink" href="#solve:-Solving-the-PDE" title="Permalink"></a></h1><p>You can use <code>solve</code> from the SciMLBase ecosystem to solve these PDEs. This allows you to use <a href="https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/">any of the available algorithms from DifferentialEquations.jl</a> for solving these problems. For non-steady problems, the relevant function is (which is public API)</p><article class="docstring"><header><a class="docstring-binding" id="CommonSolve.solve-Tuple{Union{FVMProblem, FVMSystem}, Any}" href="#CommonSolve.solve-Tuple{Union{FVMProblem, FVMSystem}, Any}"><code>CommonSolve.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve(prob::Union{FVMProblem,FVMSystem}, alg; 
    specialization=SciMLBase.AutoSpecialize, 
    jac_prototype=jacobian_sparsity(prob), 
    parallel::Val{&lt;:Bool}=Val(true),
    mass_matrix=I,
    f=fvm_eqs!,
    kwargs...)</code></pre><p>Solves the given <a href="#FiniteVolumeMethod.FVMProblem"><code>FVMProblem</code></a> or <a href="#FiniteVolumeMethod.FVMSystem"><code>FVMSystem</code></a> <code>prob</code> with the algorithm <code>alg</code>.</p><p><strong>Arguments</strong></p><ul><li><code>prob</code>: The problem to be solved.</li><li><code>alg</code>: The algorithm to be used to solve the problem. This can be any of the algorithms in DifferentialEquations.jl.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>specialization=SciMLBase.AutoSpecialize</code>: The type of specialization to be used. See https://docs.sciml.ai/DiffEqDocs/stable/features/low_dep/#Controlling-Function-Specialization-and-Precompilation.</li><li><code>jac_prototype=jacobian_sparsity(prob)</code>: The prototype for the Jacobian matrix, constructed by default from <code>jacobian_sparsity</code>. Ignored if the mass matrix is not <code>I</code>.</li><li><code>parallel::Val{&lt;:Bool}=Val(true)</code>: Whether to use multithreading. Use <code>Val(false)</code> to disable multithreading. </li><li><code>mass_matrix=I</code>: The mass matrix to be used in the problem. This argument can be useful for defining differential-algebraic equations.</li><li><code>f=fvm_eqs!</code>: The function defining the PDEs. You should only need to change this if you need a differential-algebraic equation. See the maze tutorial in the docs.</li><li><code>kwargs...</code>: Any other keyword arguments to be passed to the solver.</li></ul><p><strong>Outputs</strong></p><p>The returned value <code>sol</code> depends on the type of the problem.</p><ul><li><a href="#FiniteVolumeMethod.FVMProblem"><code>FVMProblem</code></a></li></ul><p>In this case, <code>sol::ODESolution</code> is such that the <code>i</code>th component of <code>sol</code> refers to the <code>i</code>th node of the underlying mesh.</p><ul><li><a href="#FiniteVolumeMethod.FVMSystem"><code>FVMSystem</code></a></li></ul><p>In this case, the <code>(j, i)</code>th component of <code>sol::ODESolution</code> refers to the <code>i</code>th node of the underlying mesh for the <code>j</code>th component of the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/e0c41ee12ce75f31dd4f24fccfb8744ca8e51a27/src/solve.jl#L192-L224">source</a></section></article><p>For steady-state problems, the algorithms to use are those from <a href="https://docs.sciml.ai/NonlinearSolve/stable/">NonlinearSolve.jl</a>. The relevant function is still <code>solve</code> and is public API:</p><article class="docstring"><header><a class="docstring-binding" id="CommonSolve.solve-Tuple{SteadyFVMProblem, Any}" href="#CommonSolve.solve-Tuple{SteadyFVMProblem, Any}"><code>CommonSolve.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve(prob::SteadyFVMProblem, alg; 
    specialization=SciMLBase.AutoSpecialize, 
    jac_prototype=jacobian_sparsity(prob),
    parallel::Val{&lt;:Bool}=Val(true),
    mass_matrix=I,
    f = fvm_eqs!,
    kwargs...)</code></pre><p>Solves the given <a href="#FiniteVolumeMethod.FVMProblem"><code>FVMProblem</code></a> or <a href="#FiniteVolumeMethod.FVMSystem"><code>FVMSystem</code></a> <code>prob</code> with the algorithm <code>alg</code>.</p><p><strong>Arguments</strong></p><ul><li><code>prob</code>: The problem to be solved.</li><li><code>alg</code>: The algorithm to be used to solve the problem. This can be any of the algorithms in NonlinearSolve.jl.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>specialization=SciMLBase.AutoSpecialize</code>: The type of specialization to be used. See https://docs.sciml.ai/DiffEqDocs/stable/features/low_dep/#Controlling-Function-Specialization-and-Precompilation.</li><li><code>jac_prototype=jacobian_sparsity(prob)</code>: The prototype for the Jacobian matrix, constructed by default from <code>jacobian_sparsity</code>. Ignored if the mass matrix is not <code>I</code>.</li><li><code>parallel::Val{&lt;:Bool}=Val(true)</code>: Whether to use multithreading. Use <code>Val(false)</code> to disable multithreading.</li><li><code>mass_matrix=I</code>: The mass matrix to be used in the problem. This argument can be useful for defining differential-algebraic equations.</li><li><code>f=fvm_eqs!</code>: The function defining the PDEs. You should only need to change this if you need a differential-algebraic equation. See the maze tutorial in the docs.</li><li><code>kwargs...</code>: Any other keyword arguments to be passed to the solver.</li></ul><p><strong>Outputs</strong></p><p>The returned value <code>sol</code> depends on whether the underlying problem is a <a href="#FiniteVolumeMethod.FVMProblem"><code>FVMProblem</code></a> or an <a href="#FiniteVolumeMethod.FVMSystem"><code>FVMSystem</code></a>, but in  each case it is an <code>ODESolution</code> type that can be accessed like the solutions in DifferentialEquations.jl:</p><ul><li><a href="#FiniteVolumeMethod.FVMProblem"><code>FVMProblem</code></a></li></ul><p>In this case, <code>sol</code> is such that the <code>i</code>th component of <code>sol</code> refers to the <code>i</code>th node of the underlying mesh.</p><ul><li><a href="#FiniteVolumeMethod.FVMSystem"><code>FVMSystem</code></a></li></ul><p>In this case, the <code>(j, i)</code>th component of <code>sol</code> refers to the <code>i</code>th node of the underlying mesh for the <code>j</code>th component of the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/e0c41ee12ce75f31dd4f24fccfb8744ca8e51a27/src/solve.jl#L226-L259">source</a></section></article><p>These <code>solve</code> functions rely on <code>fvm_eqs!</code> for evaluating the equations. You should never need to use <code>fvm_eqs!</code> directly, unless you are using a differential-algebraic equation. The docstring for <code>fvm_eqs!</code> is below; this function is public API.</p><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.fvm_eqs!" href="#FiniteVolumeMethod.fvm_eqs!"><code>FiniteVolumeMethod.fvm_eqs!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fvm_eqs!(du, u, p, t)</code></pre><p>Computes the finite volume method equations for the current time <code>t</code>  and solution <code>u</code>. This function is public API.</p><p>The argument <code>p</code> depends on whether the problem is being solved  in parallel or not. If it is solved serially, than the fields are:</p><ul><li><code>p.prob</code>: The <code>prob &lt;: AbstractFVMProblem</code>.</li><li><code>p.parallel</code>: <code>Val(false)</code>.</li></ul><p>If the problem is solved in parallel, then the fields are:</p><ul><li><code>p.prob</code>: The <code>prob &lt;: AbstractFVMProblem</code>.</li><li><code>p.parallel</code>: <code>Val(true)</code>.   </li><li><code>p.duplicated_du</code>: A <code>Matrix</code> of the same size as <code>du</code> that is used to store the contributions to <code>du</code> from each thread. </li><li><code>p.solid_triangles</code>: A <code>Vector</code> of the solid triangles in the triangulation.</li><li><code>p.solid_vertices</code>: A <code>Vector</code> of the solid vertices in the triangulation.</li><li><code>p.chunked_solid_triangles</code>: A <code>Vector</code> of tuples of the form <code>(range, chunk_idx)</code> where <code>range</code> is a range of indices into <code>p.solid_triangles</code> and <code>chunk_idx</code> is the index of the chunk.</li><li><code>p.boundary_edges</code>: A <code>Vector</code> of the boundary edges in the triangulation.</li><li><code>p.chunked_boundary_edges</code>: A <code>Vector</code> of tuples of the form <code>(range, chunk_idx)</code> where <code>range</code> is a range of indices into <code>p.boundary_edges</code> and <code>chunk_idx</code> is the index of the chunk.</li></ul><p>These fields are public API, although note that they are not intended to be modified by the user, and we may freely  add in new fields over new versions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/e0c41ee12ce75f31dd4f24fccfb8744ca8e51a27/src/equations/main_equations.jl#L2-L27">source</a></section></article><h1 id="Custom-constraints"><a class="docs-heading-anchor" href="#Custom-constraints">Custom constraints</a><a id="Custom-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-constraints" title="Permalink"></a></h1><p>You can also provide custom constraints. Rather than outlining this precisely here, it is best explained in the tutorials, namely <a href="../tutorials/solving_mazes_with_laplaces_equation/">this tutorial</a>. We note that one useful function for this is <code>compute_flux</code>, which allows you to compute the flux across a given edge. The docstring for <code>compute_flux</code> is below, and this function is public API.</p><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.compute_flux" href="#FiniteVolumeMethod.compute_flux"><code>FiniteVolumeMethod.compute_flux</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_flux(prob::AbstractFVMProblem, i, j, u, t)</code></pre><p>Given an edge with indices <code>(i, j)</code>, a solution vector <code>u</code>, a current time <code>t</code>,  and a problem <code>prob</code>, computes the flux <code>∇⋅q(x, y, t, α, β, γ, p) ⋅ n</code>,  where <code>n</code> is the normal vector to the edge, <code>q</code> is the flux function from <code>prob</code>, <code>(x, y)</code> is the midpoint of the edge, <code>(α, β, γ)</code> are the shape function coefficients,  and <code>p</code> are the flux parameters from <code>prob</code>. If <code>prob</code> is an <a href="#FiniteVolumeMethod.FVMSystem"><code>FVMSystem</code></a>, the returned  value is a <code>Tuple</code> for each individual flux. The normal vector <code>n</code> is a clockwise rotation of  the edge, meaning pointing right of the edge <code>(i, j)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/e0c41ee12ce75f31dd4f24fccfb8744ca8e51a27/src/problem.jl#L296-L306">source</a></section></article><h1 id="Piecewise-linear-interpolation"><a class="docs-heading-anchor" href="#Piecewise-linear-interpolation">Piecewise linear interpolation</a><a id="Piecewise-linear-interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Piecewise-linear-interpolation" title="Permalink"></a></h1><p>You can evaluate the piecewise linear interpolation corresponding to a solution using <code>pl_interpolate</code>, defined below; this function is public API.</p><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.pl_interpolate" href="#FiniteVolumeMethod.pl_interpolate"><code>FiniteVolumeMethod.pl_interpolate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pl_interpolate(prob, T, u, x, y)</code></pre><p>Given a <code>prob &lt;: AbstractFVMProblem</code>, a triangle <code>T</code> containing a point <code>(x, y)</code>,  and a set of function values <code>u</code> at the corresponding nodes of <code>prob</code>, interpolates  the solution at the point <code>(x, y)</code> using piecewise linear interpolation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/e0c41ee12ce75f31dd4f24fccfb8744ca8e51a27/src/utils.jl#L13-L19">source</a></section></article><p>Better interpolants are available from <a href="https://github.com/DanielVandH/NaturalNeighbours.jl">NaturalNeighbours.jl</a> - see the <a href="../tutorials/piecewise_linear_and_natural_neighbour_interpolation_for_an_advection_diffusion_equation/">this tutorial</a> for some examples.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../tutorials/overview/">Section Overview »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Sunday 10 September 2023 07:35">Sunday 10 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
