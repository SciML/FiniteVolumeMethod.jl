<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · FiniteVolumeMethod.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://DanielVandH.github.io/FiniteVolumeMethod.jl/docstrings/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FiniteVolumeMethod.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../interface/">Interface</a></li><li class="is-active"><a class="tocitem" href>Docstrings</a><ul class="internal"><li><a class="tocitem" href="#FVMGeometry"><span>FVMGeometry</span></a></li><li><a class="tocitem" href="#BoundaryConditions"><span>BoundaryConditions</span></a></li><li><a class="tocitem" href="#FVMProblem"><span>FVMProblem</span></a></li><li><a class="tocitem" href="#Solving-the-FVMProblem"><span>Solving the FVMProblem</span></a></li><li><a class="tocitem" href="#Linear-Interpolants"><span>Linear Interpolants</span></a></li></ul></li><li><a class="tocitem" href="../example_list/">List of Examples and Setup</a></li><li><a class="tocitem" href="../diffusion_equation/">Example I: Diffusion equation on a square plate</a></li><li><a class="tocitem" href="../diffusion_equation_on_a_wedge/">Example II: Diffusion equation in a wedge with mixed boundary conditions</a></li><li><a class="tocitem" href="../reaction_diffusion/">Example III: Reaction-diffusion equation with a time-dependent Dirichlet boundary condition on a disk</a></li><li><a class="tocitem" href="../porous_medium/">Example IV: Porous-medium equation</a></li><li><a class="tocitem" href="../porous_fisher/">Example V: Porous-Fisher equation and travelling waves</a></li><li><a class="tocitem" href="../interpolants/">Example VI: Using the linear interpolants</a></li><li><a class="tocitem" href="../annulus/">Example VII: Diffusion equation on an annulus</a></li><li><a class="tocitem" href="../laplace/">Example VIII: Laplace&#39;s equation</a></li><li><a class="tocitem" href="../mean_exit_time/">Example IX: Mean exit time problems</a></li><li><a class="tocitem" href="../math/">Mathematical Details</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Docstrings</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Docstrings</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/main/docs/src/docstrings.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Docstrings"><a class="docs-heading-anchor" href="#Docstrings">Docstrings</a><a id="Docstrings-1"></a><a class="docs-heading-anchor-permalink" href="#Docstrings" title="Permalink"></a></h1><p>Here we give some of the main docstrings.</p><h2 id="FVMGeometry"><a class="docs-heading-anchor" href="#FVMGeometry">FVMGeometry</a><a id="FVMGeometry-1"></a><a class="docs-heading-anchor-permalink" href="#FVMGeometry" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.FVMGeometry" href="#FiniteVolumeMethod.FVMGeometry"><code>FiniteVolumeMethod.FVMGeometry</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FVMGeometry{EL,P,Adj,Adj2V,NGH,TAR,N,BE,IEBEI,T,CT,VS,SS,CS,FT}</code></pre><p>Geometric information about the underlying triangular mesh, as needed for the finite volume method. </p><p><strong>Fields</strong></p><ul><li><code>mesh_information::MeshInformation</code></li></ul><p>Information about the underlying triangular mesh; see <a href="#FiniteVolumeMethod.MeshInformation"><code>MeshInformation</code></a>.</p><ul><li><code>boundary_information::BoundaryInformation</code></li></ul><p>Information about the boundary of the underlying triangular mesh; see <a href="#FiniteVolumeMethod.BoundaryInformation"><code>BoundaryInformation</code></a>.</p><ul><li><code>interior_information::InteriorInformation</code></li></ul><p>Information about the interior of the underlying triangular mesh; see <a href="#FiniteVolumeMethod.InteriorInformation"><code>InteriorInformation</code></a>.</p><ul><li><code>element_information_list::Dict{T, ElementInformation}</code></li></ul><p>List that maps each element to the information about that mesh; see <a href="#FiniteVolumeMethod.ElementInformation"><code>ElementInformation</code></a>.</p><ul><li><code>volumes::Dict{Int64,FT}</code></li></ul><p>Maps node indices to the volume of its corresponding control volume.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">FVMGeometry(tri::Triangulation;
    coordinate_type=Vector{number_type(pts)},
    control_volume_storage_type_vector=NTuple{3,coordinate_type},
    control_volume_storage_type_scalar=NTuple{3,number_type(pts)},
    shape_function_coefficient_storage_type=NTuple{9,number_type(pts)},
    interior_edge_storage_type=NTuple{2,Int64},
    interior_edge_pair_storage_type=NTuple{2,interior_edge_storage_type}) where {Ts}</code></pre><p>Constructor for <a href="#FiniteVolumeMethod.FVMGeometry"><code>FVMGeometry</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The mesh.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>coordinate_type=Vector{number_type(pts)}</code>: How coordinates are represented.</li><li><code>control_volume_storage_type_vector=NTuple{3,coordinate_type}</code>: How information for triples of coordinates is represented. The element type must be <code>coordinate_type</code>.</li><li><code>control_volume_storage_type_scalar=NTuple{3,number_type(pts)}</code>: How information triples of scalars is represented. The element type must be the same as the element type used for <code>pts</code>.</li><li><code>shape_function_coefficient_storage_type=NTuple{9,number_type(pts)}</code>: How the nine shape function coefficients for each element are stored. The element type must be the same as the element type used for <code>pts</code>.</li><li><code>interior_edge_storage_type=NTuple{2,Int64}</code>: How the tuples <code>(v, j)</code>, as defined for the interior edge identifier in <a href="#FiniteVolumeMethod.InteriorInformation"><code>InteriorInformation</code></a>, are stored.</li><li><code>interior_edge_pair_storage_type=NTuple{2,interior_edge_storage_type}</code>: How the list of tuples for the interior edge tuples, as defined for the interior edge identifier in <a href="#FiniteVolumeMethod.InteriorInformation"><code>InteriorInformation</code></a>, are stored. The element type must be <code>interior_edge_pair_storage_type</code>.</li></ul><p><strong>Outputs</strong></p><p>The returned value is the <a href="#FiniteVolumeMethod.FVMGeometry"><code>FVMGeometry</code></a> object storing information about the underlying triangular mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/8e9dc81beb41f1936d77410a5eb3619bc83255e6/src/geometry.jl#L217-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.MeshInformation" href="#FiniteVolumeMethod.MeshInformation"><code>FiniteVolumeMethod.MeshInformation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MeshInformation{T&lt;:Triangulation,TAR}</code></pre><p>Information about the underlying triangular mesh. </p><p><strong>Fields</strong></p><ul><li><code>triangulation::T</code></li></ul><p>The mesh, given with <code>T &lt;: Triangulation</code>.</p><ul><li><code>total_area::TAR</code></li></ul><p>The total area of the mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/8e9dc81beb41f1936d77410a5eb3619bc83255e6/src/geometry.jl#L102-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.BoundaryInformation" href="#FiniteVolumeMethod.BoundaryInformation"><code>FiniteVolumeMethod.BoundaryInformation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoundaryInformation{N,BE}</code></pre><p>Information for the boundary of the domain.</p><p><strong>Fields</strong></p><ul><li><code>edge_information::BoundaryEdgeMatrix</code>: The <a href="#FiniteVolumeMethod.BoundaryEdgeMatrix"><code>BoundaryEdgeMatrix</code></a>.</li><li><code>normal_information::OutwardNormalBoundary{N}</code>: The <a href="#FiniteVolumeMethod.OutwardNormalBoundary"><code>OutwardNormalBoundary</code></a>.</li><li><code>boundary_nodes::Vector{Int64}</code>: The indices for the nodes on the boundary, collected into a single vector.</li><li><code>boundary_elements::BE</code>: The elements of the underlying triangular mesh that share at least one edge with the boundary.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/8e9dc81beb41f1936d77410a5eb3619bc83255e6/src/geometry.jl#L55-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.BoundaryEdgeMatrix" href="#FiniteVolumeMethod.BoundaryEdgeMatrix"><code>FiniteVolumeMethod.BoundaryEdgeMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoundaryEdgeMatrix</code></pre><p>Information for the boundary edges. Boundaries are to be interpreted according to the specification in  DelaunayTriangulation.jl.</p><p><strong>Fields</strong></p><ul><li><code>left_nodes::Vector{Int64}</code>: The left nodes for each edge, given as indices for the points.</li><li><code>right_nodes::Vector{Int64}</code>: The right nodes for each edge, given as indices for the points. (Actually, this orientation switches on inner boundaries since those are oriented clockwise rather than counter-clockwise.)</li><li><code>adjacent_nodes::Vector{Int64}</code>: The adjacent node to each edge, i.e. the node such that <code>(left_nodes[i], right_nodes[i], adjacent_nodes[i])</code> is a positively oriented triangle in the underlying triangular mesh.</li><li><code>types::Vector{Int64}</code>: The boundaries are split into segments, so <code>types[i]</code> says what segment number the <code>i</code>th edge is on.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/8e9dc81beb41f1936d77410a5eb3619bc83255e6/src/geometry.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.OutwardNormalBoundary" href="#FiniteVolumeMethod.OutwardNormalBoundary"><code>FiniteVolumeMethod.OutwardNormalBoundary</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OutwardNormalBoundary{N}</code></pre><p>Information for the unit outward normal vector field on the boundary. </p><p><strong>Fields</strong></p><ul><li><code>x_normals::N</code>: The x-coordinates for the tail of each normal vector, with <code>x_normals[i]</code> the coordinate for the <code>i</code>th edge.</li><li><code>y_normals::N</code>: The y-coordinates for the tail of each normal vector, with <code>x_normals[i]</code> the coordinate for the <code>i</code>th edge. </li><li><code>types::Vector{Int64}</code>: As in <a href="#FiniteVolumeMethod.BoundaryEdgeMatrix"><code>BoundaryEdgeMatrix</code></a>, <code>types[i]</code> says what segment number the <code>i</code>th edge is on.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/8e9dc81beb41f1936d77410a5eb3619bc83255e6/src/geometry.jl#L33-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.InteriorInformation" href="#FiniteVolumeMethod.InteriorInformation"><code>FiniteVolumeMethod.InteriorInformation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InteriorInformation{EL,IEBEI}</code></pre><p>Information for the interior of the domain. </p><p><strong>Fields</strong></p><ul><li><code>nodes::Vector{Int64}</code></li></ul><p>Indices for the all the nodes that are in the interior of the domain. </p><ul><li><code>elements::EL</code></li></ul><p>The elements of the underlying triangular mesh that share no edges with the boundary. </p><ul><li><code>interior_edge_boundary_element_identifier::IEBEI</code></li></ul><p>Given a boundary element <code>V</code> (see <a href="#FiniteVolumeMethod.BoundaryInformation"><code>BoundaryInformation</code></a>), this maps <code>V</code> to a list of tuples of the form <code>((v₁, j₁), (v₂, j₂))</code>, where <code>(v₁, v₂)</code> is an edge such that <code>v₁</code> is a boundary node and <code>v₂</code> is an interior node, and <code>j₁</code> and <code>j₂</code> give the positions of <code>v₁</code> and <code>v₂</code>, respectively, in <code>V</code>, e.g. <code>V[j₁] == v₁</code>. See also <a href="#FiniteVolumeMethod.construct_interior_edge_boundary_element_identifier"><code>construct_interior_edge_boundary_element_identifier</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/8e9dc81beb41f1936d77410a5eb3619bc83255e6/src/geometry.jl#L77-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.construct_interior_edge_boundary_element_identifier" href="#FiniteVolumeMethod.construct_interior_edge_boundary_element_identifier"><code>FiniteVolumeMethod.construct_interior_edge_boundary_element_identifier</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">construct_interior_edge_boundary_element_identifier(boundary_elements, boundary_edges, tri;
    interior_edge_storage_type, interior_edge_pair_storage_type)</code></pre><p>Creates a <code>Dict</code> that maps a set of nodal indices <code>v</code> for some boundary element to the the  interior edges, represented as <code>((v₁, j₁), (v₂, j₂))</code> (a vector of), with <code>v[j₁] = v₁ → v[j₂] = v₂</code> an edge of the element that  is in the interior.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/8e9dc81beb41f1936d77410a5eb3619bc83255e6/src/geometry.jl#L600-L607">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.ElementInformation" href="#FiniteVolumeMethod.ElementInformation"><code>FiniteVolumeMethod.ElementInformation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ElementInformation{CoordinateType,VectorStorage,ScalarStorage,CoefficientStorage,FloatType}</code></pre><p>Information for an individual element.</p><p><strong>Fields</strong></p><ul><li><code>centroid::CoordinateType</code></li></ul><p>The centroid of the element. </p><ul><li><code>midpoints::VectorStorage</code></li></ul><p>The coordinates for the midpoints of each edge. </p><ul><li><code>control_volume_edge_midpoints::VectorStorage</code></li></ul><p>For each edge, this is the midpoint of the line that connects the edge to the centroid. </p><ul><li><code>lengths::ScalarStorage</code></li></ul><p>The lengths for each edge. </p><ul><li><code>shape_function_coefficients::CoefficientStorage</code></li></ul><p>These are the <code>sᵢⱼ</code> coefficients for the element; see their definition in the README.</p><ul><li><code>normals::VectorStorage</code></li></ul><p>The outward unit normals to each edge.</p><ul><li><code>area::FloatType</code></li></ul><p>The area of the element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/8e9dc81beb41f1936d77410a5eb3619bc83255e6/src/geometry.jl#L128-L155">source</a></section></article><h2 id="BoundaryConditions"><a class="docs-heading-anchor" href="#BoundaryConditions">BoundaryConditions</a><a id="BoundaryConditions-1"></a><a class="docs-heading-anchor-permalink" href="#BoundaryConditions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.BoundaryConditions" href="#FiniteVolumeMethod.BoundaryConditions"><code>FiniteVolumeMethod.BoundaryConditions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoundaryConditions{Tri,F,P,DN,NN,DuN,INN,BMI,MBI,TM}</code></pre><p>Information representing the boundary conditions for the PDE. </p><p><strong>Fields</strong></p><ul><li><code>triangulation::Tri</code></li></ul><p>The mesh.</p><ul><li><code>functions::F</code></li></ul><p>The <code>Tuple</code> of boundary condition functions for each boundary segment, with <code>functions[i]</code> corresponding to the <code>i</code>th segment. These functions must take the form <code>f(x, y, t, u, p)</code>.</p><ul><li><code>parameters::P</code></li></ul><p>The <code>Tuple</code> of arguments <code>p</code> for each boundary condition function, with <code>parameters[i]</code> corresponding to <code>functions[i]</code>.</p><ul><li><code>dirichlet_nodes::DN</code></li></ul><p>The indices of the nodes on the boundary that are of Dirichlet type. </p><ul><li><code>neumann_nodes::NN</code></li></ul><p>The indices of the nodes on the boundary that are of Neumann type. </p><ul><li><code>dudt_nodes::DuN</code></li></ul><p>The indices of the nodes on the boundary that are of time-dependent Dirichlet type, i.e. of the form <code>du/dt = f(x, y, t, u, p)</code>.</p><ul><li><code>interior_or_neumann_nodes</code>::INN`</li></ul><p>The nodes that are either interior or neumann nodes. </p><ul><li><code>boundary_to_mesh_idx::BMI</code></li></ul><p>If the boundary nodes are in the order <code>(b₁, b₂, …, bᵢ, …)</code>, then this is a map that takes the index order <code>i</code> to the corresponding index in the mesh, i.e. to <code>bᵢ</code>.</p><ul><li><code>mesh_to_boundary_idx::MBI</code></li></ul><p>The inverse map of <code>boundary_to_mesh_idx</code>.</p><ul><li><code>type_map::TM</code></li></ul><p>Given a node, maps it to the segment number that it belongs to.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">BoundaryConditions(mesh::FVMGeometry, functions, types;
    params=Tuple(nothing for _ in (functions isa Function ? [1] : eachindex(functions))),
    u_type=Float64, float_type=Float64)</code></pre><p>Constructor for the <a href="#FiniteVolumeMethod.BoundaryConditions"><code>BoundaryConditions</code></a> struct. </p><p><strong>Arguments</strong></p><ul><li><code>mesh::FVMGeometry</code>: The <a href="#FiniteVolumeMethod.FVMGeometry"><code>FVMGeometry</code></a> for the mesh. </li><li><code>functions</code>: The functions for each boundary segment, taking the forms <code>f(x, y, t, u, p)</code>. Can be a single function, doesn&#39;t have to be in a container (as long as only one segment is needed).</li><li><code>types</code>: The classification for the boundary condition type on each segment. See <a href="#FiniteVolumeMethod.is_dirichlet_type"><code>is_dirichlet_type</code></a>, <a href="#FiniteVolumeMethod.is_neumann_type"><code>is_neumann_type</code></a>, and <a href="#FiniteVolumeMethod.is_dudt_type"><code>is_dudt_type</code></a> for the possible values here. <code>types[i]</code> is the classification for the <code>i</code>th segment. </li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>params=Tuple(nothing for _ in (functions isa Function ? [1] : eachindex(functions)))</code>: The parameters for the functions, with <code>params[i]</code> giving the argument <code>p</code> in <code>functions[i]</code>.</li><li><code>u_type=Float64</code>: The number type used for the solution. </li><li><code>float_type=Float64</code>: The number type used for representing the coordinates of points. </li></ul><p><strong>Outputs</strong></p><p>The returned value is the corresponding <a href="#FiniteVolumeMethod.BoundaryConditions"><code>BoundaryConditions</code></a> struct. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/8e9dc81beb41f1936d77410a5eb3619bc83255e6/src/boundary_conditions.jl#L33-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.is_dirichlet_type" href="#FiniteVolumeMethod.is_dirichlet_type"><code>FiniteVolumeMethod.is_dirichlet_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_dirichlet_type(type)</code></pre><p>Returns <code>type ∈ (:Dirichlet, :D, :dirichlet, &quot;Dirichlet&quot;, &quot;D&quot;, &quot;dirichlet&quot;)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/8e9dc81beb41f1936d77410a5eb3619bc83255e6/src/boundary_conditions.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.is_neumann_type" href="#FiniteVolumeMethod.is_neumann_type"><code>FiniteVolumeMethod.is_neumann_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_neumann_type(type)</code></pre><p>Returns <code>type ∈ (:Neumann, :N, :neumann, &quot;Neumann&quot;, &quot;N&quot;, &quot;neumann&quot;)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/8e9dc81beb41f1936d77410a5eb3619bc83255e6/src/boundary_conditions.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.is_dudt_type" href="#FiniteVolumeMethod.is_dudt_type"><code>FiniteVolumeMethod.is_dudt_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_dudt_type(type)</code></pre><p>Returns <code>type ∈ (:Dudt, :dudt, &quot;Dudt&quot;, &quot;dudt&quot;, &quot;du/dt&quot;)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/8e9dc81beb41f1936d77410a5eb3619bc83255e6/src/boundary_conditions.jl#L13-L17">source</a></section></article><h2 id="FVMProblem"><a class="docs-heading-anchor" href="#FVMProblem">FVMProblem</a><a id="FVMProblem-1"></a><a class="docs-heading-anchor-permalink" href="#FVMProblem" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.FVMProblem" href="#FiniteVolumeMethod.FVMProblem"><code>FiniteVolumeMethod.FVMProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FVMProblem{iip_flux,FG,BC,F,FP,R,RP,IC,FT}</code></pre><p>Struct representing the PDE problem. </p><p><strong>Fields</strong></p><ul><li><code>mesh::FG</code></li></ul><p>The underlying mesh, given as a <a href="#FiniteVolumeMethod.FVMGeometry"><code>FVMGeometry</code></a> struct. </p><ul><li><code>boundary_conditions::BC</code></li></ul><p>The boundary conditions, given a a <a href="#FiniteVolumeMethod.BoundaryConditions"><code>BoundaryConditions</code></a> struct. </p><ul><li><code>flux_function::F</code></li></ul><p>The function for the flux vector, taking either of the forms <code>flux!(q, x, y, t, α, β, γ, p)</code> (if <code>iip_flux</code>) and <code>flux(x, y, t, α, β, γ, p)</code> (if <code>!iip_flux</code>), where <code>u = αx + βy + γ</code>.</p><ul><li><code>flux_parameters::FP</code></li></ul><p>The argument <code>p</code> in <code>flux_function</code>.</p><ul><li><code>reaction_function::R</code></li></ul><p>The function for the reaction term, taking the form <code>R(x, y, t, u, p)</code>.</p><ul><li><code>reaction_parameters::RP</code></li></ul><p>The argument <code>p</code> in <code>reaction_function</code>.</p><ul><li><code>initial_condition::IC</code></li></ul><p>The initial condition for the problem, with <code>initial_condition[i]</code> the initial value at the <code>i</code>th node of the mesh. </p><ul><li><code>initial_time::FT</code></li></ul><p>The time to start solving the PDE at. </p><ul><li><code>final_time::FT</code></li></ul><p>The time to stop solving the PDE at. </p><ul><li><code>steady::Bool</code></li></ul><p>Whether <code>∂u/∂t = 0</code> or not. When this is <code>true</code>, the problem is defined as a <code>NonlinearProblem</code> with initial guess coming  from the initial condition above.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">FVMProblem(mesh, boundary_conditions;
    iip_flux=true,
    diffusion_function=nothing,
    diffusion_parameters=nothing,
    reaction_function=nothing,
    reaction_parameters=nothing,
    delay_function=nothing,
    delay_parameters=nothing,
    flux_function=nothing,
    flux_parameters=nothing,
    initial_condition,
    initial_time=0.0,
    final_time,
    steady=false,
    q_storage=SVector{2,Float64})</code></pre><p>Constructor for the <a href="#FiniteVolumeMethod.FVMProblem"><code>FVMProblem</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>mesh</code>: The <a href="#FiniteVolumeMethod.FVMGeometry"><code>FVMGeometry</code></a> representing the underlying mesh. </li><li><code>boundary_conditions</code>: The <a href="#FiniteVolumeMethod.BoundaryConditions"><code>BoundaryConditions</code></a> representing the boundary conditions for the problem. </li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>iip_flux=true</code>: Whether the flux vector is computed in-place or not.</li><li><code>diffusion_function=nothing</code>: If <code>flux_function===nothing</code>, this can be used to provide a diffusion term for the reaction-diffusion formulation, taking the form <code>D(x, y, t, u, p)</code>. See also <a href="#FiniteVolumeMethod.construct_flux_function"><code>construct_flux_function</code></a>.</li><li><code>diffusion_parameters=nothing</code>: The argument <code>p</code> in the diffusion function. </li><li><code>reaction_function=nothing</code>: The reaction term, taking the form <code>R(x, y, t, u, p)</code>. If not provided, it is set to the zero function. See also <a href="#FiniteVolumeMethod.construct_reaction_function"><code>construct_reaction_function</code></a>.</li><li><code>reaction_parameters=nothing</code>: The argument <code>p</code> in the reaction function. </li><li><code>delay_function=nothing</code>: The delay function <code>T(x, y, t, u, p)</code> for the PDE that can be used to scale the diffusion and reaction functions, assuming <code>flux_function===nothing</code>. See also <a href="#FiniteVolumeMethod.construct_reaction_function"><code>construct_reaction_function</code></a> and <a href="#FiniteVolumeMethod.construct_flux_function"><code>construct_flux_function</code></a>.</li><li><code>delay_parameters=nothing</code>: The argument <code>p</code> in the delay function. </li><li><code>flux_function=nothing</code>: The flux function, taking either of the forms <code>flux!(q, x, y, t, α, β, γ, p)</code> (if <code>iip_flux</code>) and <code>flux(x, y, t, α, β, γ, p)</code> (if <code>!iip_flux</code>), where <code>u = αx + βy + γ</code>. If <code>flux_function===nothing</code>, thne this function is constructed from the diffusion and delay functions. </li><li><code>flux_parameters=nothing</code>: The argument <code>p</code> in the flux function. </li><li><code>initial_condition</code>: The initial condition for the problem, with <code>initial_condition[i]</code> the initial value at the <code>i</code>th node of the mesh. </li><li><code>initial_time=0.0</code>: The time to start solving the PDE at. </li><li><code>final_time</code>: The time to stop solving the PDE at. </li><li><code>steady::Bool</code>: Whether <code>∂u/∂t = 0</code> or not. If the problem is steady, then the initial estimate used for the nonlinear solver that finds the steady state is given by the initial condition, and <code>final_time</code> is set to <code>∞</code>.</li></ul><p><strong>Outputs</strong></p><p>Returns the <a href="#FiniteVolumeMethod.FVMProblem"><code>FVMProblem</code></a> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/8e9dc81beb41f1936d77410a5eb3619bc83255e6/src/problem.jl#L14-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.construct_flux_function" href="#FiniteVolumeMethod.construct_flux_function"><code>FiniteVolumeMethod.construct_flux_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">construct_flux_function(iip_flux,
    flux_function,
    delay_function, delay_parameters,
    diffusion_function, diffusion_parameters)</code></pre><p>Constructs the flux function. The arguments are as in <a href="#FiniteVolumeMethod.FVMProblem"><code>FVMProblem</code></a>, and the output depends on the following, where <code>D</code> denotes the diffusion function, <code>T</code> the delay function, <code>dₚ</code> the diffusion parameters, and <code>tₚ</code> the delay parameters: </p><ul><li>If <code>flux_function===nothing</code> and <code>delay_function===nothing</code>, defines the flux function as <code>(x, y, t, α, β, γ, _) -&gt; -D(x, y, t, αx + βy + γ, dₚ)[α, β]</code>.</li><li>If <code>flux_function===nothing</code>, defines the flux function as <code>(x, y, t, α, β, γ, _) -&gt; -T(x, y, t, αx + βy + γ, tₚ)D(x, y, t, αx + βy + γ, dₚ)[α, β]</code>.</li></ul><p>If <code>iip_flux</code>, then the functions above have an extra argument in the first position, <code>q</code>, that the flux vectors are stored in. Otherwise, the flux vector is  returned as a tuple <code>(q1, q2)</code>. If <code>flux_function !== nothing</code>, then just returns <code>flux_function</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/8e9dc81beb41f1936d77410a5eb3619bc83255e6/src/problem.jl#L136-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.construct_reaction_function" href="#FiniteVolumeMethod.construct_reaction_function"><code>FiniteVolumeMethod.construct_reaction_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">construct_reaction_function(reaction_function, reaction_parameters,
    delay_function, delay_parameters)</code></pre><p>Constructs the reaction function. The arguments are as in <a href="#FiniteVolumeMethod.FVMProblem"><code>FVMProblem</code></a>, and the output depends on the following, where <code>R</code>             denotes the reaction function, <code>T</code> the delay function, <code>rₚ</code> the reaction parameters, and <code>tₚ</code> the delay parameters: </p><ul><li>If <code>reaction_function===nothing</code>, defines the reaction function as <code>(x, y, t, u, _) = 0.0</code>.</li><li>If <code>reaction_function !== nothing</code> and <code>delay_function !== nothing</code>, defines the reaction function as <code>(x, y, t, u, _) -&gt; T(x, y, t, u, tₚ)R(x, y, t, u, rₚ)</code>.</li><li>Otherwise, just returns <code>reaction_function</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/8e9dc81beb41f1936d77410a5eb3619bc83255e6/src/problem.jl#L200-L210">source</a></section></article><h2 id="Solving-the-FVMProblem"><a class="docs-heading-anchor" href="#Solving-the-FVMProblem">Solving the FVMProblem</a><a id="Solving-the-FVMProblem-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-the-FVMProblem" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CommonSolve.solve" href="#CommonSolve.solve"><code>CommonSolve.solve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">SciMLBase.solve(prob::FVMProblem, alg;
    cache_eltype::Type{F}=eltype(get_initial_condition(prob)),
    jac_prototype=float.(jacobian_sparsity(prob)),
    parallel=false,
    specialization::Type{S}=SciMLBase.AutoSpecialize,
    chunk_size=PreallocationTools.ForwardDiff.pickchunksize(length(get_initial_condition(prob))),
    kwargs...)</code></pre><p>Solves the <a href="#FiniteVolumeMethod.FVMProblem"><code>FVMProblem</code></a> given by <code>prob</code> using the algorithm <code>alg</code>.</p><p><strong>Arguments</strong></p><ul><li><code>prob::FVMProblem</code>: The <a href="#FiniteVolumeMethod.FVMProblem"><code>FVMProblem</code></a>.</li><li><code>alg</code>: The algorithm to use for solving. See the DifferentialEquations.jl documentation for this. If your problem is a steady problem, then you should use an algorithm from NonlinearSolve.jl instead - note that the initial estimate in this case comes from the initial condition.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>cache_eltype::Type{F}=eltype(get_initial_condition(prob))</code>: The element type used for the cache vectors. </li><li><code>jac_prototype=float.(jacobian_sparsity(prob))</code>: The prototype for the sparsity pattern of the Jacobian. </li><li><code>parallel=false</code>: Whether to use multithreading for evaluating the equations. Not currently used.</li><li><code>specialization::Type{S}=SciMLBase.AutoSpecialize</code>: The specialisation level for the <code>ODEProblem</code>.</li><li><code>chunk_size=PreallocationTools.ForwardDiff.pickchunksize(length(get_initial_condition(prob))))</code>: The chunk size for the dual numbers used in the cache vector.</li><li><code>kwargs...</code>: Extra keyword arguments for <code>solve</code> as used on <code>ODEProblem</code>s (or <code>NonlinearProblem</code>s if your problem is steady).</li></ul><p><strong>Output</strong></p><p>The output is a solution struct, as returned from DifferentialEquations.jl. If instead your problem is steady, returns a  solution struct as returned from NonlinearSolve.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/8e9dc81beb41f1936d77410a5eb3619bc83255e6/src/solve.jl#L112-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.ODEProblem" href="#SciMLBase.ODEProblem"><code>SciMLBase.ODEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SciMLBase.ODEProblem(prob::FVMProblem;
    cache_eltype::Type{F}=eltype(get_initial_condition(prob)),
    jac_prototype=float.(jacobian_sparsity(prob)),
    parallel=false,
    no_saveat=true,
    specialization::Type{S}=SciMLBase.AutoSpecialize,
    chunk_size=PreallocationTools.ForwardDiff.pickchunksize(length(get_initial_condition(prob)))) where {S,F}</code></pre><p>Constructs the <code>ODEProblem</code> for the system of ODEs defined by the finite volume equations corresponding to <code>prob</code>.</p><p><strong>Arguments</strong></p><ul><li><code>prob::FVMProblem</code>: The <a href="#FiniteVolumeMethod.FVMProblem"><code>FVMProblem</code></a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>cache_eltype::Type{F}=eltype(get_initial_condition(prob))</code>: The element type used for the cache vectors. </li><li><code>jac_prototype=float.(jacobian_sparsity(prob))</code>: The prototype for the sparsity pattern of the Jacobian. </li><li><code>parallel=false</code>: Whether to use multithreading for evaluating the equations.</li><li><code>no_saveat=true</code>: Whether the solution is saving at specific points. </li><li><code>specialization::Type{S}=SciMLBase.AutoSpecialize</code>: The specialisation level for the <code>ODEProblem</code>.</li><li><code>chunk_size=PreallocationTools.ForwardDiff.pickchunksize(length(get_initial_condition(prob))))</code>: The chunk size for the dual numbers used in the cache vector.</li></ul><p><strong>Outputs</strong></p><p>Returns the corresponding <a href="#SciMLBase.ODEProblem"><code>ODEProblem</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/8e9dc81beb41f1936d77410a5eb3619bc83255e6/src/solve.jl#L34-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.jacobian_sparsity" href="#FiniteVolumeMethod.jacobian_sparsity"><code>FiniteVolumeMethod.jacobian_sparsity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">jacobian_sparsity(prob::FVMProblem)</code></pre><p>Constructs the sparse matrix which has the same sparsity pattern as the Jacobian for the finite volume equations  corresponding to the <a href="#FiniteVolumeMethod.FVMProblem"><code>FVMProblem</code></a> given by <code>prob</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/8e9dc81beb41f1936d77410a5eb3619bc83255e6/src/solve.jl#L7-L12">source</a></section></article><h2 id="Linear-Interpolants"><a class="docs-heading-anchor" href="#Linear-Interpolants">Linear Interpolants</a><a id="Linear-Interpolants-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Interpolants" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FiniteVolumeMethod.eval_interpolant" href="#FiniteVolumeMethod.eval_interpolant"><code>FiniteVolumeMethod.eval_interpolant</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eval_interpolant!(αβγ, prob::FVMProblem, x, y, T, u)
eval_interpolant(sol, x, y, t_idx::Integer, T)
eval_interpolant(sol, x, y, t::Number, T)</code></pre><p>Evaluates the interpolant corresponding to the <code>FVMProblem</code> at the point <code>(x, y)</code> and time <code>t</code> (or <code>sol.t[t_idx]</code>). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/FiniteVolumeMethod.jl/blob/8e9dc81beb41f1936d77410a5eb3619bc83255e6/src/interpolant.jl#L1-L8">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../interface/">« Interface</a><a class="docs-footer-nextpage" href="../example_list/">List of Examples and Setup »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 13 April 2023 00:56">Thursday 13 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
